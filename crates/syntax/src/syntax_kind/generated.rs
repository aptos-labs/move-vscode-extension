//! Generated by `cargo codegen`, do not edit by hand.

#![allow(bad_style, missing_docs, unreachable_pub)]
#[doc = r" The kind of syntax node, e.g. `IDENT`, `USE_KW`, or `STRUCT`."]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
#[repr(u16)]
pub enum SyntaxKind {
    #[doc(hidden)]
    TOMBSTONE,
    #[doc(hidden)]
    EOF,
    SEMICOLON,
    COMMA,
    L_PAREN,
    R_PAREN,
    L_CURLY,
    R_CURLY,
    L_BRACK,
    R_BRACK,
    L_ANGLE,
    R_ANGLE,
    AT,
    POUND,
    AMP,
    PIPE,
    PLUS,
    STAR,
    SLASH,
    CARET,
    PERCENT,
    UNDERSCORE,
    DOT,
    DOT_DOT,
    COLON,
    COLON_COLON,
    EQ,
    EQ_EQ,
    FAT_ARROW,
    IMPLIES,
    LESS_IMPLIES,
    BANG,
    NOT_EQ,
    MINUS,
    LT_EQ,
    GT_EQ,
    PLUS_EQ,
    MINUS_EQ,
    PIPE_EQ,
    AMP_EQ,
    CARET_EQ,
    SLASH_EQ,
    STAR_EQ,
    PERCENT_EQ,
    AMP_AMP,
    PIPE_PIPE,
    SHL,
    SHR,
    SHL_EQ,
    SHR_EQ,
    ADDRESS_KW,
    MODULE_KW,
    SCRIPT_KW,
    SPEC_KW,
    FUN_KW,
    STRUCT_KW,
    CONST_KW,
    FRIEND_KW,
    USE_KW,
    PUBLIC_KW,
    NATIVE_KW,
    IF_KW,
    ELSE_KW,
    TRUE_KW,
    FALSE_KW,
    LOOP_KW,
    WHILE_KW,
    CONTINUE_KW,
    BREAK_KW,
    AS_KW,
    RETURN_KW,
    MOVE_KW,
    LET_KW,
    MUT_KW,
    ABORT_KW,
    INVARIANT_KW,
    ACQUIRES_KW,
    INLINE_KW,
    ENTRY_KW,
    PACKAGE_KW,
    MATCH_KW,
    FOR_KW,
    IN_KW,
    IS_KW,
    PHANTOM_KW,
    ENUM_KW,
    HAS_KW,
    ASSERT_KW,
    ASSUME_KW,
    REQUIRES_KW,
    ENSURES_KW,
    ABORTS_IF_KW,
    POST_KW,
    SUCCEEDS_IF_KW,
    ABORTS_WITH_KW,
    DECREASES_KW,
    MODIFIES_KW,
    WITH_KW,
    AXIOM_KW,
    INCLUDE_KW,
    PRAGMA_KW,
    GLOBAL_KW,
    LOCAL_KW,
    UPDATE_KW,
    COPY_KW,
    SCHEMA_KW,
    EMITS_KW,
    APPLY_KW,
    TO_KW,
    EXCEPT_KW,
    INTERNAL_KW,
    FORALL_KW,
    EXISTS_KW,
    CHOOSE_KW,
    WHERE_KW,
    MIN_KW,
    INT_NUMBER,
    BYTE_STRING,
    HEX_STRING,
    BAD_CHARACTER,
    ERROR,
    IDENT,
    WHITESPACE,
    QUOTE_IDENT,
    COMMENT,
    WILDCARD_IDENT,
    SOURCE_FILE,
    ADDRESS_DEF,
    MODULE,
    SCRIPT,
    MODULE_SPEC,
    ITEM_SPEC,
    ITEM_SPEC_REF,
    ITEM_SPEC_TYPE_PARAM_LIST,
    ITEM_SPEC_TYPE_PARAM,
    ITEM_SPEC_PARAM_LIST,
    ITEM_SPEC_PARAM,
    STRUCT,
    FRIEND,
    ENUM,
    FUN,
    SPEC_FUN,
    SPEC_INLINE_FUN,
    USE_STMT,
    USE_SPECK,
    USE_GROUP,
    USE_ALIAS,
    CONST,
    TYPE,
    RET_TYPE,
    PAREN_TYPE,
    TUPLE_TYPE,
    PATH_TYPE,
    LAMBDA_TYPE,
    LAMBDA_TYPE_PARAM,
    LAMBDA_TYPE_ABILITY_LIST,
    REF_TYPE,
    UNIT_TYPE,
    PAREN_PAT,
    UNIT_PAT,
    PAT,
    IDENT_PAT,
    WILDCARD_PAT,
    REST_PAT,
    PATH_PAT,
    STRUCT_PAT,
    STRUCT_PAT_FIELD_LIST,
    STRUCT_PAT_FIELD,
    TUPLE_STRUCT_PAT,
    TUPLE_PAT,
    TUPLE_EXPR,
    ANNOTATED_EXPR,
    PAREN_EXPR,
    PATH_EXPR,
    LAMBDA_EXPR,
    LAMBDA_PARAM_LIST,
    LAMBDA_PARAM,
    IF_EXPR,
    WHILE_EXPR,
    CONDITION,
    LOOP_EXPR,
    FOR_EXPR,
    FOR_CONDITION,
    ABORT_EXPR,
    RETURN_EXPR,
    CONTINUE_EXPR,
    BREAK_EXPR,
    LABEL_DECL,
    LABEL,
    INLINE_EXPR,
    BLOCK_EXPR,
    SPEC_BLOCK_EXPR,
    VECTOR_LIT_EXPR,
    MATCH_EXPR,
    MATCH_ARM_LIST,
    MATCH_ARM,
    MATCH_GUARD,
    STRUCT_LIT,
    STRUCT_LIT_FIELD_LIST,
    STRUCT_LIT_FIELD,
    CALL_EXPR,
    ASSERT_MACRO_EXPR,
    INDEX_EXPR,
    DOT_EXPR,
    METHOD_CALL_EXPR,
    CAST_EXPR,
    IS_EXPR,
    BORROW_EXPR,
    DEREF_EXPR,
    BANG_EXPR,
    RESOURCE_EXPR,
    RANGE_EXPR,
    UNIT_EXPR,
    BIN_EXPR,
    INVARIANT_STMT,
    EMITS_STMT,
    EMITS_CONDITION,
    PRAGMA_STMT,
    PRAGMA_ATTR_ITEM,
    AXIOM_STMT,
    UPDATE_STMT,
    ABORTS_IF_STMT,
    ABORTS_IF_WITH,
    ABORTS_WITH_STMT,
    SPEC_PREDICATE_STMT,
    SPEC_PREDICATE,
    SPEC_PREDICATE_PROPERTY_LIST,
    SPEC_PREDICATE_PROPERTY,
    GLOBAL_VARIABLE_DECL,
    SCHEMA,
    SCHEMA_FIELD,
    INCLUDE_SCHEMA,
    SCHEMA_INCLUDE_EXPR,
    AND_INCLUDE_EXPR,
    IMPLY_INCLUDE_EXPR,
    IF_ELSE_INCLUDE_EXPR,
    APPLY_SCHEMA,
    APPLY_TO,
    APPLY_EXCEPT,
    WILDCARD_PATTERN_MODIFIER,
    WILDCARD_PATTERN,
    SCHEMA_LIT,
    SCHEMA_LIT_FIELD_LIST,
    SCHEMA_LIT_FIELD,
    FORALL_EXPR,
    EXISTS_EXPR,
    CHOOSE_EXPR,
    WHERE_EXPR,
    QUANT_BINDING_LIST,
    QUANT_BINDING,
    NAMED_FIELD_LIST,
    NAMED_FIELD,
    TUPLE_FIELD_LIST,
    TUPLE_FIELD,
    VARIANT_LIST,
    VARIANT,
    ABILITY_LIST,
    ABILITY_BOUND_LIST,
    ABILITY,
    ATTR,
    ATTR_ITEM,
    PATH,
    PATH_SEGMENT,
    PATH_ADDRESS,
    LITERAL,
    VISIBILITY_MODIFIER,
    NAME,
    FIELD_REF,
    NAME_REF,
    INDEX_REF,
    VALUE_ADDRESS,
    NAMED_ADDRESS,
    ADDRESS_REF,
    ADDRESS_LIT,
    LET_STMT,
    EXPR_STMT,
    TYPE_PARAM_LIST,
    TYPE_PARAM,
    TYPE_ARG_LIST,
    TYPE_ARG,
    VALUE_ARG_LIST,
    VALUE_ARG,
    PARAM_LIST,
    PARAM,
    ACQUIRES,
    #[doc(hidden)]
    __LAST,
}
use self::SyntaxKind::*;
impl SyntaxKind {
    pub fn is_keyword(self) -> bool {
        match self {
            ADDRESS_KW | MODULE_KW | SCRIPT_KW | SPEC_KW | FUN_KW | STRUCT_KW | CONST_KW | FRIEND_KW
            | USE_KW | PUBLIC_KW | NATIVE_KW | IF_KW | ELSE_KW | TRUE_KW | FALSE_KW | LOOP_KW
            | WHILE_KW | CONTINUE_KW | BREAK_KW | AS_KW | RETURN_KW | MOVE_KW | LET_KW | MUT_KW
            | ABORT_KW | INVARIANT_KW | ACQUIRES_KW | INLINE_KW | ENTRY_KW | PACKAGE_KW | MATCH_KW
            | FOR_KW | IN_KW | IS_KW | PHANTOM_KW | ENUM_KW | HAS_KW | ASSERT_KW | ASSUME_KW
            | REQUIRES_KW | ENSURES_KW | ABORTS_IF_KW | POST_KW | SUCCEEDS_IF_KW | ABORTS_WITH_KW
            | DECREASES_KW | MODIFIES_KW | WITH_KW | AXIOM_KW | INCLUDE_KW | PRAGMA_KW | GLOBAL_KW
            | LOCAL_KW | UPDATE_KW | COPY_KW | SCHEMA_KW | EMITS_KW | APPLY_KW | TO_KW | EXCEPT_KW
            | INTERNAL_KW | FORALL_KW | EXISTS_KW | CHOOSE_KW | WHERE_KW | MIN_KW => true,
            _ => false,
        }
    }
    pub fn is_punct(self) -> bool {
        match self {
            SEMICOLON | COMMA | L_PAREN | R_PAREN | L_CURLY | R_CURLY | L_BRACK | R_BRACK | L_ANGLE
            | R_ANGLE | AT | POUND | AMP | PIPE | PLUS | STAR | SLASH | CARET | PERCENT | UNDERSCORE
            | DOT | DOT_DOT | COLON | COLON_COLON | EQ | EQ_EQ | FAT_ARROW | IMPLIES | LESS_IMPLIES
            | BANG | NOT_EQ | MINUS | LT_EQ | GT_EQ | PLUS_EQ | MINUS_EQ | PIPE_EQ | AMP_EQ
            | CARET_EQ | SLASH_EQ | STAR_EQ | PERCENT_EQ | AMP_AMP | PIPE_PIPE | SHL | SHR | SHL_EQ
            | SHR_EQ => true,
            _ => false,
        }
    }
    pub fn is_literal(self) -> bool {
        match self {
            INT_NUMBER | BYTE_STRING | HEX_STRING => true,
            _ => false,
        }
    }
    pub fn from_keyword(ident: &str) -> Option<SyntaxKind> {
        let kw = match ident {
            "address" => ADDRESS_KW,
            "module" => MODULE_KW,
            "script" => SCRIPT_KW,
            "spec" => SPEC_KW,
            "fun" => FUN_KW,
            "struct" => STRUCT_KW,
            "const" => CONST_KW,
            "friend" => FRIEND_KW,
            "use" => USE_KW,
            "public" => PUBLIC_KW,
            "native" => NATIVE_KW,
            "if" => IF_KW,
            "else" => ELSE_KW,
            "true" => TRUE_KW,
            "false" => FALSE_KW,
            "loop" => LOOP_KW,
            "while" => WHILE_KW,
            "continue" => CONTINUE_KW,
            "break" => BREAK_KW,
            "as" => AS_KW,
            "return" => RETURN_KW,
            "move" => MOVE_KW,
            "let" => LET_KW,
            "mut" => MUT_KW,
            "abort" => ABORT_KW,
            "invariant" => INVARIANT_KW,
            "acquires" => ACQUIRES_KW,
            "inline" => INLINE_KW,
            _ => return None,
        };
        Some(kw)
    }
    pub fn from_char(c: char) -> Option<SyntaxKind> {
        let tok = match c {
            ';' => SEMICOLON,
            ',' => COMMA,
            '(' => L_PAREN,
            ')' => R_PAREN,
            '{' => L_CURLY,
            '}' => R_CURLY,
            '[' => L_BRACK,
            ']' => R_BRACK,
            '<' => L_ANGLE,
            '>' => R_ANGLE,
            '@' => AT,
            '#' => POUND,
            '&' => AMP,
            '|' => PIPE,
            '+' => PLUS,
            '*' => STAR,
            '/' => SLASH,
            '^' => CARET,
            '%' => PERCENT,
            '_' => UNDERSCORE,
            '.' => DOT,
            ':' => COLON,
            '=' => EQ,
            '!' => BANG,
            '-' => MINUS,
            _ => return None,
        };
        Some(tok)
    }
}
#[macro_export]
macro_rules ! T { [;] => { $ crate :: SyntaxKind :: SEMICOLON } ; [,] => { $ crate :: SyntaxKind :: COMMA } ; ['('] => { $ crate :: SyntaxKind :: L_PAREN } ; [')'] => { $ crate :: SyntaxKind :: R_PAREN } ; ['{'] => { $ crate :: SyntaxKind :: L_CURLY } ; ['}'] => { $ crate :: SyntaxKind :: R_CURLY } ; ['['] => { $ crate :: SyntaxKind :: L_BRACK } ; [']'] => { $ crate :: SyntaxKind :: R_BRACK } ; [<] => { $ crate :: SyntaxKind :: L_ANGLE } ; [>] => { $ crate :: SyntaxKind :: R_ANGLE } ; [@] => { $ crate :: SyntaxKind :: AT } ; [#] => { $ crate :: SyntaxKind :: POUND } ; [&] => { $ crate :: SyntaxKind :: AMP } ; [|] => { $ crate :: SyntaxKind :: PIPE } ; [+] => { $ crate :: SyntaxKind :: PLUS } ; [*] => { $ crate :: SyntaxKind :: STAR } ; [/] => { $ crate :: SyntaxKind :: SLASH } ; [^] => { $ crate :: SyntaxKind :: CARET } ; [%] => { $ crate :: SyntaxKind :: PERCENT } ; ['_'] => { $ crate :: SyntaxKind :: UNDERSCORE } ; [.] => { $ crate :: SyntaxKind :: DOT } ; [..] => { $ crate :: SyntaxKind :: DOT_DOT } ; [:] => { $ crate :: SyntaxKind :: COLON } ; [::] => { $ crate :: SyntaxKind :: COLON_COLON } ; [=] => { $ crate :: SyntaxKind :: EQ } ; [==] => { $ crate :: SyntaxKind :: EQ_EQ } ; [=>] => { $ crate :: SyntaxKind :: FAT_ARROW } ; [==>] => { $ crate :: SyntaxKind :: IMPLIES } ; [<==>] => { $ crate :: SyntaxKind :: LESS_IMPLIES } ; [!] => { $ crate :: SyntaxKind :: BANG } ; [!=] => { $ crate :: SyntaxKind :: NOT_EQ } ; [-] => { $ crate :: SyntaxKind :: MINUS } ; [<=] => { $ crate :: SyntaxKind :: LT_EQ } ; [>=] => { $ crate :: SyntaxKind :: GT_EQ } ; [+=] => { $ crate :: SyntaxKind :: PLUS_EQ } ; [-=] => { $ crate :: SyntaxKind :: MINUS_EQ } ; [|=] => { $ crate :: SyntaxKind :: PIPE_EQ } ; [&=] => { $ crate :: SyntaxKind :: AMP_EQ } ; [^=] => { $ crate :: SyntaxKind :: CARET_EQ } ; [/=] => { $ crate :: SyntaxKind :: SLASH_EQ } ; [*=] => { $ crate :: SyntaxKind :: STAR_EQ } ; [%=] => { $ crate :: SyntaxKind :: PERCENT_EQ } ; [&&] => { $ crate :: SyntaxKind :: AMP_AMP } ; [||] => { $ crate :: SyntaxKind :: PIPE_PIPE } ; [<<] => { $ crate :: SyntaxKind :: SHL } ; [>>] => { $ crate :: SyntaxKind :: SHR } ; [<<=] => { $ crate :: SyntaxKind :: SHL_EQ } ; [>>=] => { $ crate :: SyntaxKind :: SHR_EQ } ; [address] => { $ crate :: SyntaxKind :: ADDRESS_KW } ; [module] => { $ crate :: SyntaxKind :: MODULE_KW } ; [script] => { $ crate :: SyntaxKind :: SCRIPT_KW } ; [spec] => { $ crate :: SyntaxKind :: SPEC_KW } ; [fun] => { $ crate :: SyntaxKind :: FUN_KW } ; [struct] => { $ crate :: SyntaxKind :: STRUCT_KW } ; [const] => { $ crate :: SyntaxKind :: CONST_KW } ; [friend] => { $ crate :: SyntaxKind :: FRIEND_KW } ; [use] => { $ crate :: SyntaxKind :: USE_KW } ; [public] => { $ crate :: SyntaxKind :: PUBLIC_KW } ; [native] => { $ crate :: SyntaxKind :: NATIVE_KW } ; [if] => { $ crate :: SyntaxKind :: IF_KW } ; [else] => { $ crate :: SyntaxKind :: ELSE_KW } ; [true] => { $ crate :: SyntaxKind :: TRUE_KW } ; [false] => { $ crate :: SyntaxKind :: FALSE_KW } ; [loop] => { $ crate :: SyntaxKind :: LOOP_KW } ; [while] => { $ crate :: SyntaxKind :: WHILE_KW } ; [continue] => { $ crate :: SyntaxKind :: CONTINUE_KW } ; [break] => { $ crate :: SyntaxKind :: BREAK_KW } ; [as] => { $ crate :: SyntaxKind :: AS_KW } ; [return] => { $ crate :: SyntaxKind :: RETURN_KW } ; [move] => { $ crate :: SyntaxKind :: MOVE_KW } ; [let] => { $ crate :: SyntaxKind :: LET_KW } ; [mut] => { $ crate :: SyntaxKind :: MUT_KW } ; [abort] => { $ crate :: SyntaxKind :: ABORT_KW } ; [invariant] => { $ crate :: SyntaxKind :: INVARIANT_KW } ; [acquires] => { $ crate :: SyntaxKind :: ACQUIRES_KW } ; [inline] => { $ crate :: SyntaxKind :: INLINE_KW } ; [entry] => { $ crate :: SyntaxKind :: ENTRY_KW } ; [package] => { $ crate :: SyntaxKind :: PACKAGE_KW } ; [match] => { $ crate :: SyntaxKind :: MATCH_KW } ; [for] => { $ crate :: SyntaxKind :: FOR_KW } ; [in] => { $ crate :: SyntaxKind :: IN_KW } ; [is] => { $ crate :: SyntaxKind :: IS_KW } ; [phantom] => { $ crate :: SyntaxKind :: PHANTOM_KW } ; [enum] => { $ crate :: SyntaxKind :: ENUM_KW } ; [has] => { $ crate :: SyntaxKind :: HAS_KW } ; [assert] => { $ crate :: SyntaxKind :: ASSERT_KW } ; [assume] => { $ crate :: SyntaxKind :: ASSUME_KW } ; [requires] => { $ crate :: SyntaxKind :: REQUIRES_KW } ; [ensures] => { $ crate :: SyntaxKind :: ENSURES_KW } ; [aborts_if] => { $ crate :: SyntaxKind :: ABORTS_IF_KW } ; [post] => { $ crate :: SyntaxKind :: POST_KW } ; [succeeds_if] => { $ crate :: SyntaxKind :: SUCCEEDS_IF_KW } ; [aborts_with] => { $ crate :: SyntaxKind :: ABORTS_WITH_KW } ; [decreases] => { $ crate :: SyntaxKind :: DECREASES_KW } ; [modifies] => { $ crate :: SyntaxKind :: MODIFIES_KW } ; [with] => { $ crate :: SyntaxKind :: WITH_KW } ; [axiom] => { $ crate :: SyntaxKind :: AXIOM_KW } ; [include] => { $ crate :: SyntaxKind :: INCLUDE_KW } ; [pragma] => { $ crate :: SyntaxKind :: PRAGMA_KW } ; [global] => { $ crate :: SyntaxKind :: GLOBAL_KW } ; [local] => { $ crate :: SyntaxKind :: LOCAL_KW } ; [update] => { $ crate :: SyntaxKind :: UPDATE_KW } ; [copy] => { $ crate :: SyntaxKind :: COPY_KW } ; [schema] => { $ crate :: SyntaxKind :: SCHEMA_KW } ; [emits] => { $ crate :: SyntaxKind :: EMITS_KW } ; [apply] => { $ crate :: SyntaxKind :: APPLY_KW } ; [to] => { $ crate :: SyntaxKind :: TO_KW } ; [except] => { $ crate :: SyntaxKind :: EXCEPT_KW } ; [internal] => { $ crate :: SyntaxKind :: INTERNAL_KW } ; [forall] => { $ crate :: SyntaxKind :: FORALL_KW } ; [exists] => { $ crate :: SyntaxKind :: EXISTS_KW } ; [choose] => { $ crate :: SyntaxKind :: CHOOSE_KW } ; [where] => { $ crate :: SyntaxKind :: WHERE_KW } ; [min] => { $ crate :: SyntaxKind :: MIN_KW } ; [quote_ident] => { $ crate :: SyntaxKind :: QUOTE_IDENT } ; [wildcard_ident] => { $ crate :: SyntaxKind :: WILDCARD_IDENT } ; [ident] => { $ crate :: SyntaxKind :: IDENT } ; [int_number] => { $ crate :: SyntaxKind :: INT_NUMBER } ; [hex_string] => { $ crate :: SyntaxKind :: HEX_STRING } ; [byte_string] => { $ crate :: SyntaxKind :: BYTE_STRING } ; }
#[allow(unused_imports)]
pub use T;
