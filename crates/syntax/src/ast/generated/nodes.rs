//! Generated by `cargo codegen`, do not edit by hand.

#![allow(non_snake_case)]
use crate::{
    ast::{self, support, AstChildren, AstNode},
    SyntaxKind::{self, *},
    SyntaxNode, SyntaxToken, T,
};

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AddressDef {
    pub(crate) syntax: SyntaxNode,
}
impl AddressDef {
    #[inline]
    pub fn address_ref(&self) -> Option<AddressRef> { support::child(&self.syntax) }
    #[inline]
    pub fn modules(&self) -> AstChildren<Module> { support::children(&self.syntax) }
    #[inline]
    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }
    #[inline]
    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }
    #[inline]
    pub fn address_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![address]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ArgList {
    pub(crate) syntax: SyntaxNode,
}
impl ArgList {
    #[inline]
    pub fn arg_exprs(&self) -> AstChildren<Expr> { support::children(&self.syntax) }
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Attr {
    pub(crate) syntax: SyntaxNode,
}
impl Attr {
    #[inline]
    pub fn attr_item(&self) -> Option<AttrItem> { support::child(&self.syntax) }
    #[inline]
    pub fn excl_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![!]) }
    #[inline]
    pub fn pound_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![#]) }
    #[inline]
    pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['[']) }
    #[inline]
    pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AttrItem {
    pub(crate) syntax: SyntaxNode,
}
impl AttrItem {
    #[inline]
    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }
    #[inline]
    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BinExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for BinExpr {}
impl BinExpr {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BlockExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasStmts for BlockExpr {}
impl ast::HasUseStmts for BlockExpr {}
impl BlockExpr {
    #[inline]
    pub fn tail_expr(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }
    #[inline]
    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CallExpr {
    pub(crate) syntax: SyntaxNode,
}
impl CallExpr {
    #[inline]
    pub fn arg_list(&self) -> Option<ArgList> { support::child(&self.syntax) }
    #[inline]
    pub fn path(&self) -> Path { support::child(&self.syntax).expect("required by the parser") }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Const {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for Const {}
impl ast::HasName for Const {}
impl ast::HasVisibility for Const {}
impl Const {
    #[inline]
    pub fn body(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn type_(&self) -> Option<Type> { support::child(&self.syntax) }
    #[inline]
    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }
    #[inline]
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }
    #[inline]
    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }
    #[inline]
    pub fn const_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![const]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Enum {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for Enum {}
impl ast::HasName for Enum {}
impl ast::HasTypeParams for Enum {}
impl ast::HasVisibility for Enum {}
impl Enum {
    #[inline]
    pub fn variant_list(&self) -> Option<VariantList> { support::child(&self.syntax) }
    #[inline]
    pub fn enum_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![enum]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ExprStmt {
    pub(crate) syntax: SyntaxNode,
}
impl ExprStmt {
    #[inline]
    pub fn expr(&self) -> Expr { support::child(&self.syntax).expect("required by the parser") }
    #[inline]
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ForCondition {
    pub(crate) syntax: SyntaxNode,
}
impl ForCondition {
    #[inline]
    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn ident_pat(&self) -> Option<IdentPat> { support::child(&self.syntax) }
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }
    #[inline]
    pub fn in_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![in]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ForExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ForExpr {
    #[inline]
    pub fn block_expr(&self) -> Option<BlockExpr> { support::child(&self.syntax) }
    #[inline]
    pub fn for_condition(&self) -> Option<ForCondition> { support::child(&self.syntax) }
    #[inline]
    pub fn inline_expr(&self) -> Option<InlineExpr> { support::child(&self.syntax) }
    #[inline]
    pub fn for_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![for]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Friend {
    pub(crate) syntax: SyntaxNode,
}
impl Friend {
    #[inline]
    pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }
    #[inline]
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }
    #[inline]
    pub fn friend_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![friend]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Fun {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for Fun {}
impl ast::HasName for Fun {}
impl ast::HasTypeParams for Fun {}
impl ast::HasVisibility for Fun {}
impl Fun {
    #[inline]
    pub fn body(&self) -> Option<BlockExpr> { support::child(&self.syntax) }
    #[inline]
    pub fn param_list(&self) -> Option<ParamList> { support::child(&self.syntax) }
    #[inline]
    pub fn ret_type(&self) -> Option<RetType> { support::child(&self.syntax) }
    #[inline]
    pub fn visibility_modifier(&self) -> Option<VisibilityModifier> { support::child(&self.syntax) }
    #[inline]
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }
    #[inline]
    pub fn entry_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![entry]) }
    #[inline]
    pub fn fun_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![fun]) }
    #[inline]
    pub fn inline_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![inline]) }
    #[inline]
    pub fn native_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![native]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IdentPat {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for IdentPat {}
impl IdentPat {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InlineExpr {
    pub(crate) syntax: SyntaxNode,
}
impl InlineExpr {
    #[inline]
    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ItemSpec {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for ItemSpec {}
impl ast::MslOnly for ItemSpec {}
impl ItemSpec {
    #[inline]
    pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }
    #[inline]
    pub fn spec_block(&self) -> Option<BlockExpr> { support::child(&self.syntax) }
    #[inline]
    pub fn module_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![module]) }
    #[inline]
    pub fn spec_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![spec]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LetStmt {
    pub(crate) syntax: SyntaxNode,
}
impl LetStmt {
    #[inline]
    pub fn initializer(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }
    #[inline]
    pub fn type_(&self) -> Option<Type> { support::child(&self.syntax) }
    #[inline]
    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }
    #[inline]
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }
    #[inline]
    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }
    #[inline]
    pub fn let_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![let]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Literal {
    pub(crate) syntax: SyntaxNode,
}
impl Literal {
    #[inline]
    pub fn false_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![false]) }
    #[inline]
    pub fn int_number_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![int_number])
    }
    #[inline]
    pub fn true_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![true]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Module {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for Module {}
impl ast::HasItems for Module {}
impl ast::HasName for Module {}
impl ast::HasUseStmts for Module {}
impl Module {
    #[inline]
    pub fn address_ref(&self) -> Option<AddressRef> { support::child(&self.syntax) }
    #[inline]
    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }
    #[inline]
    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }
    #[inline]
    pub fn coloncolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![::]) }
    #[inline]
    pub fn module_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![module]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ModuleSpec {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for ModuleSpec {}
impl ast::HasItems for ModuleSpec {}
impl ast::HasUseStmts for ModuleSpec {}
impl ast::MslOnly for ModuleSpec {}
impl ModuleSpec {
    #[inline]
    pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }
    #[inline]
    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }
    #[inline]
    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }
    #[inline]
    pub fn spec_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![spec]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Name {
    pub(crate) syntax: SyntaxNode,
}
impl Name {
    #[inline]
    pub fn ident_token(&self) -> SyntaxToken {
        support::token(&self.syntax, T![ident]).expect("required by the parser")
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NameRef {
    pub(crate) syntax: SyntaxNode,
}
impl NameRef {
    #[inline]
    pub fn ident_token(&self) -> SyntaxToken {
        support::token(&self.syntax, T![ident]).expect("required by the parser")
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NamedAddress {
    pub(crate) syntax: SyntaxNode,
}
impl NamedAddress {
    #[inline]
    pub fn ident_token(&self) -> SyntaxToken {
        support::token(&self.syntax, T![ident]).expect("required by the parser")
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NamedField {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for NamedField {}
impl ast::HasName for NamedField {}
impl NamedField {
    #[inline]
    pub fn type_(&self) -> Option<Type> { support::child(&self.syntax) }
    #[inline]
    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NamedFieldList {
    pub(crate) syntax: SyntaxNode,
}
impl NamedFieldList {
    #[inline]
    pub fn fields(&self) -> AstChildren<NamedField> { support::children(&self.syntax) }
    #[inline]
    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }
    #[inline]
    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Param {
    pub(crate) syntax: SyntaxNode,
}
impl Param {
    #[inline]
    pub fn ident_pat(&self) -> IdentPat { support::child(&self.syntax).expect("required by the parser") }
    #[inline]
    pub fn type_(&self) -> Option<Type> { support::child(&self.syntax) }
    #[inline]
    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParamList {
    pub(crate) syntax: SyntaxNode,
}
impl ParamList {
    #[inline]
    pub fn params(&self) -> AstChildren<Param> { support::children(&self.syntax) }
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParenExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ParenExpr {
    #[inline]
    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParenType {
    pub(crate) syntax: SyntaxNode,
}
impl ParenType {
    #[inline]
    pub fn type_(&self) -> Type { support::child(&self.syntax).expect("required by the parser") }
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Path {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasReference for Path {}
impl Path {
    #[inline]
    pub fn qualifier(&self) -> Option<Path> { support::child(&self.syntax) }
    #[inline]
    pub fn segment(&self) -> PathSegment {
        support::child(&self.syntax).expect("required by the parser")
    }
    #[inline]
    pub fn coloncolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![::]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PathAddress {
    pub(crate) syntax: SyntaxNode,
}
impl PathAddress {
    #[inline]
    pub fn value_address(&self) -> ValueAddress {
        support::child(&self.syntax).expect("required by the parser")
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PathExpr {
    pub(crate) syntax: SyntaxNode,
}
impl PathExpr {
    #[inline]
    pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PathSegment {
    pub(crate) syntax: SyntaxNode,
}
impl PathSegment {
    #[inline]
    pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }
    #[inline]
    pub fn path_address(&self) -> Option<PathAddress> { support::child(&self.syntax) }
    #[inline]
    pub fn type_arg_list(&self) -> Option<TypeArgList> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PathType {
    pub(crate) syntax: SyntaxNode,
}
impl PathType {
    #[inline]
    pub fn path(&self) -> Path { support::child(&self.syntax).expect("required by the parser") }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixExpr {
    pub(crate) syntax: SyntaxNode,
}
impl PrefixExpr {
    #[inline]
    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RefType {
    pub(crate) syntax: SyntaxNode,
}
impl RefType {
    #[inline]
    pub fn type_(&self) -> Option<Type> { support::child(&self.syntax) }
    #[inline]
    pub fn amp_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![&]) }
    #[inline]
    pub fn mut_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![mut]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RestPat {
    pub(crate) syntax: SyntaxNode,
}
impl RestPat {
    #[inline]
    pub fn dotdot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![..]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RetType {
    pub(crate) syntax: SyntaxNode,
}
impl RetType {
    #[inline]
    pub fn type_(&self) -> Option<Type> { support::child(&self.syntax) }
    #[inline]
    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Schema {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for Schema {}
impl ast::HasName for Schema {}
impl ast::HasTypeParams for Schema {}
impl ast::MslOnly for Schema {}
impl Schema {
    #[inline]
    pub fn spec_block(&self) -> Option<BlockExpr> { support::child(&self.syntax) }
    #[inline]
    pub fn schema_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![schema]) }
    #[inline]
    pub fn spec_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![spec]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SchemaField {
    pub(crate) syntax: SyntaxNode,
}
impl ast::MslOnly for SchemaField {}
impl SchemaField {
    #[inline]
    pub fn ident_pat(&self) -> Option<IdentPat> { support::child(&self.syntax) }
    #[inline]
    pub fn type_(&self) -> Option<Type> { support::child(&self.syntax) }
    #[inline]
    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }
    #[inline]
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }
    #[inline]
    pub fn local_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![local]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Script {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for Script {}
impl ast::HasItems for Script {}
impl ast::HasUseStmts for Script {}
impl Script {
    #[inline]
    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }
    #[inline]
    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }
    #[inline]
    pub fn script_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![script]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SourceFile {
    pub(crate) syntax: SyntaxNode,
}
impl SourceFile {
    #[inline]
    pub fn address_defs(&self) -> AstChildren<AddressDef> { support::children(&self.syntax) }
    #[inline]
    pub fn module_specs(&self) -> AstChildren<ModuleSpec> { support::children(&self.syntax) }
    #[inline]
    pub fn modules(&self) -> AstChildren<Module> { support::children(&self.syntax) }
    #[inline]
    pub fn scripts(&self) -> AstChildren<Script> { support::children(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SpecFun {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for SpecFun {}
impl ast::HasName for SpecFun {}
impl ast::HasTypeParams for SpecFun {}
impl ast::HasVisibility for SpecFun {}
impl ast::MslOnly for SpecFun {}
impl SpecFun {
    #[inline]
    pub fn param_list(&self) -> Option<ParamList> { support::child(&self.syntax) }
    #[inline]
    pub fn ret_type(&self) -> Option<RetType> { support::child(&self.syntax) }
    #[inline]
    pub fn spec_block(&self) -> Option<BlockExpr> { support::child(&self.syntax) }
    #[inline]
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }
    #[inline]
    pub fn fun_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![fun]) }
    #[inline]
    pub fn native_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![native]) }
    #[inline]
    pub fn spec_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![spec]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SpecInlineFun {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for SpecInlineFun {}
impl ast::HasTypeParams for SpecInlineFun {}
impl ast::HasVisibility for SpecInlineFun {}
impl ast::MslOnly for SpecInlineFun {}
impl SpecInlineFun {
    #[inline]
    pub fn param_list(&self) -> Option<ParamList> { support::child(&self.syntax) }
    #[inline]
    pub fn ret_type(&self) -> Option<RetType> { support::child(&self.syntax) }
    #[inline]
    pub fn spec_block(&self) -> Option<BlockExpr> { support::child(&self.syntax) }
    #[inline]
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }
    #[inline]
    pub fn fun_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![fun]) }
    #[inline]
    pub fn native_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![native]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Struct {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for Struct {}
impl ast::HasFields for Struct {}
impl ast::HasName for Struct {}
impl ast::HasTypeParams for Struct {}
impl ast::HasVisibility for Struct {}
impl Struct {
    #[inline]
    pub fn struct_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![struct]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StructLit {
    pub(crate) syntax: SyntaxNode,
}
impl StructLit {
    #[inline]
    pub fn path(&self) -> Path { support::child(&self.syntax).expect("required by the parser") }
    #[inline]
    pub fn struct_lit_field_list(&self) -> Option<StructLitFieldList> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StructLitField {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasReference for StructLitField {}
impl StructLitField {
    #[inline]
    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }
    #[inline]
    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StructLitFieldList {
    pub(crate) syntax: SyntaxNode,
}
impl StructLitFieldList {
    #[inline]
    pub fn fields(&self) -> AstChildren<StructLitField> { support::children(&self.syntax) }
    #[inline]
    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }
    #[inline]
    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StructPat {
    pub(crate) syntax: SyntaxNode,
}
impl StructPat {
    #[inline]
    pub fn path(&self) -> Path { support::child(&self.syntax).expect("required by the parser") }
    #[inline]
    pub fn struct_pat_field_list(&self) -> Option<StructPatFieldList> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StructPatField {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasReference for StructPatField {}
impl StructPatField {
    #[inline]
    pub fn ident_pat(&self) -> Option<IdentPat> { support::child(&self.syntax) }
    #[inline]
    pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }
    #[inline]
    pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }
    #[inline]
    pub fn rest_pat(&self) -> Option<RestPat> { support::child(&self.syntax) }
    #[inline]
    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StructPatFieldList {
    pub(crate) syntax: SyntaxNode,
}
impl StructPatFieldList {
    #[inline]
    pub fn fields(&self) -> AstChildren<StructPatField> { support::children(&self.syntax) }
    #[inline]
    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }
    #[inline]
    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TupleField {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for TupleField {}
impl TupleField {
    #[inline]
    pub fn type_(&self) -> Option<Type> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TupleFieldList {
    pub(crate) syntax: SyntaxNode,
}
impl TupleFieldList {
    #[inline]
    pub fn fields(&self) -> AstChildren<TupleField> { support::children(&self.syntax) }
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TuplePat {
    pub(crate) syntax: SyntaxNode,
}
impl TuplePat {
    #[inline]
    pub fn pats(&self) -> AstChildren<Pat> { support::children(&self.syntax) }
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TupleStructPat {
    pub(crate) syntax: SyntaxNode,
}
impl TupleStructPat {
    #[inline]
    pub fn fields(&self) -> AstChildren<Pat> { support::children(&self.syntax) }
    #[inline]
    pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TupleType {
    pub(crate) syntax: SyntaxNode,
}
impl TupleType {
    #[inline]
    pub fn types(&self) -> AstChildren<Type> { support::children(&self.syntax) }
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeArg {
    pub(crate) syntax: SyntaxNode,
}
impl TypeArg {
    #[inline]
    pub fn type_(&self) -> Type { support::child(&self.syntax).expect("required by the parser") }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeArgList {
    pub(crate) syntax: SyntaxNode,
}
impl TypeArgList {
    #[inline]
    pub fn type_arguments(&self) -> AstChildren<TypeArg> { support::children(&self.syntax) }
    #[inline]
    pub fn l_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![<]) }
    #[inline]
    pub fn r_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![>]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeParam {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for TypeParam {}
impl TypeParam {
    #[inline]
    pub fn phantom_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![phantom]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeParamList {
    pub(crate) syntax: SyntaxNode,
}
impl TypeParamList {
    #[inline]
    pub fn type_parameters(&self) -> AstChildren<TypeParam> { support::children(&self.syntax) }
    #[inline]
    pub fn l_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![<]) }
    #[inline]
    pub fn r_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![>]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UnitType {
    pub(crate) syntax: SyntaxNode,
}
impl UnitType {
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UseAlias {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for UseAlias {}
impl UseAlias {
    #[inline]
    pub fn as_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![as]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UseGroup {
    pub(crate) syntax: SyntaxNode,
}
impl UseGroup {
    #[inline]
    pub fn use_specks(&self) -> AstChildren<UseSpeck> { support::children(&self.syntax) }
    #[inline]
    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }
    #[inline]
    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UseSpeck {
    pub(crate) syntax: SyntaxNode,
}
impl UseSpeck {
    #[inline]
    pub fn path(&self) -> Path { support::child(&self.syntax).expect("required by the parser") }
    #[inline]
    pub fn use_alias(&self) -> Option<UseAlias> { support::child(&self.syntax) }
    #[inline]
    pub fn use_group(&self) -> Option<UseGroup> { support::child(&self.syntax) }
    #[inline]
    pub fn coloncolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![::]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UseStmt {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for UseStmt {}
impl UseStmt {
    #[inline]
    pub fn use_speck(&self) -> Option<UseSpeck> { support::child(&self.syntax) }
    #[inline]
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }
    #[inline]
    pub fn use_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![use]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ValueAddress {
    pub(crate) syntax: SyntaxNode,
}
impl ValueAddress {
    #[inline]
    pub fn int_number_token(&self) -> SyntaxToken {
        support::token(&self.syntax, T![int_number]).expect("required by the parser")
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Variant {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for Variant {}
impl ast::HasFields for Variant {}
impl ast::HasName for Variant {}
impl Variant {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct VariantList {
    pub(crate) syntax: SyntaxNode,
}
impl VariantList {
    #[inline]
    pub fn variants(&self) -> AstChildren<Variant> { support::children(&self.syntax) }
    #[inline]
    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }
    #[inline]
    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct VisibilityModifier {
    pub(crate) syntax: SyntaxNode,
}
impl VisibilityModifier {
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }
    #[inline]
    pub fn friend_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![friend]) }
    #[inline]
    pub fn package_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![package]) }
    #[inline]
    pub fn public_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![public]) }
    #[inline]
    pub fn script_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![script]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct WildcardPat {
    pub(crate) syntax: SyntaxNode,
}
impl WildcardPat {
    #[inline]
    pub fn underscore_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['_']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum AddressRef {
    NamedAddress(NamedAddress),
    ValueAddress(ValueAddress),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum AnyField {
    NamedField(NamedField),
    TupleField(TupleField),
}
impl ast::HasAttrs for AnyField {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum BindingTypeOwner {
    LetStmt(LetStmt),
    Param(Param),
    SchemaField(SchemaField),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Expr {
    BinExpr(BinExpr),
    CallExpr(CallExpr),
    Literal(Literal),
    ParenExpr(ParenExpr),
    PathExpr(PathExpr),
    PrefixExpr(PrefixExpr),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum FieldList {
    NamedFieldList(NamedFieldList),
    TupleFieldList(TupleFieldList),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum InferenceCtxOwner {
    Fun(Fun),
    SpecFun(SpecFun),
}
impl ast::HasAttrs for InferenceCtxOwner {}
impl ast::HasName for InferenceCtxOwner {}
impl ast::HasTypeParams for InferenceCtxOwner {}
impl ast::HasVisibility for InferenceCtxOwner {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Item {
    Const(Const),
    Enum(Enum),
    Friend(Friend),
    Fun(Fun),
    ItemSpec(ItemSpec),
    Schema(Schema),
    SpecFun(SpecFun),
    Struct(Struct),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Pat {
    IdentPat(IdentPat),
    RestPat(RestPat),
    StructPat(StructPat),
    TuplePat(TuplePat),
    TupleStructPat(TupleStructPat),
    WildcardPat(WildcardPat),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Stmt {
    ExprStmt(ExprStmt),
    LetStmt(LetStmt),
    SchemaField(SchemaField),
    SpecInlineFun(SpecInlineFun),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum StructOrEnum {
    Enum(Enum),
    Struct(Struct),
}
impl ast::HasAttrs for StructOrEnum {}
impl ast::HasName for StructOrEnum {}
impl ast::HasTypeParams for StructOrEnum {}
impl ast::HasVisibility for StructOrEnum {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Type {
    ParenType(ParenType),
    PathType(PathType),
    RefType(RefType),
    TupleType(TupleType),
    UnitType(UnitType),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AnyHasAttrs {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for AnyHasAttrs {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AnyHasFields {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasFields for AnyHasFields {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AnyHasItems {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasItems for AnyHasItems {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AnyHasName {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for AnyHasName {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AnyHasReference {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasReference for AnyHasReference {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AnyHasStmts {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasStmts for AnyHasStmts {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AnyHasTypeParams {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasTypeParams for AnyHasTypeParams {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AnyHasUseStmts {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasUseStmts for AnyHasUseStmts {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AnyHasVisibility {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasVisibility for AnyHasVisibility {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AnyMslOnly {
    pub(crate) syntax: SyntaxNode,
}
impl ast::MslOnly for AnyMslOnly {}
impl AstNode for AddressDef {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        ADDRESS_DEF
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == ADDRESS_DEF }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for ArgList {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        ARG_LIST
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == ARG_LIST }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Attr {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        ATTR
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == ATTR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for AttrItem {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        ATTR_ITEM
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == ATTR_ITEM }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for BinExpr {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        BIN_EXPR
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == BIN_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for BlockExpr {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        BLOCK_EXPR
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == BLOCK_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for CallExpr {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        CALL_EXPR
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == CALL_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Const {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        CONST
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == CONST }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Enum {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        ENUM
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == ENUM }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for ExprStmt {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        EXPR_STMT
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == EXPR_STMT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for ForCondition {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        FOR_CONDITION
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == FOR_CONDITION }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for ForExpr {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        FOR_EXPR
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == FOR_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Friend {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        FRIEND
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == FRIEND }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Fun {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        FUN
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == FUN }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for IdentPat {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        IDENT_PAT
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == IDENT_PAT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for InlineExpr {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        INLINE_EXPR
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == INLINE_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for ItemSpec {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        ITEM_SPEC
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == ITEM_SPEC }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for LetStmt {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        LET_STMT
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == LET_STMT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Literal {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        LITERAL
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == LITERAL }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Module {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        MODULE
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == MODULE }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for ModuleSpec {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        MODULE_SPEC
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == MODULE_SPEC }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Name {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        NAME
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == NAME }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for NameRef {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        NAME_REF
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == NAME_REF }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for NamedAddress {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        NAMED_ADDRESS
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == NAMED_ADDRESS }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for NamedField {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        NAMED_FIELD
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == NAMED_FIELD }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for NamedFieldList {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        NAMED_FIELD_LIST
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == NAMED_FIELD_LIST }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Param {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        PARAM
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == PARAM }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for ParamList {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        PARAM_LIST
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == PARAM_LIST }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for ParenExpr {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        PAREN_EXPR
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == PAREN_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for ParenType {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        PAREN_TYPE
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == PAREN_TYPE }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Path {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        PATH
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == PATH }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for PathAddress {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        PATH_ADDRESS
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == PATH_ADDRESS }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for PathExpr {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        PATH_EXPR
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == PATH_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for PathSegment {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        PATH_SEGMENT
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == PATH_SEGMENT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for PathType {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        PATH_TYPE
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == PATH_TYPE }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for PrefixExpr {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        PREFIX_EXPR
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == PREFIX_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for RefType {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        REF_TYPE
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == REF_TYPE }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for RestPat {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        REST_PAT
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == REST_PAT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for RetType {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        RET_TYPE
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == RET_TYPE }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Schema {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        SCHEMA
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == SCHEMA }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for SchemaField {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        SCHEMA_FIELD
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == SCHEMA_FIELD }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Script {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        SCRIPT
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == SCRIPT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for SourceFile {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        SOURCE_FILE
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == SOURCE_FILE }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for SpecFun {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        SPEC_FUN
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == SPEC_FUN }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for SpecInlineFun {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        SPEC_INLINE_FUN
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == SPEC_INLINE_FUN }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Struct {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        STRUCT
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == STRUCT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for StructLit {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        STRUCT_LIT
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == STRUCT_LIT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for StructLitField {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        STRUCT_LIT_FIELD
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == STRUCT_LIT_FIELD }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for StructLitFieldList {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        STRUCT_LIT_FIELD_LIST
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == STRUCT_LIT_FIELD_LIST }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for StructPat {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        STRUCT_PAT
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == STRUCT_PAT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for StructPatField {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        STRUCT_PAT_FIELD
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == STRUCT_PAT_FIELD }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for StructPatFieldList {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        STRUCT_PAT_FIELD_LIST
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == STRUCT_PAT_FIELD_LIST }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for TupleField {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        TUPLE_FIELD
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == TUPLE_FIELD }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for TupleFieldList {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        TUPLE_FIELD_LIST
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == TUPLE_FIELD_LIST }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for TuplePat {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        TUPLE_PAT
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == TUPLE_PAT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for TupleStructPat {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        TUPLE_STRUCT_PAT
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == TUPLE_STRUCT_PAT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for TupleType {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        TUPLE_TYPE
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == TUPLE_TYPE }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for TypeArg {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        TYPE_ARG
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == TYPE_ARG }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for TypeArgList {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        TYPE_ARG_LIST
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == TYPE_ARG_LIST }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for TypeParam {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        TYPE_PARAM
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == TYPE_PARAM }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for TypeParamList {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        TYPE_PARAM_LIST
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == TYPE_PARAM_LIST }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for UnitType {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        UNIT_TYPE
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == UNIT_TYPE }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for UseAlias {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        USE_ALIAS
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == USE_ALIAS }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for UseGroup {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        USE_GROUP
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == USE_GROUP }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for UseSpeck {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        USE_SPECK
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == USE_SPECK }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for UseStmt {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        USE_STMT
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == USE_STMT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for ValueAddress {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        VALUE_ADDRESS
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == VALUE_ADDRESS }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Variant {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        VARIANT
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == VARIANT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for VariantList {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        VARIANT_LIST
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == VARIANT_LIST }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for VisibilityModifier {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        VISIBILITY_MODIFIER
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == VISIBILITY_MODIFIER }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for WildcardPat {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        WILDCARD_PAT
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == WILDCARD_PAT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl From<NamedAddress> for AddressRef {
    #[inline]
    fn from(node: NamedAddress) -> AddressRef { AddressRef::NamedAddress(node) }
}
impl From<ValueAddress> for AddressRef {
    #[inline]
    fn from(node: ValueAddress) -> AddressRef { AddressRef::ValueAddress(node) }
}
impl AddressRef {
    pub fn named_address(self) -> Option<NamedAddress> {
        match (self) {
            AddressRef::NamedAddress(item) => Some(item),
            _ => None,
        }
    }
    pub fn value_address(self) -> Option<ValueAddress> {
        match (self) {
            AddressRef::ValueAddress(item) => Some(item),
            _ => None,
        }
    }
}
impl AstNode for AddressRef {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, NAMED_ADDRESS | VALUE_ADDRESS) }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            NAMED_ADDRESS => AddressRef::NamedAddress(NamedAddress { syntax }),
            VALUE_ADDRESS => AddressRef::ValueAddress(ValueAddress { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AddressRef::NamedAddress(it) => &it.syntax,
            AddressRef::ValueAddress(it) => &it.syntax,
        }
    }
}
impl From<NamedField> for AnyField {
    #[inline]
    fn from(node: NamedField) -> AnyField { AnyField::NamedField(node) }
}
impl From<TupleField> for AnyField {
    #[inline]
    fn from(node: TupleField) -> AnyField { AnyField::TupleField(node) }
}
impl AnyField {
    pub fn named_field(self) -> Option<NamedField> {
        match (self) {
            AnyField::NamedField(item) => Some(item),
            _ => None,
        }
    }
    pub fn tuple_field(self) -> Option<TupleField> {
        match (self) {
            AnyField::TupleField(item) => Some(item),
            _ => None,
        }
    }
}
impl AstNode for AnyField {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, NAMED_FIELD | TUPLE_FIELD) }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            NAMED_FIELD => AnyField::NamedField(NamedField { syntax }),
            TUPLE_FIELD => AnyField::TupleField(TupleField { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyField::NamedField(it) => &it.syntax,
            AnyField::TupleField(it) => &it.syntax,
        }
    }
}
impl From<LetStmt> for BindingTypeOwner {
    #[inline]
    fn from(node: LetStmt) -> BindingTypeOwner { BindingTypeOwner::LetStmt(node) }
}
impl From<Param> for BindingTypeOwner {
    #[inline]
    fn from(node: Param) -> BindingTypeOwner { BindingTypeOwner::Param(node) }
}
impl From<SchemaField> for BindingTypeOwner {
    #[inline]
    fn from(node: SchemaField) -> BindingTypeOwner { BindingTypeOwner::SchemaField(node) }
}
impl BindingTypeOwner {
    pub fn let_stmt(self) -> Option<LetStmt> {
        match (self) {
            BindingTypeOwner::LetStmt(item) => Some(item),
            _ => None,
        }
    }
    pub fn param(self) -> Option<Param> {
        match (self) {
            BindingTypeOwner::Param(item) => Some(item),
            _ => None,
        }
    }
    pub fn schema_field(self) -> Option<SchemaField> {
        match (self) {
            BindingTypeOwner::SchemaField(item) => Some(item),
            _ => None,
        }
    }
}
impl AstNode for BindingTypeOwner {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, LET_STMT | PARAM | SCHEMA_FIELD) }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            LET_STMT => BindingTypeOwner::LetStmt(LetStmt { syntax }),
            PARAM => BindingTypeOwner::Param(Param { syntax }),
            SCHEMA_FIELD => BindingTypeOwner::SchemaField(SchemaField { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            BindingTypeOwner::LetStmt(it) => &it.syntax,
            BindingTypeOwner::Param(it) => &it.syntax,
            BindingTypeOwner::SchemaField(it) => &it.syntax,
        }
    }
}
impl From<BinExpr> for Expr {
    #[inline]
    fn from(node: BinExpr) -> Expr { Expr::BinExpr(node) }
}
impl From<CallExpr> for Expr {
    #[inline]
    fn from(node: CallExpr) -> Expr { Expr::CallExpr(node) }
}
impl From<Literal> for Expr {
    #[inline]
    fn from(node: Literal) -> Expr { Expr::Literal(node) }
}
impl From<ParenExpr> for Expr {
    #[inline]
    fn from(node: ParenExpr) -> Expr { Expr::ParenExpr(node) }
}
impl From<PathExpr> for Expr {
    #[inline]
    fn from(node: PathExpr) -> Expr { Expr::PathExpr(node) }
}
impl From<PrefixExpr> for Expr {
    #[inline]
    fn from(node: PrefixExpr) -> Expr { Expr::PrefixExpr(node) }
}
impl Expr {
    pub fn bin_expr(self) -> Option<BinExpr> {
        match (self) {
            Expr::BinExpr(item) => Some(item),
            _ => None,
        }
    }
    pub fn call_expr(self) -> Option<CallExpr> {
        match (self) {
            Expr::CallExpr(item) => Some(item),
            _ => None,
        }
    }
    pub fn literal(self) -> Option<Literal> {
        match (self) {
            Expr::Literal(item) => Some(item),
            _ => None,
        }
    }
    pub fn paren_expr(self) -> Option<ParenExpr> {
        match (self) {
            Expr::ParenExpr(item) => Some(item),
            _ => None,
        }
    }
    pub fn path_expr(self) -> Option<PathExpr> {
        match (self) {
            Expr::PathExpr(item) => Some(item),
            _ => None,
        }
    }
    pub fn prefix_expr(self) -> Option<PrefixExpr> {
        match (self) {
            Expr::PrefixExpr(item) => Some(item),
            _ => None,
        }
    }
}
impl AstNode for Expr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            BIN_EXPR | CALL_EXPR | LITERAL | PAREN_EXPR | PATH_EXPR | PREFIX_EXPR
        )
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            BIN_EXPR => Expr::BinExpr(BinExpr { syntax }),
            CALL_EXPR => Expr::CallExpr(CallExpr { syntax }),
            LITERAL => Expr::Literal(Literal { syntax }),
            PAREN_EXPR => Expr::ParenExpr(ParenExpr { syntax }),
            PATH_EXPR => Expr::PathExpr(PathExpr { syntax }),
            PREFIX_EXPR => Expr::PrefixExpr(PrefixExpr { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Expr::BinExpr(it) => &it.syntax,
            Expr::CallExpr(it) => &it.syntax,
            Expr::Literal(it) => &it.syntax,
            Expr::ParenExpr(it) => &it.syntax,
            Expr::PathExpr(it) => &it.syntax,
            Expr::PrefixExpr(it) => &it.syntax,
        }
    }
}
impl From<NamedFieldList> for FieldList {
    #[inline]
    fn from(node: NamedFieldList) -> FieldList { FieldList::NamedFieldList(node) }
}
impl From<TupleFieldList> for FieldList {
    #[inline]
    fn from(node: TupleFieldList) -> FieldList { FieldList::TupleFieldList(node) }
}
impl FieldList {
    pub fn named_field_list(self) -> Option<NamedFieldList> {
        match (self) {
            FieldList::NamedFieldList(item) => Some(item),
            _ => None,
        }
    }
    pub fn tuple_field_list(self) -> Option<TupleFieldList> {
        match (self) {
            FieldList::TupleFieldList(item) => Some(item),
            _ => None,
        }
    }
}
impl AstNode for FieldList {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, NAMED_FIELD_LIST | TUPLE_FIELD_LIST) }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            NAMED_FIELD_LIST => FieldList::NamedFieldList(NamedFieldList { syntax }),
            TUPLE_FIELD_LIST => FieldList::TupleFieldList(TupleFieldList { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            FieldList::NamedFieldList(it) => &it.syntax,
            FieldList::TupleFieldList(it) => &it.syntax,
        }
    }
}
impl From<Fun> for InferenceCtxOwner {
    #[inline]
    fn from(node: Fun) -> InferenceCtxOwner { InferenceCtxOwner::Fun(node) }
}
impl From<SpecFun> for InferenceCtxOwner {
    #[inline]
    fn from(node: SpecFun) -> InferenceCtxOwner { InferenceCtxOwner::SpecFun(node) }
}
impl InferenceCtxOwner {
    pub fn fun(self) -> Option<Fun> {
        match (self) {
            InferenceCtxOwner::Fun(item) => Some(item),
            _ => None,
        }
    }
    pub fn spec_fun(self) -> Option<SpecFun> {
        match (self) {
            InferenceCtxOwner::SpecFun(item) => Some(item),
            _ => None,
        }
    }
}
impl AstNode for InferenceCtxOwner {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, FUN | SPEC_FUN) }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            FUN => InferenceCtxOwner::Fun(Fun { syntax }),
            SPEC_FUN => InferenceCtxOwner::SpecFun(SpecFun { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            InferenceCtxOwner::Fun(it) => &it.syntax,
            InferenceCtxOwner::SpecFun(it) => &it.syntax,
        }
    }
}
impl From<Const> for Item {
    #[inline]
    fn from(node: Const) -> Item { Item::Const(node) }
}
impl From<Enum> for Item {
    #[inline]
    fn from(node: Enum) -> Item { Item::Enum(node) }
}
impl From<Friend> for Item {
    #[inline]
    fn from(node: Friend) -> Item { Item::Friend(node) }
}
impl From<Fun> for Item {
    #[inline]
    fn from(node: Fun) -> Item { Item::Fun(node) }
}
impl From<ItemSpec> for Item {
    #[inline]
    fn from(node: ItemSpec) -> Item { Item::ItemSpec(node) }
}
impl From<Schema> for Item {
    #[inline]
    fn from(node: Schema) -> Item { Item::Schema(node) }
}
impl From<SpecFun> for Item {
    #[inline]
    fn from(node: SpecFun) -> Item { Item::SpecFun(node) }
}
impl From<Struct> for Item {
    #[inline]
    fn from(node: Struct) -> Item { Item::Struct(node) }
}
impl Item {
    pub fn const_(self) -> Option<Const> {
        match (self) {
            Item::Const(item) => Some(item),
            _ => None,
        }
    }
    pub fn enum_(self) -> Option<Enum> {
        match (self) {
            Item::Enum(item) => Some(item),
            _ => None,
        }
    }
    pub fn friend(self) -> Option<Friend> {
        match (self) {
            Item::Friend(item) => Some(item),
            _ => None,
        }
    }
    pub fn fun(self) -> Option<Fun> {
        match (self) {
            Item::Fun(item) => Some(item),
            _ => None,
        }
    }
    pub fn item_spec(self) -> Option<ItemSpec> {
        match (self) {
            Item::ItemSpec(item) => Some(item),
            _ => None,
        }
    }
    pub fn schema(self) -> Option<Schema> {
        match (self) {
            Item::Schema(item) => Some(item),
            _ => None,
        }
    }
    pub fn spec_fun(self) -> Option<SpecFun> {
        match (self) {
            Item::SpecFun(item) => Some(item),
            _ => None,
        }
    }
    pub fn struct_(self) -> Option<Struct> {
        match (self) {
            Item::Struct(item) => Some(item),
            _ => None,
        }
    }
}
impl AstNode for Item {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            CONST | ENUM | FRIEND | FUN | ITEM_SPEC | SCHEMA | SPEC_FUN | STRUCT
        )
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            CONST => Item::Const(Const { syntax }),
            ENUM => Item::Enum(Enum { syntax }),
            FRIEND => Item::Friend(Friend { syntax }),
            FUN => Item::Fun(Fun { syntax }),
            ITEM_SPEC => Item::ItemSpec(ItemSpec { syntax }),
            SCHEMA => Item::Schema(Schema { syntax }),
            SPEC_FUN => Item::SpecFun(SpecFun { syntax }),
            STRUCT => Item::Struct(Struct { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Item::Const(it) => &it.syntax,
            Item::Enum(it) => &it.syntax,
            Item::Friend(it) => &it.syntax,
            Item::Fun(it) => &it.syntax,
            Item::ItemSpec(it) => &it.syntax,
            Item::Schema(it) => &it.syntax,
            Item::SpecFun(it) => &it.syntax,
            Item::Struct(it) => &it.syntax,
        }
    }
}
impl From<IdentPat> for Pat {
    #[inline]
    fn from(node: IdentPat) -> Pat { Pat::IdentPat(node) }
}
impl From<RestPat> for Pat {
    #[inline]
    fn from(node: RestPat) -> Pat { Pat::RestPat(node) }
}
impl From<StructPat> for Pat {
    #[inline]
    fn from(node: StructPat) -> Pat { Pat::StructPat(node) }
}
impl From<TuplePat> for Pat {
    #[inline]
    fn from(node: TuplePat) -> Pat { Pat::TuplePat(node) }
}
impl From<TupleStructPat> for Pat {
    #[inline]
    fn from(node: TupleStructPat) -> Pat { Pat::TupleStructPat(node) }
}
impl From<WildcardPat> for Pat {
    #[inline]
    fn from(node: WildcardPat) -> Pat { Pat::WildcardPat(node) }
}
impl Pat {
    pub fn ident_pat(self) -> Option<IdentPat> {
        match (self) {
            Pat::IdentPat(item) => Some(item),
            _ => None,
        }
    }
    pub fn rest_pat(self) -> Option<RestPat> {
        match (self) {
            Pat::RestPat(item) => Some(item),
            _ => None,
        }
    }
    pub fn struct_pat(self) -> Option<StructPat> {
        match (self) {
            Pat::StructPat(item) => Some(item),
            _ => None,
        }
    }
    pub fn tuple_pat(self) -> Option<TuplePat> {
        match (self) {
            Pat::TuplePat(item) => Some(item),
            _ => None,
        }
    }
    pub fn tuple_struct_pat(self) -> Option<TupleStructPat> {
        match (self) {
            Pat::TupleStructPat(item) => Some(item),
            _ => None,
        }
    }
    pub fn wildcard_pat(self) -> Option<WildcardPat> {
        match (self) {
            Pat::WildcardPat(item) => Some(item),
            _ => None,
        }
    }
}
impl AstNode for Pat {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            IDENT_PAT | REST_PAT | STRUCT_PAT | TUPLE_PAT | TUPLE_STRUCT_PAT | WILDCARD_PAT
        )
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            IDENT_PAT => Pat::IdentPat(IdentPat { syntax }),
            REST_PAT => Pat::RestPat(RestPat { syntax }),
            STRUCT_PAT => Pat::StructPat(StructPat { syntax }),
            TUPLE_PAT => Pat::TuplePat(TuplePat { syntax }),
            TUPLE_STRUCT_PAT => Pat::TupleStructPat(TupleStructPat { syntax }),
            WILDCARD_PAT => Pat::WildcardPat(WildcardPat { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Pat::IdentPat(it) => &it.syntax,
            Pat::RestPat(it) => &it.syntax,
            Pat::StructPat(it) => &it.syntax,
            Pat::TuplePat(it) => &it.syntax,
            Pat::TupleStructPat(it) => &it.syntax,
            Pat::WildcardPat(it) => &it.syntax,
        }
    }
}
impl From<ExprStmt> for Stmt {
    #[inline]
    fn from(node: ExprStmt) -> Stmt { Stmt::ExprStmt(node) }
}
impl From<LetStmt> for Stmt {
    #[inline]
    fn from(node: LetStmt) -> Stmt { Stmt::LetStmt(node) }
}
impl From<SchemaField> for Stmt {
    #[inline]
    fn from(node: SchemaField) -> Stmt { Stmt::SchemaField(node) }
}
impl From<SpecInlineFun> for Stmt {
    #[inline]
    fn from(node: SpecInlineFun) -> Stmt { Stmt::SpecInlineFun(node) }
}
impl Stmt {
    pub fn expr_stmt(self) -> Option<ExprStmt> {
        match (self) {
            Stmt::ExprStmt(item) => Some(item),
            _ => None,
        }
    }
    pub fn let_stmt(self) -> Option<LetStmt> {
        match (self) {
            Stmt::LetStmt(item) => Some(item),
            _ => None,
        }
    }
    pub fn schema_field(self) -> Option<SchemaField> {
        match (self) {
            Stmt::SchemaField(item) => Some(item),
            _ => None,
        }
    }
    pub fn spec_inline_fun(self) -> Option<SpecInlineFun> {
        match (self) {
            Stmt::SpecInlineFun(item) => Some(item),
            _ => None,
        }
    }
}
impl AstNode for Stmt {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, EXPR_STMT | LET_STMT | SCHEMA_FIELD | SPEC_INLINE_FUN)
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            EXPR_STMT => Stmt::ExprStmt(ExprStmt { syntax }),
            LET_STMT => Stmt::LetStmt(LetStmt { syntax }),
            SCHEMA_FIELD => Stmt::SchemaField(SchemaField { syntax }),
            SPEC_INLINE_FUN => Stmt::SpecInlineFun(SpecInlineFun { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Stmt::ExprStmt(it) => &it.syntax,
            Stmt::LetStmt(it) => &it.syntax,
            Stmt::SchemaField(it) => &it.syntax,
            Stmt::SpecInlineFun(it) => &it.syntax,
        }
    }
}
impl From<Enum> for StructOrEnum {
    #[inline]
    fn from(node: Enum) -> StructOrEnum { StructOrEnum::Enum(node) }
}
impl From<Struct> for StructOrEnum {
    #[inline]
    fn from(node: Struct) -> StructOrEnum { StructOrEnum::Struct(node) }
}
impl StructOrEnum {
    pub fn enum_(self) -> Option<Enum> {
        match (self) {
            StructOrEnum::Enum(item) => Some(item),
            _ => None,
        }
    }
    pub fn struct_(self) -> Option<Struct> {
        match (self) {
            StructOrEnum::Struct(item) => Some(item),
            _ => None,
        }
    }
}
impl AstNode for StructOrEnum {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, ENUM | STRUCT) }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            ENUM => StructOrEnum::Enum(Enum { syntax }),
            STRUCT => StructOrEnum::Struct(Struct { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            StructOrEnum::Enum(it) => &it.syntax,
            StructOrEnum::Struct(it) => &it.syntax,
        }
    }
}
impl From<ParenType> for Type {
    #[inline]
    fn from(node: ParenType) -> Type { Type::ParenType(node) }
}
impl From<PathType> for Type {
    #[inline]
    fn from(node: PathType) -> Type { Type::PathType(node) }
}
impl From<RefType> for Type {
    #[inline]
    fn from(node: RefType) -> Type { Type::RefType(node) }
}
impl From<TupleType> for Type {
    #[inline]
    fn from(node: TupleType) -> Type { Type::TupleType(node) }
}
impl From<UnitType> for Type {
    #[inline]
    fn from(node: UnitType) -> Type { Type::UnitType(node) }
}
impl Type {
    pub fn paren_type(self) -> Option<ParenType> {
        match (self) {
            Type::ParenType(item) => Some(item),
            _ => None,
        }
    }
    pub fn path_type(self) -> Option<PathType> {
        match (self) {
            Type::PathType(item) => Some(item),
            _ => None,
        }
    }
    pub fn ref_type(self) -> Option<RefType> {
        match (self) {
            Type::RefType(item) => Some(item),
            _ => None,
        }
    }
    pub fn tuple_type(self) -> Option<TupleType> {
        match (self) {
            Type::TupleType(item) => Some(item),
            _ => None,
        }
    }
    pub fn unit_type(self) -> Option<UnitType> {
        match (self) {
            Type::UnitType(item) => Some(item),
            _ => None,
        }
    }
}
impl AstNode for Type {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, PAREN_TYPE | PATH_TYPE | REF_TYPE | TUPLE_TYPE | UNIT_TYPE)
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            PAREN_TYPE => Type::ParenType(ParenType { syntax }),
            PATH_TYPE => Type::PathType(PathType { syntax }),
            REF_TYPE => Type::RefType(RefType { syntax }),
            TUPLE_TYPE => Type::TupleType(TupleType { syntax }),
            UNIT_TYPE => Type::UnitType(UnitType { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Type::ParenType(it) => &it.syntax,
            Type::PathType(it) => &it.syntax,
            Type::RefType(it) => &it.syntax,
            Type::TupleType(it) => &it.syntax,
            Type::UnitType(it) => &it.syntax,
        }
    }
}
impl AnyHasAttrs {
    #[inline]
    pub fn new<T: ast::HasAttrs>(node: T) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax().clone(),
        }
    }
}
impl AstNode for AnyHasAttrs {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            BIN_EXPR
                | CONST
                | ENUM
                | FUN
                | ITEM_SPEC
                | MODULE
                | MODULE_SPEC
                | NAMED_FIELD
                | SCHEMA
                | SCRIPT
                | SPEC_FUN
                | STRUCT
                | TUPLE_FIELD
                | USE_STMT
                | VARIANT
        )
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        Self::can_cast(syntax.kind()).then_some(AnyHasAttrs { syntax })
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl From<BinExpr> for AnyHasAttrs {
    #[inline]
    fn from(node: BinExpr) -> AnyHasAttrs { AnyHasAttrs { syntax: node.syntax } }
}
impl From<Const> for AnyHasAttrs {
    #[inline]
    fn from(node: Const) -> AnyHasAttrs { AnyHasAttrs { syntax: node.syntax } }
}
impl From<Enum> for AnyHasAttrs {
    #[inline]
    fn from(node: Enum) -> AnyHasAttrs { AnyHasAttrs { syntax: node.syntax } }
}
impl From<Fun> for AnyHasAttrs {
    #[inline]
    fn from(node: Fun) -> AnyHasAttrs { AnyHasAttrs { syntax: node.syntax } }
}
impl From<ItemSpec> for AnyHasAttrs {
    #[inline]
    fn from(node: ItemSpec) -> AnyHasAttrs { AnyHasAttrs { syntax: node.syntax } }
}
impl From<Module> for AnyHasAttrs {
    #[inline]
    fn from(node: Module) -> AnyHasAttrs { AnyHasAttrs { syntax: node.syntax } }
}
impl From<ModuleSpec> for AnyHasAttrs {
    #[inline]
    fn from(node: ModuleSpec) -> AnyHasAttrs { AnyHasAttrs { syntax: node.syntax } }
}
impl From<NamedField> for AnyHasAttrs {
    #[inline]
    fn from(node: NamedField) -> AnyHasAttrs { AnyHasAttrs { syntax: node.syntax } }
}
impl From<Schema> for AnyHasAttrs {
    #[inline]
    fn from(node: Schema) -> AnyHasAttrs { AnyHasAttrs { syntax: node.syntax } }
}
impl From<Script> for AnyHasAttrs {
    #[inline]
    fn from(node: Script) -> AnyHasAttrs { AnyHasAttrs { syntax: node.syntax } }
}
impl From<SpecFun> for AnyHasAttrs {
    #[inline]
    fn from(node: SpecFun) -> AnyHasAttrs { AnyHasAttrs { syntax: node.syntax } }
}
impl From<Struct> for AnyHasAttrs {
    #[inline]
    fn from(node: Struct) -> AnyHasAttrs { AnyHasAttrs { syntax: node.syntax } }
}
impl From<TupleField> for AnyHasAttrs {
    #[inline]
    fn from(node: TupleField) -> AnyHasAttrs { AnyHasAttrs { syntax: node.syntax } }
}
impl From<UseStmt> for AnyHasAttrs {
    #[inline]
    fn from(node: UseStmt) -> AnyHasAttrs { AnyHasAttrs { syntax: node.syntax } }
}
impl From<Variant> for AnyHasAttrs {
    #[inline]
    fn from(node: Variant) -> AnyHasAttrs { AnyHasAttrs { syntax: node.syntax } }
}
impl AnyHasFields {
    #[inline]
    pub fn new<T: ast::HasFields>(node: T) -> AnyHasFields {
        AnyHasFields {
            syntax: node.syntax().clone(),
        }
    }
}
impl AstNode for AnyHasFields {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, STRUCT | VARIANT) }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        Self::can_cast(syntax.kind()).then_some(AnyHasFields { syntax })
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl From<Struct> for AnyHasFields {
    #[inline]
    fn from(node: Struct) -> AnyHasFields { AnyHasFields { syntax: node.syntax } }
}
impl From<Variant> for AnyHasFields {
    #[inline]
    fn from(node: Variant) -> AnyHasFields { AnyHasFields { syntax: node.syntax } }
}
impl AnyHasItems {
    #[inline]
    pub fn new<T: ast::HasItems>(node: T) -> AnyHasItems {
        AnyHasItems {
            syntax: node.syntax().clone(),
        }
    }
}
impl AstNode for AnyHasItems {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, MODULE | MODULE_SPEC | SCRIPT) }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        Self::can_cast(syntax.kind()).then_some(AnyHasItems { syntax })
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl From<Module> for AnyHasItems {
    #[inline]
    fn from(node: Module) -> AnyHasItems { AnyHasItems { syntax: node.syntax } }
}
impl From<ModuleSpec> for AnyHasItems {
    #[inline]
    fn from(node: ModuleSpec) -> AnyHasItems { AnyHasItems { syntax: node.syntax } }
}
impl From<Script> for AnyHasItems {
    #[inline]
    fn from(node: Script) -> AnyHasItems { AnyHasItems { syntax: node.syntax } }
}
impl AnyHasName {
    #[inline]
    pub fn new<T: ast::HasName>(node: T) -> AnyHasName {
        AnyHasName {
            syntax: node.syntax().clone(),
        }
    }
}
impl AstNode for AnyHasName {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            CONST
                | ENUM
                | FUN
                | IDENT_PAT
                | MODULE
                | NAMED_FIELD
                | SCHEMA
                | SPEC_FUN
                | SPEC_INLINE_FUN
                | STRUCT
                | TYPE_PARAM
                | USE_ALIAS
                | VARIANT
        )
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        Self::can_cast(syntax.kind()).then_some(AnyHasName { syntax })
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl From<Const> for AnyHasName {
    #[inline]
    fn from(node: Const) -> AnyHasName { AnyHasName { syntax: node.syntax } }
}
impl From<Enum> for AnyHasName {
    #[inline]
    fn from(node: Enum) -> AnyHasName { AnyHasName { syntax: node.syntax } }
}
impl From<Fun> for AnyHasName {
    #[inline]
    fn from(node: Fun) -> AnyHasName { AnyHasName { syntax: node.syntax } }
}
impl From<IdentPat> for AnyHasName {
    #[inline]
    fn from(node: IdentPat) -> AnyHasName { AnyHasName { syntax: node.syntax } }
}
impl From<Module> for AnyHasName {
    #[inline]
    fn from(node: Module) -> AnyHasName { AnyHasName { syntax: node.syntax } }
}
impl From<NamedField> for AnyHasName {
    #[inline]
    fn from(node: NamedField) -> AnyHasName { AnyHasName { syntax: node.syntax } }
}
impl From<Schema> for AnyHasName {
    #[inline]
    fn from(node: Schema) -> AnyHasName { AnyHasName { syntax: node.syntax } }
}
impl From<SpecFun> for AnyHasName {
    #[inline]
    fn from(node: SpecFun) -> AnyHasName { AnyHasName { syntax: node.syntax } }
}
impl From<SpecInlineFun> for AnyHasName {
    #[inline]
    fn from(node: SpecInlineFun) -> AnyHasName { AnyHasName { syntax: node.syntax } }
}
impl From<Struct> for AnyHasName {
    #[inline]
    fn from(node: Struct) -> AnyHasName { AnyHasName { syntax: node.syntax } }
}
impl From<TypeParam> for AnyHasName {
    #[inline]
    fn from(node: TypeParam) -> AnyHasName { AnyHasName { syntax: node.syntax } }
}
impl From<UseAlias> for AnyHasName {
    #[inline]
    fn from(node: UseAlias) -> AnyHasName { AnyHasName { syntax: node.syntax } }
}
impl From<Variant> for AnyHasName {
    #[inline]
    fn from(node: Variant) -> AnyHasName { AnyHasName { syntax: node.syntax } }
}
impl AnyHasReference {
    #[inline]
    pub fn new<T: ast::HasReference>(node: T) -> AnyHasReference {
        AnyHasReference {
            syntax: node.syntax().clone(),
        }
    }
}
impl AstNode for AnyHasReference {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, PATH | STRUCT_LIT_FIELD | STRUCT_PAT_FIELD) }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        Self::can_cast(syntax.kind()).then_some(AnyHasReference { syntax })
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl From<Path> for AnyHasReference {
    #[inline]
    fn from(node: Path) -> AnyHasReference { AnyHasReference { syntax: node.syntax } }
}
impl From<StructLitField> for AnyHasReference {
    #[inline]
    fn from(node: StructLitField) -> AnyHasReference { AnyHasReference { syntax: node.syntax } }
}
impl From<StructPatField> for AnyHasReference {
    #[inline]
    fn from(node: StructPatField) -> AnyHasReference { AnyHasReference { syntax: node.syntax } }
}
impl AnyHasStmts {
    #[inline]
    pub fn new<T: ast::HasStmts>(node: T) -> AnyHasStmts {
        AnyHasStmts {
            syntax: node.syntax().clone(),
        }
    }
}
impl AstNode for AnyHasStmts {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, BLOCK_EXPR) }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        Self::can_cast(syntax.kind()).then_some(AnyHasStmts { syntax })
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl From<BlockExpr> for AnyHasStmts {
    #[inline]
    fn from(node: BlockExpr) -> AnyHasStmts { AnyHasStmts { syntax: node.syntax } }
}
impl AnyHasTypeParams {
    #[inline]
    pub fn new<T: ast::HasTypeParams>(node: T) -> AnyHasTypeParams {
        AnyHasTypeParams {
            syntax: node.syntax().clone(),
        }
    }
}
impl AstNode for AnyHasTypeParams {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, ENUM | FUN | SCHEMA | SPEC_FUN | SPEC_INLINE_FUN | STRUCT)
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        Self::can_cast(syntax.kind()).then_some(AnyHasTypeParams { syntax })
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl From<Enum> for AnyHasTypeParams {
    #[inline]
    fn from(node: Enum) -> AnyHasTypeParams { AnyHasTypeParams { syntax: node.syntax } }
}
impl From<Fun> for AnyHasTypeParams {
    #[inline]
    fn from(node: Fun) -> AnyHasTypeParams { AnyHasTypeParams { syntax: node.syntax } }
}
impl From<Schema> for AnyHasTypeParams {
    #[inline]
    fn from(node: Schema) -> AnyHasTypeParams { AnyHasTypeParams { syntax: node.syntax } }
}
impl From<SpecFun> for AnyHasTypeParams {
    #[inline]
    fn from(node: SpecFun) -> AnyHasTypeParams { AnyHasTypeParams { syntax: node.syntax } }
}
impl From<SpecInlineFun> for AnyHasTypeParams {
    #[inline]
    fn from(node: SpecInlineFun) -> AnyHasTypeParams { AnyHasTypeParams { syntax: node.syntax } }
}
impl From<Struct> for AnyHasTypeParams {
    #[inline]
    fn from(node: Struct) -> AnyHasTypeParams { AnyHasTypeParams { syntax: node.syntax } }
}
impl AnyHasUseStmts {
    #[inline]
    pub fn new<T: ast::HasUseStmts>(node: T) -> AnyHasUseStmts {
        AnyHasUseStmts {
            syntax: node.syntax().clone(),
        }
    }
}
impl AstNode for AnyHasUseStmts {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, BLOCK_EXPR | MODULE | MODULE_SPEC | SCRIPT) }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        Self::can_cast(syntax.kind()).then_some(AnyHasUseStmts { syntax })
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl From<BlockExpr> for AnyHasUseStmts {
    #[inline]
    fn from(node: BlockExpr) -> AnyHasUseStmts { AnyHasUseStmts { syntax: node.syntax } }
}
impl From<Module> for AnyHasUseStmts {
    #[inline]
    fn from(node: Module) -> AnyHasUseStmts { AnyHasUseStmts { syntax: node.syntax } }
}
impl From<ModuleSpec> for AnyHasUseStmts {
    #[inline]
    fn from(node: ModuleSpec) -> AnyHasUseStmts { AnyHasUseStmts { syntax: node.syntax } }
}
impl From<Script> for AnyHasUseStmts {
    #[inline]
    fn from(node: Script) -> AnyHasUseStmts { AnyHasUseStmts { syntax: node.syntax } }
}
impl AnyHasVisibility {
    #[inline]
    pub fn new<T: ast::HasVisibility>(node: T) -> AnyHasVisibility {
        AnyHasVisibility {
            syntax: node.syntax().clone(),
        }
    }
}
impl AstNode for AnyHasVisibility {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, CONST | ENUM | FUN | SPEC_FUN | SPEC_INLINE_FUN | STRUCT)
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        Self::can_cast(syntax.kind()).then_some(AnyHasVisibility { syntax })
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl From<Const> for AnyHasVisibility {
    #[inline]
    fn from(node: Const) -> AnyHasVisibility { AnyHasVisibility { syntax: node.syntax } }
}
impl From<Enum> for AnyHasVisibility {
    #[inline]
    fn from(node: Enum) -> AnyHasVisibility { AnyHasVisibility { syntax: node.syntax } }
}
impl From<Fun> for AnyHasVisibility {
    #[inline]
    fn from(node: Fun) -> AnyHasVisibility { AnyHasVisibility { syntax: node.syntax } }
}
impl From<SpecFun> for AnyHasVisibility {
    #[inline]
    fn from(node: SpecFun) -> AnyHasVisibility { AnyHasVisibility { syntax: node.syntax } }
}
impl From<SpecInlineFun> for AnyHasVisibility {
    #[inline]
    fn from(node: SpecInlineFun) -> AnyHasVisibility { AnyHasVisibility { syntax: node.syntax } }
}
impl From<Struct> for AnyHasVisibility {
    #[inline]
    fn from(node: Struct) -> AnyHasVisibility { AnyHasVisibility { syntax: node.syntax } }
}
impl AnyMslOnly {
    #[inline]
    pub fn new<T: ast::MslOnly>(node: T) -> AnyMslOnly {
        AnyMslOnly {
            syntax: node.syntax().clone(),
        }
    }
}
impl AstNode for AnyMslOnly {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            ITEM_SPEC | MODULE_SPEC | SCHEMA | SCHEMA_FIELD | SPEC_FUN | SPEC_INLINE_FUN
        )
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        Self::can_cast(syntax.kind()).then_some(AnyMslOnly { syntax })
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl From<ItemSpec> for AnyMslOnly {
    #[inline]
    fn from(node: ItemSpec) -> AnyMslOnly { AnyMslOnly { syntax: node.syntax } }
}
impl From<ModuleSpec> for AnyMslOnly {
    #[inline]
    fn from(node: ModuleSpec) -> AnyMslOnly { AnyMslOnly { syntax: node.syntax } }
}
impl From<Schema> for AnyMslOnly {
    #[inline]
    fn from(node: Schema) -> AnyMslOnly { AnyMslOnly { syntax: node.syntax } }
}
impl From<SchemaField> for AnyMslOnly {
    #[inline]
    fn from(node: SchemaField) -> AnyMslOnly { AnyMslOnly { syntax: node.syntax } }
}
impl From<SpecFun> for AnyMslOnly {
    #[inline]
    fn from(node: SpecFun) -> AnyMslOnly { AnyMslOnly { syntax: node.syntax } }
}
impl From<SpecInlineFun> for AnyMslOnly {
    #[inline]
    fn from(node: SpecInlineFun) -> AnyMslOnly { AnyMslOnly { syntax: node.syntax } }
}
impl std::fmt::Display for AddressRef {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyField {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for BindingTypeOwner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Expr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for FieldList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for InferenceCtxOwner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Item {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Pat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Stmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for StructOrEnum {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Type {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AddressDef {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ArgList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Attr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AttrItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for BinExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for BlockExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CallExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Const {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Enum {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ExprStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ForCondition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ForExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Friend {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Fun {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for IdentPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for InlineExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ItemSpec {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for LetStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Literal {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Module {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ModuleSpec {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Name {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for NameRef {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for NamedAddress {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for NamedField {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for NamedFieldList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Param {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ParamList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ParenExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ParenType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Path {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PathAddress {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PathExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PathSegment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PathType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for RefType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for RestPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for RetType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Schema {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SchemaField {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Script {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SourceFile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SpecFun {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SpecInlineFun {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Struct {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for StructLit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for StructLitField {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for StructLitFieldList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for StructPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for StructPatField {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for StructPatFieldList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TupleField {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TupleFieldList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TuplePat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TupleStructPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TupleType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TypeArg {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TypeArgList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TypeParam {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TypeParamList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for UnitType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for UseAlias {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for UseGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for UseSpeck {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for UseStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ValueAddress {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Variant {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for VariantList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for VisibilityModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for WildcardPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
