//! Generated by `cargo codegen sourcegen_ast`, do not edit by hand.

#![allow(non_snake_case)]
use crate::{
    ast::{self, support, AstChildren, AstNode},
    SyntaxKind::{self, *},
    SyntaxNode, SyntaxToken, T,
};

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Attr {
    pub(crate) syntax: SyntaxNode,
}
impl Attr {
    #[inline]
    pub fn attr_item(&self) -> Option<AttrItem> { support::child(&self.syntax) }
    #[inline]
    pub fn excl_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![!]) }
    #[inline]
    pub fn pound_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![#]) }
    #[inline]
    pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['[']) }
    #[inline]
    pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AttrItem {
    pub(crate) syntax: SyntaxNode,
}
impl AttrItem {
    #[inline]
    pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BinExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for BinExpr {}
impl BinExpr {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BlockExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasStmtList for BlockExpr {}
impl BlockExpr {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Const {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for Const {}
impl ast::HasName for Const {}
impl Const {
    #[inline]
    pub fn body(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn type_(&self) -> Option<Type> { support::child(&self.syntax) }
    #[inline]
    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }
    #[inline]
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }
    #[inline]
    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }
    #[inline]
    pub fn const_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![const]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Enum {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for Enum {}
impl ast::HasName for Enum {}
impl ast::HasTypeParams for Enum {}
impl Enum {
    #[inline]
    pub fn variant_list(&self) -> Option<VariantList> { support::child(&self.syntax) }
    #[inline]
    pub fn enum_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![enum]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ExprStmt {
    pub(crate) syntax: SyntaxNode,
}
impl ExprStmt {
    #[inline]
    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Fun {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for Fun {}
impl ast::HasName for Fun {}
impl ast::HasTypeParams for Fun {}
impl Fun {
    #[inline]
    pub fn body(&self) -> Option<BlockExpr> { support::child(&self.syntax) }
    #[inline]
    pub fn param_list(&self) -> Option<ParamList> { support::child(&self.syntax) }
    #[inline]
    pub fn ret_type(&self) -> Option<RetType> { support::child(&self.syntax) }
    #[inline]
    pub fn visibility(&self) -> Option<Visibility> { support::child(&self.syntax) }
    #[inline]
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }
    #[inline]
    pub fn fun_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![fun]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IdentPat {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for IdentPat {}
impl IdentPat {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ItemList {
    pub(crate) syntax: SyntaxNode,
}
impl ItemList {
    #[inline]
    pub fn items(&self) -> AstChildren<Item> { support::children(&self.syntax) }
    #[inline]
    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }
    #[inline]
    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ItemSpec {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for ItemSpec {}
impl ItemSpec {
    #[inline]
    pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }
    #[inline]
    pub fn spec_block(&self) -> Option<BlockExpr> { support::child(&self.syntax) }
    #[inline]
    pub fn module_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![module]) }
    #[inline]
    pub fn spec_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![spec]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LetStmt {
    pub(crate) syntax: SyntaxNode,
}
impl LetStmt {
    #[inline]
    pub fn initializer(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }
    #[inline]
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }
    #[inline]
    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }
    #[inline]
    pub fn let_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![let]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Literal {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for Literal {}
impl Literal {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Module {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for Module {}
impl ast::HasItemList for Module {}
impl ast::HasName for Module {}
impl Module {
    #[inline]
    pub fn module_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![module]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ModuleSpec {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for ModuleSpec {}
impl ast::HasItemList for ModuleSpec {}
impl ModuleSpec {
    #[inline]
    pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }
    #[inline]
    pub fn spec_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![spec]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Name {
    pub(crate) syntax: SyntaxNode,
}
impl Name {
    #[inline]
    pub fn ident_token(&self) -> SyntaxToken {
        support::token(&self.syntax, T![ident]).expect("required by the parser")
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NameRef {
    pub(crate) syntax: SyntaxNode,
}
impl NameRef {
    #[inline]
    pub fn ident_token(&self) -> SyntaxToken {
        support::token(&self.syntax, T![ident]).expect("required by the parser")
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NamedAddress {
    pub(crate) syntax: SyntaxNode,
}
impl NamedAddress {
    #[inline]
    pub fn ident_token(&self) -> SyntaxToken {
        support::token(&self.syntax, T![ident]).expect("required by the parser")
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Param {
    pub(crate) syntax: SyntaxNode,
}
impl Param {
    #[inline]
    pub fn ident_pat(&self) -> IdentPat { support::child(&self.syntax).expect("required by the parser") }
    #[inline]
    pub fn type_(&self) -> Option<Type> { support::child(&self.syntax) }
    #[inline]
    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParamList {
    pub(crate) syntax: SyntaxNode,
}
impl ParamList {
    #[inline]
    pub fn params(&self) -> AstChildren<Param> { support::children(&self.syntax) }
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParenExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ParenExpr {
    #[inline]
    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Path {
    pub(crate) syntax: SyntaxNode,
}
impl Path {
    #[inline]
    pub fn qualifier(&self) -> Option<Path> { support::child(&self.syntax) }
    #[inline]
    pub fn segment(&self) -> PathSegment {
        support::child(&self.syntax).expect("required by the parser")
    }
    #[inline]
    pub fn coloncolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![::]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PathAddress {
    pub(crate) syntax: SyntaxNode,
}
impl PathAddress {
    #[inline]
    pub fn value_address(&self) -> ValueAddress {
        support::child(&self.syntax).expect("required by the parser")
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PathExpr {
    pub(crate) syntax: SyntaxNode,
}
impl PathExpr {
    #[inline]
    pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PathSegment {
    pub(crate) syntax: SyntaxNode,
}
impl PathSegment {
    #[inline]
    pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }
    #[inline]
    pub fn path_address(&self) -> Option<PathAddress> { support::child(&self.syntax) }
    #[inline]
    pub fn type_arg_list(&self) -> Option<TypeArgList> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PathType {
    pub(crate) syntax: SyntaxNode,
}
impl PathType {
    #[inline]
    pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixExpr {
    pub(crate) syntax: SyntaxNode,
}
impl PrefixExpr {
    #[inline]
    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RefType {
    pub(crate) syntax: SyntaxNode,
}
impl RefType {
    #[inline]
    pub fn type_(&self) -> Option<Type> { support::child(&self.syntax) }
    #[inline]
    pub fn amp_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![&]) }
    #[inline]
    pub fn mut_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![mut]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RetType {
    pub(crate) syntax: SyntaxNode,
}
impl RetType {
    #[inline]
    pub fn type_(&self) -> Option<Type> { support::child(&self.syntax) }
    #[inline]
    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Schema {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for Schema {}
impl ast::HasName for Schema {}
impl ast::HasTypeParams for Schema {}
impl Schema {
    #[inline]
    pub fn spec_block(&self) -> Option<BlockExpr> { support::child(&self.syntax) }
    #[inline]
    pub fn schema_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![schema]) }
    #[inline]
    pub fn spec_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![spec]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SchemaField {
    pub(crate) syntax: SyntaxNode,
}
impl SchemaField {
    #[inline]
    pub fn ident_pat(&self) -> Option<IdentPat> { support::child(&self.syntax) }
    #[inline]
    pub fn type_(&self) -> Option<Type> { support::child(&self.syntax) }
    #[inline]
    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }
    #[inline]
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }
    #[inline]
    pub fn local_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![local]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Script {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for Script {}
impl ast::HasItemList for Script {}
impl Script {
    #[inline]
    pub fn script_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![script]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SourceFile {
    pub(crate) syntax: SyntaxNode,
}
impl SourceFile {
    #[inline]
    pub fn module_specs(&self) -> AstChildren<ModuleSpec> { support::children(&self.syntax) }
    #[inline]
    pub fn modules(&self) -> AstChildren<Module> { support::children(&self.syntax) }
    #[inline]
    pub fn scripts(&self) -> AstChildren<Script> { support::children(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SpecFun {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for SpecFun {}
impl ast::HasName for SpecFun {}
impl ast::HasTypeParams for SpecFun {}
impl SpecFun {
    #[inline]
    pub fn param_list(&self) -> Option<ParamList> { support::child(&self.syntax) }
    #[inline]
    pub fn ret_type(&self) -> Option<RetType> { support::child(&self.syntax) }
    #[inline]
    pub fn spec_block(&self) -> Option<BlockExpr> { support::child(&self.syntax) }
    #[inline]
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }
    #[inline]
    pub fn fun_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![fun]) }
    #[inline]
    pub fn native_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![native]) }
    #[inline]
    pub fn spec_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![spec]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SpecInlineFun {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for SpecInlineFun {}
impl ast::HasTypeParams for SpecInlineFun {}
impl SpecInlineFun {
    #[inline]
    pub fn param_list(&self) -> Option<ParamList> { support::child(&self.syntax) }
    #[inline]
    pub fn ret_type(&self) -> Option<RetType> { support::child(&self.syntax) }
    #[inline]
    pub fn spec_block(&self) -> Option<BlockExpr> { support::child(&self.syntax) }
    #[inline]
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }
    #[inline]
    pub fn fun_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![fun]) }
    #[inline]
    pub fn native_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![native]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StmtList {
    pub(crate) syntax: SyntaxNode,
}
impl StmtList {
    #[inline]
    pub fn statements(&self) -> AstChildren<Stmt> { support::children(&self.syntax) }
    #[inline]
    pub fn tail_expr(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }
    #[inline]
    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Struct {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for Struct {}
impl ast::HasName for Struct {}
impl ast::HasTypeParams for Struct {}
impl Struct {
    #[inline]
    pub fn struct_field_list(&self) -> Option<StructFieldList> { support::child(&self.syntax) }
    #[inline]
    pub fn tuple_field_list(&self) -> Option<TupleFieldList> { support::child(&self.syntax) }
    #[inline]
    pub fn struct_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![struct]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StructField {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for StructField {}
impl ast::HasName for StructField {}
impl StructField {
    #[inline]
    pub fn type_(&self) -> Option<Type> { support::child(&self.syntax) }
    #[inline]
    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StructFieldList {
    pub(crate) syntax: SyntaxNode,
}
impl StructFieldList {
    #[inline]
    pub fn fields(&self) -> AstChildren<StructField> { support::children(&self.syntax) }
    #[inline]
    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }
    #[inline]
    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TupleField {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for TupleField {}
impl TupleField {
    #[inline]
    pub fn type_(&self) -> Option<Type> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TupleFieldList {
    pub(crate) syntax: SyntaxNode,
}
impl TupleFieldList {
    #[inline]
    pub fn fields(&self) -> AstChildren<TupleField> { support::children(&self.syntax) }
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TuplePat {
    pub(crate) syntax: SyntaxNode,
}
impl TuplePat {
    #[inline]
    pub fn fields(&self) -> AstChildren<Pat> { support::children(&self.syntax) }
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeArg {
    pub(crate) syntax: SyntaxNode,
}
impl TypeArg {
    #[inline]
    pub fn type_(&self) -> Option<Type> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeArgList {
    pub(crate) syntax: SyntaxNode,
}
impl TypeArgList {
    #[inline]
    pub fn type_arguments(&self) -> AstChildren<TypeArg> { support::children(&self.syntax) }
    #[inline]
    pub fn l_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![<]) }
    #[inline]
    pub fn r_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![>]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeParam {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for TypeParam {}
impl TypeParam {
    #[inline]
    pub fn phantom_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![phantom]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeParamList {
    pub(crate) syntax: SyntaxNode,
}
impl TypeParamList {
    #[inline]
    pub fn type_parameters(&self) -> AstChildren<TypeParam> { support::children(&self.syntax) }
    #[inline]
    pub fn l_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![<]) }
    #[inline]
    pub fn r_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![>]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UseAlias {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for UseAlias {}
impl UseAlias {
    #[inline]
    pub fn as_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![as]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UseGroup {
    pub(crate) syntax: SyntaxNode,
}
impl UseGroup {
    #[inline]
    pub fn use_specks(&self) -> AstChildren<UseSpeck> { support::children(&self.syntax) }
    #[inline]
    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }
    #[inline]
    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UseItem {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for UseItem {}
impl UseItem {
    #[inline]
    pub fn use_speck(&self) -> Option<UseSpeck> { support::child(&self.syntax) }
    #[inline]
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }
    #[inline]
    pub fn use_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![use]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UseSpeck {
    pub(crate) syntax: SyntaxNode,
}
impl UseSpeck {
    #[inline]
    pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }
    #[inline]
    pub fn use_alias(&self) -> Option<UseAlias> { support::child(&self.syntax) }
    #[inline]
    pub fn use_group(&self) -> Option<UseGroup> { support::child(&self.syntax) }
    #[inline]
    pub fn coloncolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![::]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ValueAddress {
    pub(crate) syntax: SyntaxNode,
}
impl ValueAddress {
    #[inline]
    pub fn int_number_token(&self) -> SyntaxToken {
        support::token(&self.syntax, T![int_number]).expect("required by the parser")
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Variant {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for Variant {}
impl ast::HasName for Variant {}
impl Variant {
    #[inline]
    pub fn struct_field_list(&self) -> Option<StructFieldList> { support::child(&self.syntax) }
    #[inline]
    pub fn tuple_field_list(&self) -> Option<TupleFieldList> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct VariantList {
    pub(crate) syntax: SyntaxNode,
}
impl VariantList {
    #[inline]
    pub fn variants(&self) -> AstChildren<Variant> { support::children(&self.syntax) }
    #[inline]
    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }
    #[inline]
    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Visibility {
    pub(crate) syntax: SyntaxNode,
}
impl Visibility {
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }
    #[inline]
    pub fn friend_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![friend]) }
    #[inline]
    pub fn package_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![package]) }
    #[inline]
    pub fn public_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![public]) }
    #[inline]
    pub fn script_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![script]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum AddressRef {
    NamedAddress(NamedAddress),
    ValueAddress(ValueAddress),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Adt {
    Enum(Enum),
    Struct(Struct),
}
impl ast::HasAttrs for Adt {}
impl ast::HasName for Adt {}
impl ast::HasTypeParams for Adt {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Expr {
    BinExpr(BinExpr),
    Literal(Literal),
    ParenExpr(ParenExpr),
    PathExpr(PathExpr),
    PrefixExpr(PrefixExpr),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum FieldList {
    StructFieldList(StructFieldList),
    TupleFieldList(TupleFieldList),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Item {
    Const(Const),
    Enum(Enum),
    Fun(Fun),
    ItemSpec(ItemSpec),
    Schema(Schema),
    SpecFun(SpecFun),
    Struct(Struct),
    UseItem(UseItem),
}
impl ast::HasAttrs for Item {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Pat {
    IdentPat(IdentPat),
    TuplePat(TuplePat),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Stmt {
    ExprStmt(ExprStmt),
    LetStmt(LetStmt),
    SchemaField(SchemaField),
    SpecInlineFun(SpecInlineFun),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Type {
    PathType(PathType),
    RefType(RefType),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AnyHasAttrs {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for AnyHasAttrs {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AnyHasItemList {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasItemList for AnyHasItemList {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AnyHasName {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for AnyHasName {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AnyHasStmtList {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasStmtList for AnyHasStmtList {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AnyHasTypeParams {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasTypeParams for AnyHasTypeParams {}
impl AstNode for Attr {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        ATTR
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == ATTR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for AttrItem {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        ATTR_ITEM
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == ATTR_ITEM }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for BinExpr {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        BIN_EXPR
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == BIN_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for BlockExpr {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        BLOCK_EXPR
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == BLOCK_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Const {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        CONST
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == CONST }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Enum {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        ENUM
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == ENUM }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for ExprStmt {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        EXPR_STMT
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == EXPR_STMT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Fun {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        FUN
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == FUN }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for IdentPat {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        IDENT_PAT
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == IDENT_PAT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for ItemList {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        ITEM_LIST
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == ITEM_LIST }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for ItemSpec {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        ITEM_SPEC
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == ITEM_SPEC }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for LetStmt {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        LET_STMT
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == LET_STMT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Literal {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        LITERAL
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == LITERAL }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Module {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        MODULE
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == MODULE }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for ModuleSpec {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        MODULE_SPEC
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == MODULE_SPEC }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Name {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        NAME
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == NAME }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for NameRef {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        NAME_REF
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == NAME_REF }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for NamedAddress {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        NAMED_ADDRESS
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == NAMED_ADDRESS }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Param {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        PARAM
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == PARAM }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for ParamList {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        PARAM_LIST
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == PARAM_LIST }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for ParenExpr {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        PAREN_EXPR
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == PAREN_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Path {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        PATH
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == PATH }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for PathAddress {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        PATH_ADDRESS
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == PATH_ADDRESS }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for PathExpr {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        PATH_EXPR
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == PATH_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for PathSegment {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        PATH_SEGMENT
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == PATH_SEGMENT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for PathType {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        PATH_TYPE
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == PATH_TYPE }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for PrefixExpr {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        PREFIX_EXPR
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == PREFIX_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for RefType {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        REF_TYPE
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == REF_TYPE }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for RetType {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        RET_TYPE
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == RET_TYPE }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Schema {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        SCHEMA
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == SCHEMA }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for SchemaField {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        SCHEMA_FIELD
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == SCHEMA_FIELD }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Script {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        SCRIPT
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == SCRIPT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for SourceFile {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        SOURCE_FILE
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == SOURCE_FILE }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for SpecFun {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        SPEC_FUN
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == SPEC_FUN }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for SpecInlineFun {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        SPEC_INLINE_FUN
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == SPEC_INLINE_FUN }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for StmtList {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        STMT_LIST
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == STMT_LIST }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Struct {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        STRUCT
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == STRUCT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for StructField {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        STRUCT_FIELD
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == STRUCT_FIELD }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for StructFieldList {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        STRUCT_FIELD_LIST
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == STRUCT_FIELD_LIST }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for TupleField {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        TUPLE_FIELD
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == TUPLE_FIELD }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for TupleFieldList {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        TUPLE_FIELD_LIST
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == TUPLE_FIELD_LIST }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for TuplePat {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        TUPLE_PAT
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == TUPLE_PAT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for TypeArg {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        TYPE_ARG
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == TYPE_ARG }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for TypeArgList {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        TYPE_ARG_LIST
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == TYPE_ARG_LIST }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for TypeParam {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        TYPE_PARAM
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == TYPE_PARAM }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for TypeParamList {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        TYPE_PARAM_LIST
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == TYPE_PARAM_LIST }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for UseAlias {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        USE_ALIAS
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == USE_ALIAS }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for UseGroup {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        USE_GROUP
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == USE_GROUP }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for UseItem {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        USE_ITEM
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == USE_ITEM }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for UseSpeck {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        USE_SPECK
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == USE_SPECK }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for ValueAddress {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        VALUE_ADDRESS
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == VALUE_ADDRESS }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Variant {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        VARIANT
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == VARIANT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for VariantList {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        VARIANT_LIST
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == VARIANT_LIST }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Visibility {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        VISIBILITY
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == VISIBILITY }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl From<NamedAddress> for AddressRef {
    #[inline]
    fn from(node: NamedAddress) -> AddressRef { AddressRef::NamedAddress(node) }
}
impl From<ValueAddress> for AddressRef {
    #[inline]
    fn from(node: ValueAddress) -> AddressRef { AddressRef::ValueAddress(node) }
}
impl AddressRef {
    pub fn named_address(self) -> Option<NamedAddress> {
        match (self) {
            AddressRef::NamedAddress(item) => Some(item),
            _ => None,
        }
    }
    pub fn value_address(self) -> Option<ValueAddress> {
        match (self) {
            AddressRef::ValueAddress(item) => Some(item),
            _ => None,
        }
    }
}
impl AstNode for AddressRef {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, NAMED_ADDRESS | VALUE_ADDRESS) }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            NAMED_ADDRESS => AddressRef::NamedAddress(NamedAddress { syntax }),
            VALUE_ADDRESS => AddressRef::ValueAddress(ValueAddress { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AddressRef::NamedAddress(it) => &it.syntax,
            AddressRef::ValueAddress(it) => &it.syntax,
        }
    }
}
impl From<Enum> for Adt {
    #[inline]
    fn from(node: Enum) -> Adt { Adt::Enum(node) }
}
impl From<Struct> for Adt {
    #[inline]
    fn from(node: Struct) -> Adt { Adt::Struct(node) }
}
impl Adt {
    pub fn enum_(self) -> Option<Enum> {
        match (self) {
            Adt::Enum(item) => Some(item),
            _ => None,
        }
    }
    pub fn struct_(self) -> Option<Struct> {
        match (self) {
            Adt::Struct(item) => Some(item),
            _ => None,
        }
    }
}
impl AstNode for Adt {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, ENUM | STRUCT) }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            ENUM => Adt::Enum(Enum { syntax }),
            STRUCT => Adt::Struct(Struct { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Adt::Enum(it) => &it.syntax,
            Adt::Struct(it) => &it.syntax,
        }
    }
}
impl From<BinExpr> for Expr {
    #[inline]
    fn from(node: BinExpr) -> Expr { Expr::BinExpr(node) }
}
impl From<Literal> for Expr {
    #[inline]
    fn from(node: Literal) -> Expr { Expr::Literal(node) }
}
impl From<ParenExpr> for Expr {
    #[inline]
    fn from(node: ParenExpr) -> Expr { Expr::ParenExpr(node) }
}
impl From<PathExpr> for Expr {
    #[inline]
    fn from(node: PathExpr) -> Expr { Expr::PathExpr(node) }
}
impl From<PrefixExpr> for Expr {
    #[inline]
    fn from(node: PrefixExpr) -> Expr { Expr::PrefixExpr(node) }
}
impl Expr {
    pub fn bin_expr(self) -> Option<BinExpr> {
        match (self) {
            Expr::BinExpr(item) => Some(item),
            _ => None,
        }
    }
    pub fn literal(self) -> Option<Literal> {
        match (self) {
            Expr::Literal(item) => Some(item),
            _ => None,
        }
    }
    pub fn paren_expr(self) -> Option<ParenExpr> {
        match (self) {
            Expr::ParenExpr(item) => Some(item),
            _ => None,
        }
    }
    pub fn path_expr(self) -> Option<PathExpr> {
        match (self) {
            Expr::PathExpr(item) => Some(item),
            _ => None,
        }
    }
    pub fn prefix_expr(self) -> Option<PrefixExpr> {
        match (self) {
            Expr::PrefixExpr(item) => Some(item),
            _ => None,
        }
    }
}
impl AstNode for Expr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, BIN_EXPR | LITERAL | PAREN_EXPR | PATH_EXPR | PREFIX_EXPR)
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            BIN_EXPR => Expr::BinExpr(BinExpr { syntax }),
            LITERAL => Expr::Literal(Literal { syntax }),
            PAREN_EXPR => Expr::ParenExpr(ParenExpr { syntax }),
            PATH_EXPR => Expr::PathExpr(PathExpr { syntax }),
            PREFIX_EXPR => Expr::PrefixExpr(PrefixExpr { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Expr::BinExpr(it) => &it.syntax,
            Expr::Literal(it) => &it.syntax,
            Expr::ParenExpr(it) => &it.syntax,
            Expr::PathExpr(it) => &it.syntax,
            Expr::PrefixExpr(it) => &it.syntax,
        }
    }
}
impl From<StructFieldList> for FieldList {
    #[inline]
    fn from(node: StructFieldList) -> FieldList { FieldList::StructFieldList(node) }
}
impl From<TupleFieldList> for FieldList {
    #[inline]
    fn from(node: TupleFieldList) -> FieldList { FieldList::TupleFieldList(node) }
}
impl FieldList {
    pub fn struct_field_list(self) -> Option<StructFieldList> {
        match (self) {
            FieldList::StructFieldList(item) => Some(item),
            _ => None,
        }
    }
    pub fn tuple_field_list(self) -> Option<TupleFieldList> {
        match (self) {
            FieldList::TupleFieldList(item) => Some(item),
            _ => None,
        }
    }
}
impl AstNode for FieldList {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, STRUCT_FIELD_LIST | TUPLE_FIELD_LIST) }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            STRUCT_FIELD_LIST => FieldList::StructFieldList(StructFieldList { syntax }),
            TUPLE_FIELD_LIST => FieldList::TupleFieldList(TupleFieldList { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            FieldList::StructFieldList(it) => &it.syntax,
            FieldList::TupleFieldList(it) => &it.syntax,
        }
    }
}
impl From<Const> for Item {
    #[inline]
    fn from(node: Const) -> Item { Item::Const(node) }
}
impl From<Enum> for Item {
    #[inline]
    fn from(node: Enum) -> Item { Item::Enum(node) }
}
impl From<Fun> for Item {
    #[inline]
    fn from(node: Fun) -> Item { Item::Fun(node) }
}
impl From<ItemSpec> for Item {
    #[inline]
    fn from(node: ItemSpec) -> Item { Item::ItemSpec(node) }
}
impl From<Schema> for Item {
    #[inline]
    fn from(node: Schema) -> Item { Item::Schema(node) }
}
impl From<SpecFun> for Item {
    #[inline]
    fn from(node: SpecFun) -> Item { Item::SpecFun(node) }
}
impl From<Struct> for Item {
    #[inline]
    fn from(node: Struct) -> Item { Item::Struct(node) }
}
impl From<UseItem> for Item {
    #[inline]
    fn from(node: UseItem) -> Item { Item::UseItem(node) }
}
impl Item {
    pub fn const_(self) -> Option<Const> {
        match (self) {
            Item::Const(item) => Some(item),
            _ => None,
        }
    }
    pub fn enum_(self) -> Option<Enum> {
        match (self) {
            Item::Enum(item) => Some(item),
            _ => None,
        }
    }
    pub fn fun(self) -> Option<Fun> {
        match (self) {
            Item::Fun(item) => Some(item),
            _ => None,
        }
    }
    pub fn item_spec(self) -> Option<ItemSpec> {
        match (self) {
            Item::ItemSpec(item) => Some(item),
            _ => None,
        }
    }
    pub fn schema(self) -> Option<Schema> {
        match (self) {
            Item::Schema(item) => Some(item),
            _ => None,
        }
    }
    pub fn spec_fun(self) -> Option<SpecFun> {
        match (self) {
            Item::SpecFun(item) => Some(item),
            _ => None,
        }
    }
    pub fn struct_(self) -> Option<Struct> {
        match (self) {
            Item::Struct(item) => Some(item),
            _ => None,
        }
    }
    pub fn use_item(self) -> Option<UseItem> {
        match (self) {
            Item::UseItem(item) => Some(item),
            _ => None,
        }
    }
}
impl AstNode for Item {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            CONST | ENUM | FUN | ITEM_SPEC | SCHEMA | SPEC_FUN | STRUCT | USE_ITEM
        )
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            CONST => Item::Const(Const { syntax }),
            ENUM => Item::Enum(Enum { syntax }),
            FUN => Item::Fun(Fun { syntax }),
            ITEM_SPEC => Item::ItemSpec(ItemSpec { syntax }),
            SCHEMA => Item::Schema(Schema { syntax }),
            SPEC_FUN => Item::SpecFun(SpecFun { syntax }),
            STRUCT => Item::Struct(Struct { syntax }),
            USE_ITEM => Item::UseItem(UseItem { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Item::Const(it) => &it.syntax,
            Item::Enum(it) => &it.syntax,
            Item::Fun(it) => &it.syntax,
            Item::ItemSpec(it) => &it.syntax,
            Item::Schema(it) => &it.syntax,
            Item::SpecFun(it) => &it.syntax,
            Item::Struct(it) => &it.syntax,
            Item::UseItem(it) => &it.syntax,
        }
    }
}
impl From<IdentPat> for Pat {
    #[inline]
    fn from(node: IdentPat) -> Pat { Pat::IdentPat(node) }
}
impl From<TuplePat> for Pat {
    #[inline]
    fn from(node: TuplePat) -> Pat { Pat::TuplePat(node) }
}
impl Pat {
    pub fn ident_pat(self) -> Option<IdentPat> {
        match (self) {
            Pat::IdentPat(item) => Some(item),
            _ => None,
        }
    }
    pub fn tuple_pat(self) -> Option<TuplePat> {
        match (self) {
            Pat::TuplePat(item) => Some(item),
            _ => None,
        }
    }
}
impl AstNode for Pat {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, IDENT_PAT | TUPLE_PAT) }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            IDENT_PAT => Pat::IdentPat(IdentPat { syntax }),
            TUPLE_PAT => Pat::TuplePat(TuplePat { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Pat::IdentPat(it) => &it.syntax,
            Pat::TuplePat(it) => &it.syntax,
        }
    }
}
impl From<ExprStmt> for Stmt {
    #[inline]
    fn from(node: ExprStmt) -> Stmt { Stmt::ExprStmt(node) }
}
impl From<LetStmt> for Stmt {
    #[inline]
    fn from(node: LetStmt) -> Stmt { Stmt::LetStmt(node) }
}
impl From<SchemaField> for Stmt {
    #[inline]
    fn from(node: SchemaField) -> Stmt { Stmt::SchemaField(node) }
}
impl From<SpecInlineFun> for Stmt {
    #[inline]
    fn from(node: SpecInlineFun) -> Stmt { Stmt::SpecInlineFun(node) }
}
impl Stmt {
    pub fn expr_stmt(self) -> Option<ExprStmt> {
        match (self) {
            Stmt::ExprStmt(item) => Some(item),
            _ => None,
        }
    }
    pub fn let_stmt(self) -> Option<LetStmt> {
        match (self) {
            Stmt::LetStmt(item) => Some(item),
            _ => None,
        }
    }
    pub fn schema_field(self) -> Option<SchemaField> {
        match (self) {
            Stmt::SchemaField(item) => Some(item),
            _ => None,
        }
    }
    pub fn spec_inline_fun(self) -> Option<SpecInlineFun> {
        match (self) {
            Stmt::SpecInlineFun(item) => Some(item),
            _ => None,
        }
    }
}
impl AstNode for Stmt {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, EXPR_STMT | LET_STMT | SCHEMA_FIELD | SPEC_INLINE_FUN)
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            EXPR_STMT => Stmt::ExprStmt(ExprStmt { syntax }),
            LET_STMT => Stmt::LetStmt(LetStmt { syntax }),
            SCHEMA_FIELD => Stmt::SchemaField(SchemaField { syntax }),
            SPEC_INLINE_FUN => Stmt::SpecInlineFun(SpecInlineFun { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Stmt::ExprStmt(it) => &it.syntax,
            Stmt::LetStmt(it) => &it.syntax,
            Stmt::SchemaField(it) => &it.syntax,
            Stmt::SpecInlineFun(it) => &it.syntax,
        }
    }
}
impl From<PathType> for Type {
    #[inline]
    fn from(node: PathType) -> Type { Type::PathType(node) }
}
impl From<RefType> for Type {
    #[inline]
    fn from(node: RefType) -> Type { Type::RefType(node) }
}
impl Type {
    pub fn path_type(self) -> Option<PathType> {
        match (self) {
            Type::PathType(item) => Some(item),
            _ => None,
        }
    }
    pub fn ref_type(self) -> Option<RefType> {
        match (self) {
            Type::RefType(item) => Some(item),
            _ => None,
        }
    }
}
impl AstNode for Type {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, PATH_TYPE | REF_TYPE) }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            PATH_TYPE => Type::PathType(PathType { syntax }),
            REF_TYPE => Type::RefType(RefType { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Type::PathType(it) => &it.syntax,
            Type::RefType(it) => &it.syntax,
        }
    }
}
impl AnyHasAttrs {
    #[inline]
    pub fn new<T: ast::HasAttrs>(node: T) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax().clone(),
        }
    }
}
impl AstNode for AnyHasAttrs {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            BIN_EXPR
                | CONST
                | ENUM
                | FUN
                | ITEM_SPEC
                | LITERAL
                | MODULE
                | MODULE_SPEC
                | SCHEMA
                | SCRIPT
                | SPEC_FUN
                | STRUCT
                | STRUCT_FIELD
                | TUPLE_FIELD
                | USE_ITEM
                | VARIANT
        )
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        Self::can_cast(syntax.kind()).then_some(AnyHasAttrs { syntax })
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl From<BinExpr> for AnyHasAttrs {
    #[inline]
    fn from(node: BinExpr) -> AnyHasAttrs { AnyHasAttrs { syntax: node.syntax } }
}
impl From<Const> for AnyHasAttrs {
    #[inline]
    fn from(node: Const) -> AnyHasAttrs { AnyHasAttrs { syntax: node.syntax } }
}
impl From<Enum> for AnyHasAttrs {
    #[inline]
    fn from(node: Enum) -> AnyHasAttrs { AnyHasAttrs { syntax: node.syntax } }
}
impl From<Fun> for AnyHasAttrs {
    #[inline]
    fn from(node: Fun) -> AnyHasAttrs { AnyHasAttrs { syntax: node.syntax } }
}
impl From<ItemSpec> for AnyHasAttrs {
    #[inline]
    fn from(node: ItemSpec) -> AnyHasAttrs { AnyHasAttrs { syntax: node.syntax } }
}
impl From<Literal> for AnyHasAttrs {
    #[inline]
    fn from(node: Literal) -> AnyHasAttrs { AnyHasAttrs { syntax: node.syntax } }
}
impl From<Module> for AnyHasAttrs {
    #[inline]
    fn from(node: Module) -> AnyHasAttrs { AnyHasAttrs { syntax: node.syntax } }
}
impl From<ModuleSpec> for AnyHasAttrs {
    #[inline]
    fn from(node: ModuleSpec) -> AnyHasAttrs { AnyHasAttrs { syntax: node.syntax } }
}
impl From<Schema> for AnyHasAttrs {
    #[inline]
    fn from(node: Schema) -> AnyHasAttrs { AnyHasAttrs { syntax: node.syntax } }
}
impl From<Script> for AnyHasAttrs {
    #[inline]
    fn from(node: Script) -> AnyHasAttrs { AnyHasAttrs { syntax: node.syntax } }
}
impl From<SpecFun> for AnyHasAttrs {
    #[inline]
    fn from(node: SpecFun) -> AnyHasAttrs { AnyHasAttrs { syntax: node.syntax } }
}
impl From<Struct> for AnyHasAttrs {
    #[inline]
    fn from(node: Struct) -> AnyHasAttrs { AnyHasAttrs { syntax: node.syntax } }
}
impl From<StructField> for AnyHasAttrs {
    #[inline]
    fn from(node: StructField) -> AnyHasAttrs { AnyHasAttrs { syntax: node.syntax } }
}
impl From<TupleField> for AnyHasAttrs {
    #[inline]
    fn from(node: TupleField) -> AnyHasAttrs { AnyHasAttrs { syntax: node.syntax } }
}
impl From<UseItem> for AnyHasAttrs {
    #[inline]
    fn from(node: UseItem) -> AnyHasAttrs { AnyHasAttrs { syntax: node.syntax } }
}
impl From<Variant> for AnyHasAttrs {
    #[inline]
    fn from(node: Variant) -> AnyHasAttrs { AnyHasAttrs { syntax: node.syntax } }
}
impl AnyHasItemList {
    #[inline]
    pub fn new<T: ast::HasItemList>(node: T) -> AnyHasItemList {
        AnyHasItemList {
            syntax: node.syntax().clone(),
        }
    }
}
impl AstNode for AnyHasItemList {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, MODULE | MODULE_SPEC | SCRIPT) }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        Self::can_cast(syntax.kind()).then_some(AnyHasItemList { syntax })
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl From<Module> for AnyHasItemList {
    #[inline]
    fn from(node: Module) -> AnyHasItemList { AnyHasItemList { syntax: node.syntax } }
}
impl From<ModuleSpec> for AnyHasItemList {
    #[inline]
    fn from(node: ModuleSpec) -> AnyHasItemList { AnyHasItemList { syntax: node.syntax } }
}
impl From<Script> for AnyHasItemList {
    #[inline]
    fn from(node: Script) -> AnyHasItemList { AnyHasItemList { syntax: node.syntax } }
}
impl AnyHasName {
    #[inline]
    pub fn new<T: ast::HasName>(node: T) -> AnyHasName {
        AnyHasName {
            syntax: node.syntax().clone(),
        }
    }
}
impl AstNode for AnyHasName {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            CONST
                | ENUM
                | FUN
                | IDENT_PAT
                | MODULE
                | SCHEMA
                | SPEC_FUN
                | SPEC_INLINE_FUN
                | STRUCT
                | STRUCT_FIELD
                | TYPE_PARAM
                | USE_ALIAS
                | VARIANT
        )
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        Self::can_cast(syntax.kind()).then_some(AnyHasName { syntax })
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl From<Const> for AnyHasName {
    #[inline]
    fn from(node: Const) -> AnyHasName { AnyHasName { syntax: node.syntax } }
}
impl From<Enum> for AnyHasName {
    #[inline]
    fn from(node: Enum) -> AnyHasName { AnyHasName { syntax: node.syntax } }
}
impl From<Fun> for AnyHasName {
    #[inline]
    fn from(node: Fun) -> AnyHasName { AnyHasName { syntax: node.syntax } }
}
impl From<IdentPat> for AnyHasName {
    #[inline]
    fn from(node: IdentPat) -> AnyHasName { AnyHasName { syntax: node.syntax } }
}
impl From<Module> for AnyHasName {
    #[inline]
    fn from(node: Module) -> AnyHasName { AnyHasName { syntax: node.syntax } }
}
impl From<Schema> for AnyHasName {
    #[inline]
    fn from(node: Schema) -> AnyHasName { AnyHasName { syntax: node.syntax } }
}
impl From<SpecFun> for AnyHasName {
    #[inline]
    fn from(node: SpecFun) -> AnyHasName { AnyHasName { syntax: node.syntax } }
}
impl From<SpecInlineFun> for AnyHasName {
    #[inline]
    fn from(node: SpecInlineFun) -> AnyHasName { AnyHasName { syntax: node.syntax } }
}
impl From<Struct> for AnyHasName {
    #[inline]
    fn from(node: Struct) -> AnyHasName { AnyHasName { syntax: node.syntax } }
}
impl From<StructField> for AnyHasName {
    #[inline]
    fn from(node: StructField) -> AnyHasName { AnyHasName { syntax: node.syntax } }
}
impl From<TypeParam> for AnyHasName {
    #[inline]
    fn from(node: TypeParam) -> AnyHasName { AnyHasName { syntax: node.syntax } }
}
impl From<UseAlias> for AnyHasName {
    #[inline]
    fn from(node: UseAlias) -> AnyHasName { AnyHasName { syntax: node.syntax } }
}
impl From<Variant> for AnyHasName {
    #[inline]
    fn from(node: Variant) -> AnyHasName { AnyHasName { syntax: node.syntax } }
}
impl AnyHasStmtList {
    #[inline]
    pub fn new<T: ast::HasStmtList>(node: T) -> AnyHasStmtList {
        AnyHasStmtList {
            syntax: node.syntax().clone(),
        }
    }
}
impl AstNode for AnyHasStmtList {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, BLOCK_EXPR) }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        Self::can_cast(syntax.kind()).then_some(AnyHasStmtList { syntax })
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl From<BlockExpr> for AnyHasStmtList {
    #[inline]
    fn from(node: BlockExpr) -> AnyHasStmtList { AnyHasStmtList { syntax: node.syntax } }
}
impl AnyHasTypeParams {
    #[inline]
    pub fn new<T: ast::HasTypeParams>(node: T) -> AnyHasTypeParams {
        AnyHasTypeParams {
            syntax: node.syntax().clone(),
        }
    }
}
impl AstNode for AnyHasTypeParams {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, ENUM | FUN | SCHEMA | SPEC_FUN | SPEC_INLINE_FUN | STRUCT)
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        Self::can_cast(syntax.kind()).then_some(AnyHasTypeParams { syntax })
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl From<Enum> for AnyHasTypeParams {
    #[inline]
    fn from(node: Enum) -> AnyHasTypeParams { AnyHasTypeParams { syntax: node.syntax } }
}
impl From<Fun> for AnyHasTypeParams {
    #[inline]
    fn from(node: Fun) -> AnyHasTypeParams { AnyHasTypeParams { syntax: node.syntax } }
}
impl From<Schema> for AnyHasTypeParams {
    #[inline]
    fn from(node: Schema) -> AnyHasTypeParams { AnyHasTypeParams { syntax: node.syntax } }
}
impl From<SpecFun> for AnyHasTypeParams {
    #[inline]
    fn from(node: SpecFun) -> AnyHasTypeParams { AnyHasTypeParams { syntax: node.syntax } }
}
impl From<SpecInlineFun> for AnyHasTypeParams {
    #[inline]
    fn from(node: SpecInlineFun) -> AnyHasTypeParams { AnyHasTypeParams { syntax: node.syntax } }
}
impl From<Struct> for AnyHasTypeParams {
    #[inline]
    fn from(node: Struct) -> AnyHasTypeParams { AnyHasTypeParams { syntax: node.syntax } }
}
impl std::fmt::Display for AddressRef {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Adt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Expr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for FieldList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Item {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Pat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Stmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Type {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Attr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AttrItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for BinExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for BlockExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Const {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Enum {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ExprStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Fun {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for IdentPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ItemList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ItemSpec {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for LetStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Literal {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Module {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ModuleSpec {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Name {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for NameRef {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for NamedAddress {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Param {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ParamList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ParenExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Path {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PathAddress {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PathExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PathSegment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PathType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for RefType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for RetType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Schema {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SchemaField {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Script {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SourceFile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SpecFun {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SpecInlineFun {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for StmtList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Struct {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for StructField {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for StructFieldList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TupleField {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TupleFieldList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TuplePat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TypeArg {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TypeArgList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TypeParam {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TypeParamList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for UseAlias {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for UseGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for UseItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for UseSpeck {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ValueAddress {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Variant {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for VariantList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Visibility {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
