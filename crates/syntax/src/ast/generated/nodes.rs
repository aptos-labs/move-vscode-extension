//! Generated by `cargo codegen`, do not edit by hand.

#![allow(non_snake_case)]
use crate::{
    ast::{self, support, AstChildren, AstNode},
    SyntaxKind::{self, *},
    SyntaxNode, SyntaxToken, T,
};

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Ability {
    pub(crate) syntax: SyntaxNode,
}
impl Ability {
    #[inline]
    pub fn ident_token(&self) -> SyntaxToken {
        support::token(&self.syntax, T![ident]).expect("Ability.ident_token required by the parser")
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AbilityList {
    pub(crate) syntax: SyntaxNode,
}
impl AbilityList {
    #[inline]
    pub fn abilities(&self) -> AstChildren<Ability> { support::children(&self.syntax) }
    #[inline]
    pub fn has_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![has]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AbortExpr {
    pub(crate) syntax: SyntaxNode,
}
impl AbortExpr {
    #[inline]
    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn abort_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![abort]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AbortsIfStmt {
    pub(crate) syntax: SyntaxNode,
}
impl AbortsIfStmt {
    #[inline]
    pub fn aborts_if_with(&self) -> Option<AbortsIfWith> { support::child(&self.syntax) }
    #[inline]
    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn spec_predicate_property_list(&self) -> Option<SpecPredicatePropertyList> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }
    #[inline]
    pub fn aborts_if_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![aborts_if]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AbortsIfWith {
    pub(crate) syntax: SyntaxNode,
}
impl AbortsIfWith {
    #[inline]
    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn with_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![with]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AddressDef {
    pub(crate) syntax: SyntaxNode,
}
impl AddressDef {
    #[inline]
    pub fn address_ref(&self) -> Option<AddressRef> { support::child(&self.syntax) }
    #[inline]
    pub fn modules(&self) -> AstChildren<Module> { support::children(&self.syntax) }
    #[inline]
    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }
    #[inline]
    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }
    #[inline]
    pub fn address_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![address]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AddressLit {
    pub(crate) syntax: SyntaxNode,
}
impl AddressLit {
    #[inline]
    pub fn named_address(&self) -> Option<NamedAddress> { support::child(&self.syntax) }
    #[inline]
    pub fn value_address(&self) -> Option<ValueAddress> { support::child(&self.syntax) }
    #[inline]
    pub fn at_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![@]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ArgList {
    pub(crate) syntax: SyntaxNode,
}
impl ArgList {
    #[inline]
    pub fn arg_exprs(&self) -> AstChildren<Expr> { support::children(&self.syntax) }
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AssertMacroExpr {
    pub(crate) syntax: SyntaxNode,
}
impl AssertMacroExpr {
    #[inline]
    pub fn arg_list(&self) -> Option<ArgList> { support::child(&self.syntax) }
    #[inline]
    pub fn excl_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![!]) }
    #[inline]
    pub fn ident_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![ident]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Attr {
    pub(crate) syntax: SyntaxNode,
}
impl Attr {
    #[inline]
    pub fn attr_item(&self) -> Option<AttrItem> { support::child(&self.syntax) }
    #[inline]
    pub fn excl_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![!]) }
    #[inline]
    pub fn pound_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![#]) }
    #[inline]
    pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['[']) }
    #[inline]
    pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AttrItem {
    pub(crate) syntax: SyntaxNode,
}
impl AttrItem {
    #[inline]
    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }
    #[inline]
    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BangExpr {
    pub(crate) syntax: SyntaxNode,
}
impl BangExpr {
    #[inline]
    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn excl_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![!]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BinExpr {
    pub(crate) syntax: SyntaxNode,
}
impl BinExpr {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BlockExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasStmts for BlockExpr {}
impl ast::HasUseStmts for BlockExpr {}
impl BlockExpr {
    #[inline]
    pub fn tail_expr(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }
    #[inline]
    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BorrowExpr {
    pub(crate) syntax: SyntaxNode,
}
impl BorrowExpr {
    #[inline]
    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn amp_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![&]) }
    #[inline]
    pub fn mut_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![mut]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BreakExpr {
    pub(crate) syntax: SyntaxNode,
}
impl BreakExpr {
    #[inline]
    pub fn label(&self) -> Option<Label> { support::child(&self.syntax) }
    #[inline]
    pub fn break_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![break]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CallExpr {
    pub(crate) syntax: SyntaxNode,
}
impl CallExpr {
    #[inline]
    pub fn arg_list(&self) -> Option<ArgList> { support::child(&self.syntax) }
    #[inline]
    pub fn path(&self) -> Path {
        support::child(&self.syntax).expect("CallExpr.path required by the parser")
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CastExpr {
    pub(crate) syntax: SyntaxNode,
}
impl CastExpr {
    #[inline]
    pub fn expr(&self) -> Expr {
        support::child(&self.syntax).expect("CastExpr.expr required by the parser")
    }
    #[inline]
    pub fn type_(&self) -> Option<Type> { support::child(&self.syntax) }
    #[inline]
    pub fn as_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![as]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ChooseExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ChooseExpr {
    #[inline]
    pub fn quant_binding_list(&self) -> Option<QuantBindingList> { support::child(&self.syntax) }
    #[inline]
    pub fn where_expr(&self) -> Option<WhereExpr> { support::child(&self.syntax) }
    #[inline]
    pub fn choose_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![choose]) }
    #[inline]
    pub fn min_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![min]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Condition {
    pub(crate) syntax: SyntaxNode,
}
impl Condition {
    #[inline]
    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Const {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for Const {}
impl ast::HasVisibility for Const {}
impl ast::HoverDocsOwner for Const {}
impl ast::NamedElement for Const {}
impl Const {
    #[inline]
    pub fn body(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn type_(&self) -> Option<Type> { support::child(&self.syntax) }
    #[inline]
    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }
    #[inline]
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }
    #[inline]
    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }
    #[inline]
    pub fn const_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![const]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ContinueExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ContinueExpr {
    #[inline]
    pub fn label(&self) -> Option<Label> { support::child(&self.syntax) }
    #[inline]
    pub fn continue_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![continue]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DerefExpr {
    pub(crate) syntax: SyntaxNode,
}
impl DerefExpr {
    #[inline]
    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn star_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![*]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DotExpr {
    pub(crate) syntax: SyntaxNode,
}
impl DotExpr {
    #[inline]
    pub fn field_ref(&self) -> FieldRef {
        support::child(&self.syntax).expect("DotExpr.field_ref required by the parser")
    }
    #[inline]
    pub fn receiver_expr(&self) -> Expr {
        support::child(&self.syntax).expect("DotExpr.receiver_expr required by the parser")
    }
    #[inline]
    pub fn dot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![.]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Enum {
    pub(crate) syntax: SyntaxNode,
}
impl ast::GenericElement for Enum {}
impl ast::HasAttrs for Enum {}
impl ast::HasVisibility for Enum {}
impl ast::HoverDocsOwner for Enum {}
impl ast::NamedElement for Enum {}
impl Enum {
    #[inline]
    pub fn ability_list(&self) -> Option<AbilityList> { support::child(&self.syntax) }
    #[inline]
    pub fn variant_list(&self) -> Option<VariantList> { support::child(&self.syntax) }
    #[inline]
    pub fn enum_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![enum]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ExistsExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ExistsExpr {
    #[inline]
    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn quant_binding_list(&self) -> Option<QuantBindingList> { support::child(&self.syntax) }
    #[inline]
    pub fn where_expr(&self) -> Option<WhereExpr> { support::child(&self.syntax) }
    #[inline]
    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }
    #[inline]
    pub fn exists_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![exists]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ExprStmt {
    pub(crate) syntax: SyntaxNode,
}
impl ExprStmt {
    #[inline]
    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FieldRef {
    pub(crate) syntax: SyntaxNode,
}
impl ast::ReferenceElement for FieldRef {}
impl FieldRef {
    #[inline]
    pub fn index_ref(&self) -> Option<IndexRef> { support::child(&self.syntax) }
    #[inline]
    pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ForCondition {
    pub(crate) syntax: SyntaxNode,
}
impl ForCondition {
    #[inline]
    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn ident_pat(&self) -> Option<IdentPat> { support::child(&self.syntax) }
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }
    #[inline]
    pub fn in_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![in]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ForExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ast::LoopLike for ForExpr {}
impl ForExpr {
    #[inline]
    pub fn for_condition(&self) -> Option<ForCondition> { support::child(&self.syntax) }
    #[inline]
    pub fn for_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![for]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ForallExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ForallExpr {
    #[inline]
    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn quant_binding_list(&self) -> Option<QuantBindingList> { support::child(&self.syntax) }
    #[inline]
    pub fn where_expr(&self) -> Option<WhereExpr> { support::child(&self.syntax) }
    #[inline]
    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }
    #[inline]
    pub fn forall_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![forall]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Friend {
    pub(crate) syntax: SyntaxNode,
}
impl Friend {
    #[inline]
    pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }
    #[inline]
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }
    #[inline]
    pub fn friend_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![friend]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Fun {
    pub(crate) syntax: SyntaxNode,
}
impl ast::GenericElement for Fun {}
impl ast::HasAttrs for Fun {}
impl ast::HasVisibility for Fun {}
impl ast::HoverDocsOwner for Fun {}
impl ast::NamedElement for Fun {}
impl Fun {
    #[inline]
    pub fn body(&self) -> Option<BlockExpr> { support::child(&self.syntax) }
    #[inline]
    pub fn param_list(&self) -> Option<ParamList> { support::child(&self.syntax) }
    #[inline]
    pub fn ret_type(&self) -> Option<RetType> { support::child(&self.syntax) }
    #[inline]
    pub fn visibility_modifier(&self) -> Option<VisibilityModifier> { support::child(&self.syntax) }
    #[inline]
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }
    #[inline]
    pub fn entry_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![entry]) }
    #[inline]
    pub fn fun_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![fun]) }
    #[inline]
    pub fn inline_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![inline]) }
    #[inline]
    pub fn native_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![native]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IdentPat {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HoverDocsOwner for IdentPat {}
impl ast::NamedElement for IdentPat {}
impl ast::ReferenceElement for IdentPat {}
impl IdentPat {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IfExpr {
    pub(crate) syntax: SyntaxNode,
}
impl IfExpr {
    #[inline]
    pub fn condition(&self) -> Option<Condition> { support::child(&self.syntax) }
    #[inline]
    pub fn else_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![else]) }
    #[inline]
    pub fn if_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![if]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IndexExpr {
    pub(crate) syntax: SyntaxNode,
}
impl IndexExpr {
    #[inline]
    pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['[']) }
    #[inline]
    pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IndexRef {
    pub(crate) syntax: SyntaxNode,
}
impl IndexRef {
    #[inline]
    pub fn int_number_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![int_number])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InlineExpr {
    pub(crate) syntax: SyntaxNode,
}
impl InlineExpr {
    #[inline]
    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IsExpr {
    pub(crate) syntax: SyntaxNode,
}
impl IsExpr {
    #[inline]
    pub fn expr(&self) -> Expr {
        support::child(&self.syntax).expect("IsExpr.expr required by the parser")
    }
    #[inline]
    pub fn types(&self) -> AstChildren<Type> { support::children(&self.syntax) }
    #[inline]
    pub fn is_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![is]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ItemSpec {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for ItemSpec {}
impl ast::MslOnly for ItemSpec {}
impl ItemSpec {
    #[inline]
    pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }
    #[inline]
    pub fn spec_block(&self) -> Option<BlockExpr> { support::child(&self.syntax) }
    #[inline]
    pub fn module_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![module]) }
    #[inline]
    pub fn spec_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![spec]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Label {
    pub(crate) syntax: SyntaxNode,
}
impl Label {
    #[inline]
    pub fn quote_ident_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![quote_ident])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LambdaExpr {
    pub(crate) syntax: SyntaxNode,
}
impl LambdaExpr {
    #[inline]
    pub fn body_expr(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn lambda_param_list(&self) -> Option<LambdaParamList> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LambdaParam {
    pub(crate) syntax: SyntaxNode,
}
impl LambdaParam {
    #[inline]
    pub fn ident_pat(&self) -> Option<IdentPat> { support::child(&self.syntax) }
    #[inline]
    pub fn type_(&self) -> Option<Type> { support::child(&self.syntax) }
    #[inline]
    pub fn wildcard_pat(&self) -> Option<WildcardPat> { support::child(&self.syntax) }
    #[inline]
    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LambdaParamList {
    pub(crate) syntax: SyntaxNode,
}
impl LambdaParamList {
    #[inline]
    pub fn lambda_params(&self) -> AstChildren<LambdaParam> { support::children(&self.syntax) }
    #[inline]
    pub fn pipe_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![|]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LambdaType {
    pub(crate) syntax: SyntaxNode,
}
impl LambdaType {
    #[inline]
    pub fn lambda_type_params(&self) -> AstChildren<LambdaTypeParam> { support::children(&self.syntax) }
    #[inline]
    pub fn return_type(&self) -> Option<Type> { support::child(&self.syntax) }
    #[inline]
    pub fn pipe_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![|]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LambdaTypeParam {
    pub(crate) syntax: SyntaxNode,
}
impl LambdaTypeParam {
    #[inline]
    pub fn type_(&self) -> Type {
        support::child(&self.syntax).expect("LambdaTypeParam.type_ required by the parser")
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LetStmt {
    pub(crate) syntax: SyntaxNode,
}
impl LetStmt {
    #[inline]
    pub fn initializer(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }
    #[inline]
    pub fn type_(&self) -> Option<Type> { support::child(&self.syntax) }
    #[inline]
    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }
    #[inline]
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }
    #[inline]
    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }
    #[inline]
    pub fn let_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![let]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Literal {
    pub(crate) syntax: SyntaxNode,
}
impl Literal {
    #[inline]
    pub fn address_lit(&self) -> Option<AddressLit> { support::child(&self.syntax) }
    #[inline]
    pub fn byte_string_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![byte_string])
    }
    #[inline]
    pub fn false_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![false]) }
    #[inline]
    pub fn hex_string_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![hex_string])
    }
    #[inline]
    pub fn int_number_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![int_number])
    }
    #[inline]
    pub fn true_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![true]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LoopExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ast::LoopLike for LoopExpr {}
impl LoopExpr {
    #[inline]
    pub fn loop_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![loop]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MatchArm {
    pub(crate) syntax: SyntaxNode,
}
impl MatchArm {
    #[inline]
    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn match_guard(&self) -> Option<MatchGuard> { support::child(&self.syntax) }
    #[inline]
    pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }
    #[inline]
    pub fn comma_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![,]) }
    #[inline]
    pub fn fat_arrow_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=>]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MatchArmList {
    pub(crate) syntax: SyntaxNode,
}
impl MatchArmList {
    #[inline]
    pub fn match_arms(&self) -> AstChildren<MatchArm> { support::children(&self.syntax) }
    #[inline]
    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }
    #[inline]
    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MatchExpr {
    pub(crate) syntax: SyntaxNode,
}
impl MatchExpr {
    #[inline]
    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn match_arm_list(&self) -> Option<MatchArmList> { support::child(&self.syntax) }
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }
    #[inline]
    pub fn match_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![match]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MatchGuard {
    pub(crate) syntax: SyntaxNode,
}
impl MatchGuard {
    #[inline]
    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn if_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![if]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MethodCallExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ast::ReferenceElement for MethodCallExpr {}
impl MethodCallExpr {
    #[inline]
    pub fn arg_list(&self) -> Option<ArgList> { support::child(&self.syntax) }
    #[inline]
    pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }
    #[inline]
    pub fn receiver_expr(&self) -> Expr {
        support::child(&self.syntax).expect("MethodCallExpr.receiver_expr required by the parser")
    }
    #[inline]
    pub fn type_arg_list(&self) -> Option<TypeArgList> { support::child(&self.syntax) }
    #[inline]
    pub fn dot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![.]) }
    #[inline]
    pub fn coloncolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![::]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Module {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for Module {}
impl ast::HasItems for Module {}
impl ast::HasUseStmts for Module {}
impl ast::HoverDocsOwner for Module {}
impl ast::NamedElement for Module {}
impl Module {
    #[inline]
    pub fn address_ref(&self) -> Option<AddressRef> { support::child(&self.syntax) }
    #[inline]
    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }
    #[inline]
    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }
    #[inline]
    pub fn coloncolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![::]) }
    #[inline]
    pub fn module_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![module]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ModuleSpec {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for ModuleSpec {}
impl ast::HasItems for ModuleSpec {}
impl ast::HasUseStmts for ModuleSpec {}
impl ast::MslOnly for ModuleSpec {}
impl ModuleSpec {
    #[inline]
    pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }
    #[inline]
    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }
    #[inline]
    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }
    #[inline]
    pub fn spec_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![spec]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Name {
    pub(crate) syntax: SyntaxNode,
}
impl Name {
    #[inline]
    pub fn ident_token(&self) -> SyntaxToken {
        support::token(&self.syntax, T![ident]).expect("Name.ident_token required by the parser")
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NameRef {
    pub(crate) syntax: SyntaxNode,
}
impl NameRef {
    #[inline]
    pub fn ident_token(&self) -> SyntaxToken {
        support::token(&self.syntax, T![ident]).expect("NameRef.ident_token required by the parser")
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NamedAddress {
    pub(crate) syntax: SyntaxNode,
}
impl NamedAddress {
    #[inline]
    pub fn ident_token(&self) -> SyntaxToken {
        support::token(&self.syntax, T![ident]).expect("NamedAddress.ident_token required by the parser")
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NamedField {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for NamedField {}
impl ast::HoverDocsOwner for NamedField {}
impl ast::NamedElement for NamedField {}
impl NamedField {
    #[inline]
    pub fn type_(&self) -> Option<Type> { support::child(&self.syntax) }
    #[inline]
    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NamedFieldList {
    pub(crate) syntax: SyntaxNode,
}
impl NamedFieldList {
    #[inline]
    pub fn fields(&self) -> AstChildren<NamedField> { support::children(&self.syntax) }
    #[inline]
    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }
    #[inline]
    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Param {
    pub(crate) syntax: SyntaxNode,
}
impl Param {
    #[inline]
    pub fn ident_pat(&self) -> Option<IdentPat> { support::child(&self.syntax) }
    #[inline]
    pub fn type_(&self) -> Option<Type> { support::child(&self.syntax) }
    #[inline]
    pub fn wildcard_pat(&self) -> Option<WildcardPat> { support::child(&self.syntax) }
    #[inline]
    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParamList {
    pub(crate) syntax: SyntaxNode,
}
impl ParamList {
    #[inline]
    pub fn params(&self) -> AstChildren<Param> { support::children(&self.syntax) }
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParenExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ParenExpr {
    #[inline]
    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParenType {
    pub(crate) syntax: SyntaxNode,
}
impl ParenType {
    #[inline]
    pub fn type_(&self) -> Type {
        support::child(&self.syntax).expect("ParenType.type_ required by the parser")
    }
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Path {
    pub(crate) syntax: SyntaxNode,
}
impl ast::ReferenceElement for Path {}
impl Path {
    #[inline]
    pub fn qualifier(&self) -> Option<Path> { support::child(&self.syntax) }
    #[inline]
    pub fn segment(&self) -> Option<PathSegment> { support::child(&self.syntax) }
    #[inline]
    pub fn coloncolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![::]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PathAddress {
    pub(crate) syntax: SyntaxNode,
}
impl PathAddress {
    #[inline]
    pub fn value_address(&self) -> ValueAddress {
        support::child(&self.syntax).expect("PathAddress.value_address required by the parser")
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PathExpr {
    pub(crate) syntax: SyntaxNode,
}
impl PathExpr {
    #[inline]
    pub fn path(&self) -> Path {
        support::child(&self.syntax).expect("PathExpr.path required by the parser")
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PathPat {
    pub(crate) syntax: SyntaxNode,
}
impl PathPat {
    #[inline]
    pub fn path(&self) -> Path {
        support::child(&self.syntax).expect("PathPat.path required by the parser")
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PathSegment {
    pub(crate) syntax: SyntaxNode,
}
impl PathSegment {
    #[inline]
    pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }
    #[inline]
    pub fn path_address(&self) -> Option<PathAddress> { support::child(&self.syntax) }
    #[inline]
    pub fn type_arg_list(&self) -> Option<TypeArgList> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PathType {
    pub(crate) syntax: SyntaxNode,
}
impl PathType {
    #[inline]
    pub fn path(&self) -> Path {
        support::child(&self.syntax).expect("PathType.path required by the parser")
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct QuantBinding {
    pub(crate) syntax: SyntaxNode,
}
impl QuantBinding {
    #[inline]
    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn ident_pat(&self) -> Option<IdentPat> { support::child(&self.syntax) }
    #[inline]
    pub fn type_(&self) -> Option<Type> { support::child(&self.syntax) }
    #[inline]
    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }
    #[inline]
    pub fn in_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![in]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct QuantBindingList {
    pub(crate) syntax: SyntaxNode,
}
impl QuantBindingList {
    #[inline]
    pub fn bindings(&self) -> AstChildren<QuantBinding> { support::children(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RangeExpr {
    pub(crate) syntax: SyntaxNode,
}
impl RangeExpr {
    #[inline]
    pub fn dotdot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![..]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RefType {
    pub(crate) syntax: SyntaxNode,
}
impl RefType {
    #[inline]
    pub fn type_(&self) -> Option<Type> { support::child(&self.syntax) }
    #[inline]
    pub fn amp_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![&]) }
    #[inline]
    pub fn mut_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![mut]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ResourceExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ResourceExpr {
    #[inline]
    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn copy_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![copy]) }
    #[inline]
    pub fn move_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![move]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RestPat {
    pub(crate) syntax: SyntaxNode,
}
impl RestPat {
    #[inline]
    pub fn dotdot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![..]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RetType {
    pub(crate) syntax: SyntaxNode,
}
impl RetType {
    #[inline]
    pub fn type_(&self) -> Option<Type> { support::child(&self.syntax) }
    #[inline]
    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ReturnExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ReturnExpr {
    #[inline]
    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn return_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![return]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Schema {
    pub(crate) syntax: SyntaxNode,
}
impl ast::GenericElement for Schema {}
impl ast::HasAttrs for Schema {}
impl ast::HoverDocsOwner for Schema {}
impl ast::MslOnly for Schema {}
impl ast::NamedElement for Schema {}
impl Schema {
    #[inline]
    pub fn spec_block(&self) -> Option<BlockExpr> { support::child(&self.syntax) }
    #[inline]
    pub fn schema_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![schema]) }
    #[inline]
    pub fn spec_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![spec]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SchemaFieldStmt {
    pub(crate) syntax: SyntaxNode,
}
impl SchemaFieldStmt {
    #[inline]
    pub fn ident_pat(&self) -> Option<IdentPat> { support::child(&self.syntax) }
    #[inline]
    pub fn type_(&self) -> Option<Type> { support::child(&self.syntax) }
    #[inline]
    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }
    #[inline]
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }
    #[inline]
    pub fn local_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![local]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Script {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for Script {}
impl ast::HasItems for Script {}
impl ast::HasUseStmts for Script {}
impl Script {
    #[inline]
    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }
    #[inline]
    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }
    #[inline]
    pub fn script_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![script]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SourceFile {
    pub(crate) syntax: SyntaxNode,
}
impl SourceFile {
    #[inline]
    pub fn address_defs(&self) -> AstChildren<AddressDef> { support::children(&self.syntax) }
    #[inline]
    pub fn module_specs(&self) -> AstChildren<ModuleSpec> { support::children(&self.syntax) }
    #[inline]
    pub fn modules(&self) -> AstChildren<Module> { support::children(&self.syntax) }
    #[inline]
    pub fn scripts(&self) -> AstChildren<Script> { support::children(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SpecFun {
    pub(crate) syntax: SyntaxNode,
}
impl ast::GenericElement for SpecFun {}
impl ast::HasAttrs for SpecFun {}
impl ast::HasVisibility for SpecFun {}
impl ast::HoverDocsOwner for SpecFun {}
impl ast::MslOnly for SpecFun {}
impl ast::NamedElement for SpecFun {}
impl SpecFun {
    #[inline]
    pub fn param_list(&self) -> Option<ParamList> { support::child(&self.syntax) }
    #[inline]
    pub fn ret_type(&self) -> Option<RetType> { support::child(&self.syntax) }
    #[inline]
    pub fn spec_block(&self) -> Option<BlockExpr> { support::child(&self.syntax) }
    #[inline]
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }
    #[inline]
    pub fn fun_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![fun]) }
    #[inline]
    pub fn native_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![native]) }
    #[inline]
    pub fn spec_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![spec]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SpecInlineFun {
    pub(crate) syntax: SyntaxNode,
}
impl ast::GenericElement for SpecInlineFun {}
impl ast::HasVisibility for SpecInlineFun {}
impl ast::HoverDocsOwner for SpecInlineFun {}
impl ast::MslOnly for SpecInlineFun {}
impl ast::NamedElement for SpecInlineFun {}
impl SpecInlineFun {
    #[inline]
    pub fn param_list(&self) -> Option<ParamList> { support::child(&self.syntax) }
    #[inline]
    pub fn ret_type(&self) -> Option<RetType> { support::child(&self.syntax) }
    #[inline]
    pub fn spec_block(&self) -> Option<BlockExpr> { support::child(&self.syntax) }
    #[inline]
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }
    #[inline]
    pub fn fun_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![fun]) }
    #[inline]
    pub fn native_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![native]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SpecPredicateProperty {
    pub(crate) syntax: SyntaxNode,
}
impl SpecPredicateProperty {
    #[inline]
    pub fn literal(&self) -> Option<Literal> { support::child(&self.syntax) }
    #[inline]
    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }
    #[inline]
    pub fn ident_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![ident]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SpecPredicatePropertyList {
    pub(crate) syntax: SyntaxNode,
}
impl SpecPredicatePropertyList {
    #[inline]
    pub fn properties(&self) -> AstChildren<SpecPredicateProperty> { support::children(&self.syntax) }
    #[inline]
    pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['[']) }
    #[inline]
    pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SpecPredicateStmt {
    pub(crate) syntax: SyntaxNode,
}
impl SpecPredicateStmt {
    #[inline]
    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn spec_predicate_property_list(&self) -> Option<SpecPredicatePropertyList> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }
    #[inline]
    pub fn assert_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![assert]) }
    #[inline]
    pub fn assume_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![assume]) }
    #[inline]
    pub fn decreases_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![decreases]) }
    #[inline]
    pub fn ensures_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![ensures]) }
    #[inline]
    pub fn modifies_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![modifies]) }
    #[inline]
    pub fn requires_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![requires]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Struct {
    pub(crate) syntax: SyntaxNode,
}
impl ast::FieldsOwner for Struct {}
impl ast::GenericElement for Struct {}
impl ast::HasAttrs for Struct {}
impl ast::HasVisibility for Struct {}
impl ast::HoverDocsOwner for Struct {}
impl ast::NamedElement for Struct {}
impl Struct {
    #[inline]
    pub fn ability_list(&self) -> Option<AbilityList> { support::child(&self.syntax) }
    #[inline]
    pub fn struct_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![struct]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StructLit {
    pub(crate) syntax: SyntaxNode,
}
impl StructLit {
    #[inline]
    pub fn path(&self) -> Path {
        support::child(&self.syntax).expect("StructLit.path required by the parser")
    }
    #[inline]
    pub fn struct_lit_field_list(&self) -> Option<StructLitFieldList> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StructLitField {
    pub(crate) syntax: SyntaxNode,
}
impl ast::ReferenceElement for StructLitField {}
impl StructLitField {
    #[inline]
    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }
    #[inline]
    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StructLitFieldList {
    pub(crate) syntax: SyntaxNode,
}
impl StructLitFieldList {
    #[inline]
    pub fn fields(&self) -> AstChildren<StructLitField> { support::children(&self.syntax) }
    #[inline]
    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }
    #[inline]
    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StructPat {
    pub(crate) syntax: SyntaxNode,
}
impl StructPat {
    #[inline]
    pub fn path(&self) -> Path {
        support::child(&self.syntax).expect("StructPat.path required by the parser")
    }
    #[inline]
    pub fn struct_pat_field_list(&self) -> Option<StructPatFieldList> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StructPatField {
    pub(crate) syntax: SyntaxNode,
}
impl ast::ReferenceElement for StructPatField {}
impl StructPatField {
    #[inline]
    pub fn ident_pat(&self) -> Option<IdentPat> { support::child(&self.syntax) }
    #[inline]
    pub fn name_ref(&self) -> Option<NameRef> { support::child(&self.syntax) }
    #[inline]
    pub fn pat(&self) -> Option<Pat> { support::child(&self.syntax) }
    #[inline]
    pub fn rest_pat(&self) -> Option<RestPat> { support::child(&self.syntax) }
    #[inline]
    pub fn wildcard_pat(&self) -> Option<WildcardPat> { support::child(&self.syntax) }
    #[inline]
    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StructPatFieldList {
    pub(crate) syntax: SyntaxNode,
}
impl StructPatFieldList {
    #[inline]
    pub fn fields(&self) -> AstChildren<StructPatField> { support::children(&self.syntax) }
    #[inline]
    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }
    #[inline]
    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TupleExpr {
    pub(crate) syntax: SyntaxNode,
}
impl TupleExpr {
    #[inline]
    pub fn exprs(&self) -> AstChildren<Expr> { support::children(&self.syntax) }
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TupleField {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for TupleField {}
impl TupleField {
    #[inline]
    pub fn type_(&self) -> Option<Type> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TupleFieldList {
    pub(crate) syntax: SyntaxNode,
}
impl TupleFieldList {
    #[inline]
    pub fn fields(&self) -> AstChildren<TupleField> { support::children(&self.syntax) }
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TuplePat {
    pub(crate) syntax: SyntaxNode,
}
impl TuplePat {
    #[inline]
    pub fn pats(&self) -> AstChildren<Pat> { support::children(&self.syntax) }
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TupleStructPat {
    pub(crate) syntax: SyntaxNode,
}
impl TupleStructPat {
    #[inline]
    pub fn fields(&self) -> AstChildren<Pat> { support::children(&self.syntax) }
    #[inline]
    pub fn path(&self) -> Path {
        support::child(&self.syntax).expect("TupleStructPat.path required by the parser")
    }
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TupleType {
    pub(crate) syntax: SyntaxNode,
}
impl TupleType {
    #[inline]
    pub fn types(&self) -> AstChildren<Type> { support::children(&self.syntax) }
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeArg {
    pub(crate) syntax: SyntaxNode,
}
impl TypeArg {
    #[inline]
    pub fn type_(&self) -> Type {
        support::child(&self.syntax).expect("TypeArg.type_ required by the parser")
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeArgList {
    pub(crate) syntax: SyntaxNode,
}
impl TypeArgList {
    #[inline]
    pub fn type_arguments(&self) -> AstChildren<TypeArg> { support::children(&self.syntax) }
    #[inline]
    pub fn l_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![<]) }
    #[inline]
    pub fn r_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![>]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeParam {
    pub(crate) syntax: SyntaxNode,
}
impl ast::NamedElement for TypeParam {}
impl TypeParam {
    #[inline]
    pub fn phantom_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![phantom]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeParamList {
    pub(crate) syntax: SyntaxNode,
}
impl TypeParamList {
    #[inline]
    pub fn type_parameters(&self) -> AstChildren<TypeParam> { support::children(&self.syntax) }
    #[inline]
    pub fn l_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![<]) }
    #[inline]
    pub fn r_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![>]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UnitType {
    pub(crate) syntax: SyntaxNode,
}
impl UnitType {
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UseAlias {
    pub(crate) syntax: SyntaxNode,
}
impl ast::NamedElement for UseAlias {}
impl UseAlias {
    #[inline]
    pub fn as_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![as]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UseGroup {
    pub(crate) syntax: SyntaxNode,
}
impl UseGroup {
    #[inline]
    pub fn use_specks(&self) -> AstChildren<UseSpeck> { support::children(&self.syntax) }
    #[inline]
    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }
    #[inline]
    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UseSpeck {
    pub(crate) syntax: SyntaxNode,
}
impl UseSpeck {
    #[inline]
    pub fn path(&self) -> Path {
        support::child(&self.syntax).expect("UseSpeck.path required by the parser")
    }
    #[inline]
    pub fn use_alias(&self) -> Option<UseAlias> { support::child(&self.syntax) }
    #[inline]
    pub fn use_group(&self) -> Option<UseGroup> { support::child(&self.syntax) }
    #[inline]
    pub fn coloncolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![::]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UseStmt {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for UseStmt {}
impl UseStmt {
    #[inline]
    pub fn use_speck(&self) -> Option<UseSpeck> { support::child(&self.syntax) }
    #[inline]
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }
    #[inline]
    pub fn use_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![use]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ValueAddress {
    pub(crate) syntax: SyntaxNode,
}
impl ValueAddress {
    #[inline]
    pub fn int_number_token(&self) -> SyntaxToken {
        support::token(&self.syntax, T![int_number])
            .expect("ValueAddress.int_number_token required by the parser")
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Variant {
    pub(crate) syntax: SyntaxNode,
}
impl ast::FieldsOwner for Variant {}
impl ast::HasAttrs for Variant {}
impl ast::HoverDocsOwner for Variant {}
impl ast::NamedElement for Variant {}
impl Variant {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct VariantList {
    pub(crate) syntax: SyntaxNode,
}
impl VariantList {
    #[inline]
    pub fn variants(&self) -> AstChildren<Variant> { support::children(&self.syntax) }
    #[inline]
    pub fn l_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['{']) }
    #[inline]
    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct VectorLitExpr {
    pub(crate) syntax: SyntaxNode,
}
impl VectorLitExpr {
    #[inline]
    pub fn arg_exprs(&self) -> AstChildren<Expr> { support::children(&self.syntax) }
    #[inline]
    pub fn type_arg_list(&self) -> Option<TypeArgList> { support::child(&self.syntax) }
    #[inline]
    pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['[']) }
    #[inline]
    pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }
    #[inline]
    pub fn ident_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![ident]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct VisibilityModifier {
    pub(crate) syntax: SyntaxNode,
}
impl VisibilityModifier {
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }
    #[inline]
    pub fn friend_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![friend]) }
    #[inline]
    pub fn package_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![package]) }
    #[inline]
    pub fn public_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![public]) }
    #[inline]
    pub fn script_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![script]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct WhereExpr {
    pub(crate) syntax: SyntaxNode,
}
impl WhereExpr {
    #[inline]
    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }
    #[inline]
    pub fn where_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![where]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct WhileExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ast::LoopLike for WhileExpr {}
impl WhileExpr {
    #[inline]
    pub fn condition(&self) -> Option<Condition> { support::child(&self.syntax) }
    #[inline]
    pub fn while_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![while]) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct WildcardPat {
    pub(crate) syntax: SyntaxNode,
}
impl WildcardPat {
    #[inline]
    pub fn underscore_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['_']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum AddressRef {
    NamedAddress(NamedAddress),
    ValueAddress(ValueAddress),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum AnyField {
    NamedField(NamedField),
    TupleField(TupleField),
}
impl ast::HasAttrs for AnyField {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum AnyFun {
    Fun(Fun),
    SpecFun(SpecFun),
    SpecInlineFun(SpecInlineFun),
}
impl ast::GenericElement for AnyFun {}
impl ast::HasVisibility for AnyFun {}
impl ast::HoverDocsOwner for AnyFun {}
impl ast::NamedElement for AnyFun {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum BlockOrInlineExpr {
    BlockExpr(BlockExpr),
    InlineExpr(InlineExpr),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Expr {
    AbortExpr(AbortExpr),
    AssertMacroExpr(AssertMacroExpr),
    BangExpr(BangExpr),
    BinExpr(BinExpr),
    BlockExpr(BlockExpr),
    BorrowExpr(BorrowExpr),
    BreakExpr(BreakExpr),
    CallExpr(CallExpr),
    CastExpr(CastExpr),
    ChooseExpr(ChooseExpr),
    ContinueExpr(ContinueExpr),
    DerefExpr(DerefExpr),
    DotExpr(DotExpr),
    ExistsExpr(ExistsExpr),
    ForExpr(ForExpr),
    ForallExpr(ForallExpr),
    IfExpr(IfExpr),
    IndexExpr(IndexExpr),
    IsExpr(IsExpr),
    LambdaExpr(LambdaExpr),
    Literal(Literal),
    LoopExpr(LoopExpr),
    MatchExpr(MatchExpr),
    MethodCallExpr(MethodCallExpr),
    ParenExpr(ParenExpr),
    PathExpr(PathExpr),
    RangeExpr(RangeExpr),
    ResourceExpr(ResourceExpr),
    ReturnExpr(ReturnExpr),
    StructLit(StructLit),
    TupleExpr(TupleExpr),
    VectorLitExpr(VectorLitExpr),
    WhileExpr(WhileExpr),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum FieldList {
    NamedFieldList(NamedFieldList),
    TupleFieldList(TupleFieldList),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum IdentPatKind {
    LetStmt(LetStmt),
    Param(Param),
    SchemaFieldStmt(SchemaFieldStmt),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum InferenceCtxOwner {
    Fun(Fun),
    ItemSpec(ItemSpec),
    Schema(Schema),
    SpecFun(SpecFun),
    SpecInlineFun(SpecInlineFun),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Item {
    Const(Const),
    Enum(Enum),
    Friend(Friend),
    Fun(Fun),
    ItemSpec(ItemSpec),
    Schema(Schema),
    SpecFun(SpecFun),
    Struct(Struct),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum MethodOrPath {
    MethodCallExpr(MethodCallExpr),
    Path(Path),
}
impl ast::ReferenceElement for MethodOrPath {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum NameLike {
    Name(Name),
    NameRef(NameRef),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Pat {
    IdentPat(IdentPat),
    PathPat(PathPat),
    RestPat(RestPat),
    StructPat(StructPat),
    TuplePat(TuplePat),
    TupleStructPat(TupleStructPat),
    WildcardPat(WildcardPat),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum QuantExpr {
    ChooseExpr(ChooseExpr),
    ExistsExpr(ExistsExpr),
    ForallExpr(ForallExpr),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Stmt {
    AbortsIfStmt(AbortsIfStmt),
    ExprStmt(ExprStmt),
    LetStmt(LetStmt),
    SchemaFieldStmt(SchemaFieldStmt),
    SpecInlineFun(SpecInlineFun),
    SpecPredicateStmt(SpecPredicateStmt),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum StructOrEnum {
    Enum(Enum),
    Struct(Struct),
}
impl ast::GenericElement for StructOrEnum {}
impl ast::HasAttrs for StructOrEnum {}
impl ast::HasVisibility for StructOrEnum {}
impl ast::HoverDocsOwner for StructOrEnum {}
impl ast::NamedElement for StructOrEnum {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Type {
    LambdaType(LambdaType),
    ParenType(ParenType),
    PathType(PathType),
    RefType(RefType),
    TupleType(TupleType),
    UnitType(UnitType),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AnyFieldsOwner {
    pub(crate) syntax: SyntaxNode,
}
impl ast::FieldsOwner for AnyFieldsOwner {}
impl ast::HasAttrs for AnyFieldsOwner {}
impl ast::HoverDocsOwner for AnyFieldsOwner {}
impl ast::NamedElement for AnyFieldsOwner {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AnyGenericElement {
    pub(crate) syntax: SyntaxNode,
}
impl ast::GenericElement for AnyGenericElement {}
impl ast::HoverDocsOwner for AnyGenericElement {}
impl ast::NamedElement for AnyGenericElement {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AnyHasAttrs {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasAttrs for AnyHasAttrs {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AnyHasItems {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasItems for AnyHasItems {}
impl ast::HasAttrs for AnyHasItems {}
impl ast::HasUseStmts for AnyHasItems {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AnyHasStmts {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasStmts for AnyHasStmts {}
impl ast::HasUseStmts for AnyHasStmts {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AnyHasUseStmts {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasUseStmts for AnyHasUseStmts {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AnyHasVisibility {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasVisibility for AnyHasVisibility {}
impl ast::HoverDocsOwner for AnyHasVisibility {}
impl ast::NamedElement for AnyHasVisibility {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AnyHoverDocsOwner {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HoverDocsOwner for AnyHoverDocsOwner {}
impl ast::NamedElement for AnyHoverDocsOwner {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AnyLoopLike {
    pub(crate) syntax: SyntaxNode,
}
impl ast::LoopLike for AnyLoopLike {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AnyMslOnly {
    pub(crate) syntax: SyntaxNode,
}
impl ast::MslOnly for AnyMslOnly {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AnyNamedElement {
    pub(crate) syntax: SyntaxNode,
}
impl ast::NamedElement for AnyNamedElement {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AnyReferenceElement {
    pub(crate) syntax: SyntaxNode,
}
impl ast::ReferenceElement for AnyReferenceElement {}
impl AstNode for Ability {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        ABILITY
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == ABILITY }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for AbilityList {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        ABILITY_LIST
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == ABILITY_LIST }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for AbortExpr {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        ABORT_EXPR
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == ABORT_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for AbortsIfStmt {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        ABORTS_IF_STMT
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == ABORTS_IF_STMT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for AbortsIfWith {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        ABORTS_IF_WITH
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == ABORTS_IF_WITH }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for AddressDef {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        ADDRESS_DEF
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == ADDRESS_DEF }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for AddressLit {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        ADDRESS_LIT
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == ADDRESS_LIT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for ArgList {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        ARG_LIST
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == ARG_LIST }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for AssertMacroExpr {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        ASSERT_MACRO_EXPR
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == ASSERT_MACRO_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Attr {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        ATTR
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == ATTR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for AttrItem {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        ATTR_ITEM
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == ATTR_ITEM }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for BangExpr {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        BANG_EXPR
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == BANG_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for BinExpr {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        BIN_EXPR
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == BIN_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for BlockExpr {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        BLOCK_EXPR
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == BLOCK_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for BorrowExpr {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        BORROW_EXPR
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == BORROW_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for BreakExpr {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        BREAK_EXPR
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == BREAK_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for CallExpr {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        CALL_EXPR
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == CALL_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for CastExpr {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        CAST_EXPR
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == CAST_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for ChooseExpr {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        CHOOSE_EXPR
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == CHOOSE_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Condition {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        CONDITION
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == CONDITION }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Const {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        CONST
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == CONST }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for ContinueExpr {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        CONTINUE_EXPR
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == CONTINUE_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for DerefExpr {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        DEREF_EXPR
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == DEREF_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for DotExpr {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        DOT_EXPR
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == DOT_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Enum {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        ENUM
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == ENUM }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for ExistsExpr {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        EXISTS_EXPR
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == EXISTS_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for ExprStmt {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        EXPR_STMT
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == EXPR_STMT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for FieldRef {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        FIELD_REF
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == FIELD_REF }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for ForCondition {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        FOR_CONDITION
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == FOR_CONDITION }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for ForExpr {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        FOR_EXPR
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == FOR_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for ForallExpr {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        FORALL_EXPR
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == FORALL_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Friend {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        FRIEND
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == FRIEND }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Fun {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        FUN
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == FUN }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for IdentPat {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        IDENT_PAT
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == IDENT_PAT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for IfExpr {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        IF_EXPR
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == IF_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for IndexExpr {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        INDEX_EXPR
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == INDEX_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for IndexRef {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        INDEX_REF
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == INDEX_REF }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for InlineExpr {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        INLINE_EXPR
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == INLINE_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for IsExpr {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        IS_EXPR
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == IS_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for ItemSpec {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        ITEM_SPEC
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == ITEM_SPEC }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Label {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        LABEL
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == LABEL }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for LambdaExpr {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        LAMBDA_EXPR
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == LAMBDA_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for LambdaParam {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        LAMBDA_PARAM
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == LAMBDA_PARAM }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for LambdaParamList {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        LAMBDA_PARAM_LIST
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == LAMBDA_PARAM_LIST }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for LambdaType {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        LAMBDA_TYPE
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == LAMBDA_TYPE }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for LambdaTypeParam {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        LAMBDA_TYPE_PARAM
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == LAMBDA_TYPE_PARAM }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for LetStmt {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        LET_STMT
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == LET_STMT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Literal {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        LITERAL
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == LITERAL }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for LoopExpr {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        LOOP_EXPR
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == LOOP_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for MatchArm {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        MATCH_ARM
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == MATCH_ARM }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for MatchArmList {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        MATCH_ARM_LIST
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == MATCH_ARM_LIST }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for MatchExpr {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        MATCH_EXPR
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == MATCH_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for MatchGuard {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        MATCH_GUARD
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == MATCH_GUARD }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for MethodCallExpr {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        METHOD_CALL_EXPR
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == METHOD_CALL_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Module {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        MODULE
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == MODULE }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for ModuleSpec {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        MODULE_SPEC
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == MODULE_SPEC }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Name {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        NAME
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == NAME }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for NameRef {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        NAME_REF
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == NAME_REF }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for NamedAddress {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        NAMED_ADDRESS
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == NAMED_ADDRESS }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for NamedField {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        NAMED_FIELD
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == NAMED_FIELD }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for NamedFieldList {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        NAMED_FIELD_LIST
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == NAMED_FIELD_LIST }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Param {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        PARAM
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == PARAM }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for ParamList {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        PARAM_LIST
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == PARAM_LIST }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for ParenExpr {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        PAREN_EXPR
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == PAREN_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for ParenType {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        PAREN_TYPE
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == PAREN_TYPE }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Path {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        PATH
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == PATH }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for PathAddress {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        PATH_ADDRESS
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == PATH_ADDRESS }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for PathExpr {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        PATH_EXPR
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == PATH_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for PathPat {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        PATH_PAT
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == PATH_PAT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for PathSegment {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        PATH_SEGMENT
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == PATH_SEGMENT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for PathType {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        PATH_TYPE
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == PATH_TYPE }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for QuantBinding {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        QUANT_BINDING
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == QUANT_BINDING }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for QuantBindingList {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        QUANT_BINDING_LIST
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == QUANT_BINDING_LIST }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for RangeExpr {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        RANGE_EXPR
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == RANGE_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for RefType {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        REF_TYPE
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == REF_TYPE }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for ResourceExpr {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        RESOURCE_EXPR
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == RESOURCE_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for RestPat {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        REST_PAT
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == REST_PAT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for RetType {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        RET_TYPE
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == RET_TYPE }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for ReturnExpr {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        RETURN_EXPR
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == RETURN_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Schema {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        SCHEMA
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == SCHEMA }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for SchemaFieldStmt {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        SCHEMA_FIELD_STMT
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == SCHEMA_FIELD_STMT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Script {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        SCRIPT
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == SCRIPT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for SourceFile {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        SOURCE_FILE
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == SOURCE_FILE }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for SpecFun {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        SPEC_FUN
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == SPEC_FUN }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for SpecInlineFun {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        SPEC_INLINE_FUN
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == SPEC_INLINE_FUN }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for SpecPredicateProperty {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        SPEC_PREDICATE_PROPERTY
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == SPEC_PREDICATE_PROPERTY }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for SpecPredicatePropertyList {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        SPEC_PREDICATE_PROPERTY_LIST
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == SPEC_PREDICATE_PROPERTY_LIST }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for SpecPredicateStmt {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        SPEC_PREDICATE_STMT
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == SPEC_PREDICATE_STMT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Struct {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        STRUCT
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == STRUCT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for StructLit {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        STRUCT_LIT
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == STRUCT_LIT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for StructLitField {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        STRUCT_LIT_FIELD
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == STRUCT_LIT_FIELD }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for StructLitFieldList {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        STRUCT_LIT_FIELD_LIST
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == STRUCT_LIT_FIELD_LIST }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for StructPat {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        STRUCT_PAT
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == STRUCT_PAT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for StructPatField {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        STRUCT_PAT_FIELD
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == STRUCT_PAT_FIELD }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for StructPatFieldList {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        STRUCT_PAT_FIELD_LIST
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == STRUCT_PAT_FIELD_LIST }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for TupleExpr {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        TUPLE_EXPR
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == TUPLE_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for TupleField {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        TUPLE_FIELD
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == TUPLE_FIELD }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for TupleFieldList {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        TUPLE_FIELD_LIST
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == TUPLE_FIELD_LIST }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for TuplePat {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        TUPLE_PAT
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == TUPLE_PAT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for TupleStructPat {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        TUPLE_STRUCT_PAT
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == TUPLE_STRUCT_PAT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for TupleType {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        TUPLE_TYPE
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == TUPLE_TYPE }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for TypeArg {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        TYPE_ARG
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == TYPE_ARG }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for TypeArgList {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        TYPE_ARG_LIST
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == TYPE_ARG_LIST }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for TypeParam {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        TYPE_PARAM
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == TYPE_PARAM }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for TypeParamList {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        TYPE_PARAM_LIST
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == TYPE_PARAM_LIST }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for UnitType {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        UNIT_TYPE
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == UNIT_TYPE }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for UseAlias {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        USE_ALIAS
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == USE_ALIAS }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for UseGroup {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        USE_GROUP
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == USE_GROUP }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for UseSpeck {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        USE_SPECK
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == USE_SPECK }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for UseStmt {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        USE_STMT
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == USE_STMT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for ValueAddress {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        VALUE_ADDRESS
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == VALUE_ADDRESS }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Variant {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        VARIANT
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == VARIANT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for VariantList {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        VARIANT_LIST
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == VARIANT_LIST }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for VectorLitExpr {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        VECTOR_LIT_EXPR
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == VECTOR_LIT_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for VisibilityModifier {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        VISIBILITY_MODIFIER
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == VISIBILITY_MODIFIER }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for WhereExpr {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        WHERE_EXPR
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == WHERE_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for WhileExpr {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        WHILE_EXPR
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == WHILE_EXPR }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for WildcardPat {
    #[inline]
    fn kind() -> SyntaxKind
    where
        Self: Sized,
    {
        WILDCARD_PAT
    }
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { kind == WILDCARD_PAT }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl From<NamedAddress> for AddressRef {
    #[inline]
    fn from(node: NamedAddress) -> AddressRef { AddressRef::NamedAddress(node) }
}
impl From<ValueAddress> for AddressRef {
    #[inline]
    fn from(node: ValueAddress) -> AddressRef { AddressRef::ValueAddress(node) }
}
impl AddressRef {
    pub fn named_address(self) -> Option<NamedAddress> {
        match (self) {
            AddressRef::NamedAddress(item) => Some(item),
            _ => None,
        }
    }
    pub fn value_address(self) -> Option<ValueAddress> {
        match (self) {
            AddressRef::ValueAddress(item) => Some(item),
            _ => None,
        }
    }
}
impl AstNode for AddressRef {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, NAMED_ADDRESS | VALUE_ADDRESS) }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            NAMED_ADDRESS => AddressRef::NamedAddress(NamedAddress { syntax }),
            VALUE_ADDRESS => AddressRef::ValueAddress(ValueAddress { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AddressRef::NamedAddress(it) => &it.syntax,
            AddressRef::ValueAddress(it) => &it.syntax,
        }
    }
}
impl From<NamedField> for AnyField {
    #[inline]
    fn from(node: NamedField) -> AnyField { AnyField::NamedField(node) }
}
impl From<TupleField> for AnyField {
    #[inline]
    fn from(node: TupleField) -> AnyField { AnyField::TupleField(node) }
}
impl From<AnyField> for AnyHasAttrs {
    #[inline]
    fn from(node: AnyField) -> AnyHasAttrs {
        match node {
            AnyField::NamedField(it) => it.into(),
            AnyField::TupleField(it) => it.into(),
        }
    }
}
impl AnyField {
    pub fn named_field(self) -> Option<NamedField> {
        match (self) {
            AnyField::NamedField(item) => Some(item),
            _ => None,
        }
    }
    pub fn tuple_field(self) -> Option<TupleField> {
        match (self) {
            AnyField::TupleField(item) => Some(item),
            _ => None,
        }
    }
    #[inline]
    pub fn type_(&self) -> Option<Type> {
        match self {
            AnyField::NamedField(it) => it.type_(),
            AnyField::TupleField(it) => it.type_(),
        }
    }
}
impl AstNode for AnyField {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, NAMED_FIELD | TUPLE_FIELD) }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            NAMED_FIELD => AnyField::NamedField(NamedField { syntax }),
            TUPLE_FIELD => AnyField::TupleField(TupleField { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyField::NamedField(it) => &it.syntax,
            AnyField::TupleField(it) => &it.syntax,
        }
    }
}
impl From<Fun> for AnyFun {
    #[inline]
    fn from(node: Fun) -> AnyFun { AnyFun::Fun(node) }
}
impl From<SpecFun> for AnyFun {
    #[inline]
    fn from(node: SpecFun) -> AnyFun { AnyFun::SpecFun(node) }
}
impl From<SpecInlineFun> for AnyFun {
    #[inline]
    fn from(node: SpecInlineFun) -> AnyFun { AnyFun::SpecInlineFun(node) }
}
impl From<AnyFun> for AnyGenericElement {
    #[inline]
    fn from(node: AnyFun) -> AnyGenericElement {
        match node {
            AnyFun::Fun(it) => it.into(),
            AnyFun::SpecFun(it) => it.into(),
            AnyFun::SpecInlineFun(it) => it.into(),
        }
    }
}
impl From<AnyFun> for AnyHasVisibility {
    #[inline]
    fn from(node: AnyFun) -> AnyHasVisibility {
        match node {
            AnyFun::Fun(it) => it.into(),
            AnyFun::SpecFun(it) => it.into(),
            AnyFun::SpecInlineFun(it) => it.into(),
        }
    }
}
impl From<AnyFun> for AnyHoverDocsOwner {
    #[inline]
    fn from(node: AnyFun) -> AnyHoverDocsOwner {
        match node {
            AnyFun::Fun(it) => it.into(),
            AnyFun::SpecFun(it) => it.into(),
            AnyFun::SpecInlineFun(it) => it.into(),
        }
    }
}
impl From<AnyFun> for AnyNamedElement {
    #[inline]
    fn from(node: AnyFun) -> AnyNamedElement {
        match node {
            AnyFun::Fun(it) => it.into(),
            AnyFun::SpecFun(it) => it.into(),
            AnyFun::SpecInlineFun(it) => it.into(),
        }
    }
}
impl AnyFun {
    pub fn fun(self) -> Option<Fun> {
        match (self) {
            AnyFun::Fun(item) => Some(item),
            _ => None,
        }
    }
    pub fn spec_fun(self) -> Option<SpecFun> {
        match (self) {
            AnyFun::SpecFun(item) => Some(item),
            _ => None,
        }
    }
    pub fn spec_inline_fun(self) -> Option<SpecInlineFun> {
        match (self) {
            AnyFun::SpecInlineFun(item) => Some(item),
            _ => None,
        }
    }
    #[inline]
    pub fn type_param_list(&self) -> Option<TypeParamList> {
        match self {
            AnyFun::Fun(it) => ast::GenericElement::type_param_list(it),
            AnyFun::SpecFun(it) => ast::GenericElement::type_param_list(it),
            AnyFun::SpecInlineFun(it) => ast::GenericElement::type_param_list(it),
        }
    }
    #[inline]
    pub fn param_list(&self) -> Option<ParamList> {
        match self {
            AnyFun::Fun(it) => it.param_list(),
            AnyFun::SpecFun(it) => it.param_list(),
            AnyFun::SpecInlineFun(it) => it.param_list(),
        }
    }
    #[inline]
    pub fn ret_type(&self) -> Option<RetType> {
        match self {
            AnyFun::Fun(it) => it.ret_type(),
            AnyFun::SpecFun(it) => it.ret_type(),
            AnyFun::SpecInlineFun(it) => it.ret_type(),
        }
    }
}
impl AstNode for AnyFun {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, FUN | SPEC_FUN | SPEC_INLINE_FUN) }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            FUN => AnyFun::Fun(Fun { syntax }),
            SPEC_FUN => AnyFun::SpecFun(SpecFun { syntax }),
            SPEC_INLINE_FUN => AnyFun::SpecInlineFun(SpecInlineFun { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AnyFun::Fun(it) => &it.syntax,
            AnyFun::SpecFun(it) => &it.syntax,
            AnyFun::SpecInlineFun(it) => &it.syntax,
        }
    }
}
impl From<BlockExpr> for BlockOrInlineExpr {
    #[inline]
    fn from(node: BlockExpr) -> BlockOrInlineExpr { BlockOrInlineExpr::BlockExpr(node) }
}
impl From<InlineExpr> for BlockOrInlineExpr {
    #[inline]
    fn from(node: InlineExpr) -> BlockOrInlineExpr { BlockOrInlineExpr::InlineExpr(node) }
}
impl BlockOrInlineExpr {
    pub fn block_expr(self) -> Option<BlockExpr> {
        match (self) {
            BlockOrInlineExpr::BlockExpr(item) => Some(item),
            _ => None,
        }
    }
    pub fn inline_expr(self) -> Option<InlineExpr> {
        match (self) {
            BlockOrInlineExpr::InlineExpr(item) => Some(item),
            _ => None,
        }
    }
}
impl AstNode for BlockOrInlineExpr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, BLOCK_EXPR | INLINE_EXPR) }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            BLOCK_EXPR => BlockOrInlineExpr::BlockExpr(BlockExpr { syntax }),
            INLINE_EXPR => BlockOrInlineExpr::InlineExpr(InlineExpr { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            BlockOrInlineExpr::BlockExpr(it) => &it.syntax,
            BlockOrInlineExpr::InlineExpr(it) => &it.syntax,
        }
    }
}
impl From<AbortExpr> for Expr {
    #[inline]
    fn from(node: AbortExpr) -> Expr { Expr::AbortExpr(node) }
}
impl From<AssertMacroExpr> for Expr {
    #[inline]
    fn from(node: AssertMacroExpr) -> Expr { Expr::AssertMacroExpr(node) }
}
impl From<BangExpr> for Expr {
    #[inline]
    fn from(node: BangExpr) -> Expr { Expr::BangExpr(node) }
}
impl From<BinExpr> for Expr {
    #[inline]
    fn from(node: BinExpr) -> Expr { Expr::BinExpr(node) }
}
impl From<BlockExpr> for Expr {
    #[inline]
    fn from(node: BlockExpr) -> Expr { Expr::BlockExpr(node) }
}
impl From<BorrowExpr> for Expr {
    #[inline]
    fn from(node: BorrowExpr) -> Expr { Expr::BorrowExpr(node) }
}
impl From<BreakExpr> for Expr {
    #[inline]
    fn from(node: BreakExpr) -> Expr { Expr::BreakExpr(node) }
}
impl From<CallExpr> for Expr {
    #[inline]
    fn from(node: CallExpr) -> Expr { Expr::CallExpr(node) }
}
impl From<CastExpr> for Expr {
    #[inline]
    fn from(node: CastExpr) -> Expr { Expr::CastExpr(node) }
}
impl From<ChooseExpr> for Expr {
    #[inline]
    fn from(node: ChooseExpr) -> Expr { Expr::ChooseExpr(node) }
}
impl From<ContinueExpr> for Expr {
    #[inline]
    fn from(node: ContinueExpr) -> Expr { Expr::ContinueExpr(node) }
}
impl From<DerefExpr> for Expr {
    #[inline]
    fn from(node: DerefExpr) -> Expr { Expr::DerefExpr(node) }
}
impl From<DotExpr> for Expr {
    #[inline]
    fn from(node: DotExpr) -> Expr { Expr::DotExpr(node) }
}
impl From<ExistsExpr> for Expr {
    #[inline]
    fn from(node: ExistsExpr) -> Expr { Expr::ExistsExpr(node) }
}
impl From<ForExpr> for Expr {
    #[inline]
    fn from(node: ForExpr) -> Expr { Expr::ForExpr(node) }
}
impl From<ForallExpr> for Expr {
    #[inline]
    fn from(node: ForallExpr) -> Expr { Expr::ForallExpr(node) }
}
impl From<IfExpr> for Expr {
    #[inline]
    fn from(node: IfExpr) -> Expr { Expr::IfExpr(node) }
}
impl From<IndexExpr> for Expr {
    #[inline]
    fn from(node: IndexExpr) -> Expr { Expr::IndexExpr(node) }
}
impl From<IsExpr> for Expr {
    #[inline]
    fn from(node: IsExpr) -> Expr { Expr::IsExpr(node) }
}
impl From<LambdaExpr> for Expr {
    #[inline]
    fn from(node: LambdaExpr) -> Expr { Expr::LambdaExpr(node) }
}
impl From<Literal> for Expr {
    #[inline]
    fn from(node: Literal) -> Expr { Expr::Literal(node) }
}
impl From<LoopExpr> for Expr {
    #[inline]
    fn from(node: LoopExpr) -> Expr { Expr::LoopExpr(node) }
}
impl From<MatchExpr> for Expr {
    #[inline]
    fn from(node: MatchExpr) -> Expr { Expr::MatchExpr(node) }
}
impl From<MethodCallExpr> for Expr {
    #[inline]
    fn from(node: MethodCallExpr) -> Expr { Expr::MethodCallExpr(node) }
}
impl From<ParenExpr> for Expr {
    #[inline]
    fn from(node: ParenExpr) -> Expr { Expr::ParenExpr(node) }
}
impl From<PathExpr> for Expr {
    #[inline]
    fn from(node: PathExpr) -> Expr { Expr::PathExpr(node) }
}
impl From<RangeExpr> for Expr {
    #[inline]
    fn from(node: RangeExpr) -> Expr { Expr::RangeExpr(node) }
}
impl From<ResourceExpr> for Expr {
    #[inline]
    fn from(node: ResourceExpr) -> Expr { Expr::ResourceExpr(node) }
}
impl From<ReturnExpr> for Expr {
    #[inline]
    fn from(node: ReturnExpr) -> Expr { Expr::ReturnExpr(node) }
}
impl From<StructLit> for Expr {
    #[inline]
    fn from(node: StructLit) -> Expr { Expr::StructLit(node) }
}
impl From<TupleExpr> for Expr {
    #[inline]
    fn from(node: TupleExpr) -> Expr { Expr::TupleExpr(node) }
}
impl From<VectorLitExpr> for Expr {
    #[inline]
    fn from(node: VectorLitExpr) -> Expr { Expr::VectorLitExpr(node) }
}
impl From<WhileExpr> for Expr {
    #[inline]
    fn from(node: WhileExpr) -> Expr { Expr::WhileExpr(node) }
}
impl Expr {
    pub fn abort_expr(self) -> Option<AbortExpr> {
        match (self) {
            Expr::AbortExpr(item) => Some(item),
            _ => None,
        }
    }
    pub fn assert_macro_expr(self) -> Option<AssertMacroExpr> {
        match (self) {
            Expr::AssertMacroExpr(item) => Some(item),
            _ => None,
        }
    }
    pub fn bang_expr(self) -> Option<BangExpr> {
        match (self) {
            Expr::BangExpr(item) => Some(item),
            _ => None,
        }
    }
    pub fn bin_expr(self) -> Option<BinExpr> {
        match (self) {
            Expr::BinExpr(item) => Some(item),
            _ => None,
        }
    }
    pub fn block_expr(self) -> Option<BlockExpr> {
        match (self) {
            Expr::BlockExpr(item) => Some(item),
            _ => None,
        }
    }
    pub fn borrow_expr(self) -> Option<BorrowExpr> {
        match (self) {
            Expr::BorrowExpr(item) => Some(item),
            _ => None,
        }
    }
    pub fn break_expr(self) -> Option<BreakExpr> {
        match (self) {
            Expr::BreakExpr(item) => Some(item),
            _ => None,
        }
    }
    pub fn call_expr(self) -> Option<CallExpr> {
        match (self) {
            Expr::CallExpr(item) => Some(item),
            _ => None,
        }
    }
    pub fn cast_expr(self) -> Option<CastExpr> {
        match (self) {
            Expr::CastExpr(item) => Some(item),
            _ => None,
        }
    }
    pub fn choose_expr(self) -> Option<ChooseExpr> {
        match (self) {
            Expr::ChooseExpr(item) => Some(item),
            _ => None,
        }
    }
    pub fn continue_expr(self) -> Option<ContinueExpr> {
        match (self) {
            Expr::ContinueExpr(item) => Some(item),
            _ => None,
        }
    }
    pub fn deref_expr(self) -> Option<DerefExpr> {
        match (self) {
            Expr::DerefExpr(item) => Some(item),
            _ => None,
        }
    }
    pub fn dot_expr(self) -> Option<DotExpr> {
        match (self) {
            Expr::DotExpr(item) => Some(item),
            _ => None,
        }
    }
    pub fn exists_expr(self) -> Option<ExistsExpr> {
        match (self) {
            Expr::ExistsExpr(item) => Some(item),
            _ => None,
        }
    }
    pub fn for_expr(self) -> Option<ForExpr> {
        match (self) {
            Expr::ForExpr(item) => Some(item),
            _ => None,
        }
    }
    pub fn forall_expr(self) -> Option<ForallExpr> {
        match (self) {
            Expr::ForallExpr(item) => Some(item),
            _ => None,
        }
    }
    pub fn if_expr(self) -> Option<IfExpr> {
        match (self) {
            Expr::IfExpr(item) => Some(item),
            _ => None,
        }
    }
    pub fn index_expr(self) -> Option<IndexExpr> {
        match (self) {
            Expr::IndexExpr(item) => Some(item),
            _ => None,
        }
    }
    pub fn is_expr(self) -> Option<IsExpr> {
        match (self) {
            Expr::IsExpr(item) => Some(item),
            _ => None,
        }
    }
    pub fn lambda_expr(self) -> Option<LambdaExpr> {
        match (self) {
            Expr::LambdaExpr(item) => Some(item),
            _ => None,
        }
    }
    pub fn literal(self) -> Option<Literal> {
        match (self) {
            Expr::Literal(item) => Some(item),
            _ => None,
        }
    }
    pub fn loop_expr(self) -> Option<LoopExpr> {
        match (self) {
            Expr::LoopExpr(item) => Some(item),
            _ => None,
        }
    }
    pub fn match_expr(self) -> Option<MatchExpr> {
        match (self) {
            Expr::MatchExpr(item) => Some(item),
            _ => None,
        }
    }
    pub fn method_call_expr(self) -> Option<MethodCallExpr> {
        match (self) {
            Expr::MethodCallExpr(item) => Some(item),
            _ => None,
        }
    }
    pub fn paren_expr(self) -> Option<ParenExpr> {
        match (self) {
            Expr::ParenExpr(item) => Some(item),
            _ => None,
        }
    }
    pub fn path_expr(self) -> Option<PathExpr> {
        match (self) {
            Expr::PathExpr(item) => Some(item),
            _ => None,
        }
    }
    pub fn range_expr(self) -> Option<RangeExpr> {
        match (self) {
            Expr::RangeExpr(item) => Some(item),
            _ => None,
        }
    }
    pub fn resource_expr(self) -> Option<ResourceExpr> {
        match (self) {
            Expr::ResourceExpr(item) => Some(item),
            _ => None,
        }
    }
    pub fn return_expr(self) -> Option<ReturnExpr> {
        match (self) {
            Expr::ReturnExpr(item) => Some(item),
            _ => None,
        }
    }
    pub fn struct_lit(self) -> Option<StructLit> {
        match (self) {
            Expr::StructLit(item) => Some(item),
            _ => None,
        }
    }
    pub fn tuple_expr(self) -> Option<TupleExpr> {
        match (self) {
            Expr::TupleExpr(item) => Some(item),
            _ => None,
        }
    }
    pub fn vector_lit_expr(self) -> Option<VectorLitExpr> {
        match (self) {
            Expr::VectorLitExpr(item) => Some(item),
            _ => None,
        }
    }
    pub fn while_expr(self) -> Option<WhileExpr> {
        match (self) {
            Expr::WhileExpr(item) => Some(item),
            _ => None,
        }
    }
}
impl AstNode for Expr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            ABORT_EXPR
                | ASSERT_MACRO_EXPR
                | BANG_EXPR
                | BIN_EXPR
                | BLOCK_EXPR
                | BORROW_EXPR
                | BREAK_EXPR
                | CALL_EXPR
                | CAST_EXPR
                | CHOOSE_EXPR
                | CONTINUE_EXPR
                | DEREF_EXPR
                | DOT_EXPR
                | EXISTS_EXPR
                | FOR_EXPR
                | FORALL_EXPR
                | IF_EXPR
                | INDEX_EXPR
                | IS_EXPR
                | LAMBDA_EXPR
                | LITERAL
                | LOOP_EXPR
                | MATCH_EXPR
                | METHOD_CALL_EXPR
                | PAREN_EXPR
                | PATH_EXPR
                | RANGE_EXPR
                | RESOURCE_EXPR
                | RETURN_EXPR
                | STRUCT_LIT
                | TUPLE_EXPR
                | VECTOR_LIT_EXPR
                | WHILE_EXPR
        )
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            ABORT_EXPR => Expr::AbortExpr(AbortExpr { syntax }),
            ASSERT_MACRO_EXPR => Expr::AssertMacroExpr(AssertMacroExpr { syntax }),
            BANG_EXPR => Expr::BangExpr(BangExpr { syntax }),
            BIN_EXPR => Expr::BinExpr(BinExpr { syntax }),
            BLOCK_EXPR => Expr::BlockExpr(BlockExpr { syntax }),
            BORROW_EXPR => Expr::BorrowExpr(BorrowExpr { syntax }),
            BREAK_EXPR => Expr::BreakExpr(BreakExpr { syntax }),
            CALL_EXPR => Expr::CallExpr(CallExpr { syntax }),
            CAST_EXPR => Expr::CastExpr(CastExpr { syntax }),
            CHOOSE_EXPR => Expr::ChooseExpr(ChooseExpr { syntax }),
            CONTINUE_EXPR => Expr::ContinueExpr(ContinueExpr { syntax }),
            DEREF_EXPR => Expr::DerefExpr(DerefExpr { syntax }),
            DOT_EXPR => Expr::DotExpr(DotExpr { syntax }),
            EXISTS_EXPR => Expr::ExistsExpr(ExistsExpr { syntax }),
            FOR_EXPR => Expr::ForExpr(ForExpr { syntax }),
            FORALL_EXPR => Expr::ForallExpr(ForallExpr { syntax }),
            IF_EXPR => Expr::IfExpr(IfExpr { syntax }),
            INDEX_EXPR => Expr::IndexExpr(IndexExpr { syntax }),
            IS_EXPR => Expr::IsExpr(IsExpr { syntax }),
            LAMBDA_EXPR => Expr::LambdaExpr(LambdaExpr { syntax }),
            LITERAL => Expr::Literal(Literal { syntax }),
            LOOP_EXPR => Expr::LoopExpr(LoopExpr { syntax }),
            MATCH_EXPR => Expr::MatchExpr(MatchExpr { syntax }),
            METHOD_CALL_EXPR => Expr::MethodCallExpr(MethodCallExpr { syntax }),
            PAREN_EXPR => Expr::ParenExpr(ParenExpr { syntax }),
            PATH_EXPR => Expr::PathExpr(PathExpr { syntax }),
            RANGE_EXPR => Expr::RangeExpr(RangeExpr { syntax }),
            RESOURCE_EXPR => Expr::ResourceExpr(ResourceExpr { syntax }),
            RETURN_EXPR => Expr::ReturnExpr(ReturnExpr { syntax }),
            STRUCT_LIT => Expr::StructLit(StructLit { syntax }),
            TUPLE_EXPR => Expr::TupleExpr(TupleExpr { syntax }),
            VECTOR_LIT_EXPR => Expr::VectorLitExpr(VectorLitExpr { syntax }),
            WHILE_EXPR => Expr::WhileExpr(WhileExpr { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Expr::AbortExpr(it) => &it.syntax,
            Expr::AssertMacroExpr(it) => &it.syntax,
            Expr::BangExpr(it) => &it.syntax,
            Expr::BinExpr(it) => &it.syntax,
            Expr::BlockExpr(it) => &it.syntax,
            Expr::BorrowExpr(it) => &it.syntax,
            Expr::BreakExpr(it) => &it.syntax,
            Expr::CallExpr(it) => &it.syntax,
            Expr::CastExpr(it) => &it.syntax,
            Expr::ChooseExpr(it) => &it.syntax,
            Expr::ContinueExpr(it) => &it.syntax,
            Expr::DerefExpr(it) => &it.syntax,
            Expr::DotExpr(it) => &it.syntax,
            Expr::ExistsExpr(it) => &it.syntax,
            Expr::ForExpr(it) => &it.syntax,
            Expr::ForallExpr(it) => &it.syntax,
            Expr::IfExpr(it) => &it.syntax,
            Expr::IndexExpr(it) => &it.syntax,
            Expr::IsExpr(it) => &it.syntax,
            Expr::LambdaExpr(it) => &it.syntax,
            Expr::Literal(it) => &it.syntax,
            Expr::LoopExpr(it) => &it.syntax,
            Expr::MatchExpr(it) => &it.syntax,
            Expr::MethodCallExpr(it) => &it.syntax,
            Expr::ParenExpr(it) => &it.syntax,
            Expr::PathExpr(it) => &it.syntax,
            Expr::RangeExpr(it) => &it.syntax,
            Expr::ResourceExpr(it) => &it.syntax,
            Expr::ReturnExpr(it) => &it.syntax,
            Expr::StructLit(it) => &it.syntax,
            Expr::TupleExpr(it) => &it.syntax,
            Expr::VectorLitExpr(it) => &it.syntax,
            Expr::WhileExpr(it) => &it.syntax,
        }
    }
}
impl From<NamedFieldList> for FieldList {
    #[inline]
    fn from(node: NamedFieldList) -> FieldList { FieldList::NamedFieldList(node) }
}
impl From<TupleFieldList> for FieldList {
    #[inline]
    fn from(node: TupleFieldList) -> FieldList { FieldList::TupleFieldList(node) }
}
impl FieldList {
    pub fn named_field_list(self) -> Option<NamedFieldList> {
        match (self) {
            FieldList::NamedFieldList(item) => Some(item),
            _ => None,
        }
    }
    pub fn tuple_field_list(self) -> Option<TupleFieldList> {
        match (self) {
            FieldList::TupleFieldList(item) => Some(item),
            _ => None,
        }
    }
}
impl AstNode for FieldList {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, NAMED_FIELD_LIST | TUPLE_FIELD_LIST) }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            NAMED_FIELD_LIST => FieldList::NamedFieldList(NamedFieldList { syntax }),
            TUPLE_FIELD_LIST => FieldList::TupleFieldList(TupleFieldList { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            FieldList::NamedFieldList(it) => &it.syntax,
            FieldList::TupleFieldList(it) => &it.syntax,
        }
    }
}
impl From<LetStmt> for IdentPatKind {
    #[inline]
    fn from(node: LetStmt) -> IdentPatKind { IdentPatKind::LetStmt(node) }
}
impl From<Param> for IdentPatKind {
    #[inline]
    fn from(node: Param) -> IdentPatKind { IdentPatKind::Param(node) }
}
impl From<SchemaFieldStmt> for IdentPatKind {
    #[inline]
    fn from(node: SchemaFieldStmt) -> IdentPatKind { IdentPatKind::SchemaFieldStmt(node) }
}
impl IdentPatKind {
    pub fn let_stmt(self) -> Option<LetStmt> {
        match (self) {
            IdentPatKind::LetStmt(item) => Some(item),
            _ => None,
        }
    }
    pub fn param(self) -> Option<Param> {
        match (self) {
            IdentPatKind::Param(item) => Some(item),
            _ => None,
        }
    }
    pub fn schema_field_stmt(self) -> Option<SchemaFieldStmt> {
        match (self) {
            IdentPatKind::SchemaFieldStmt(item) => Some(item),
            _ => None,
        }
    }
}
impl AstNode for IdentPatKind {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, LET_STMT | PARAM | SCHEMA_FIELD_STMT) }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            LET_STMT => IdentPatKind::LetStmt(LetStmt { syntax }),
            PARAM => IdentPatKind::Param(Param { syntax }),
            SCHEMA_FIELD_STMT => IdentPatKind::SchemaFieldStmt(SchemaFieldStmt { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            IdentPatKind::LetStmt(it) => &it.syntax,
            IdentPatKind::Param(it) => &it.syntax,
            IdentPatKind::SchemaFieldStmt(it) => &it.syntax,
        }
    }
}
impl From<Fun> for InferenceCtxOwner {
    #[inline]
    fn from(node: Fun) -> InferenceCtxOwner { InferenceCtxOwner::Fun(node) }
}
impl From<ItemSpec> for InferenceCtxOwner {
    #[inline]
    fn from(node: ItemSpec) -> InferenceCtxOwner { InferenceCtxOwner::ItemSpec(node) }
}
impl From<Schema> for InferenceCtxOwner {
    #[inline]
    fn from(node: Schema) -> InferenceCtxOwner { InferenceCtxOwner::Schema(node) }
}
impl From<SpecFun> for InferenceCtxOwner {
    #[inline]
    fn from(node: SpecFun) -> InferenceCtxOwner { InferenceCtxOwner::SpecFun(node) }
}
impl From<SpecInlineFun> for InferenceCtxOwner {
    #[inline]
    fn from(node: SpecInlineFun) -> InferenceCtxOwner { InferenceCtxOwner::SpecInlineFun(node) }
}
impl InferenceCtxOwner {
    pub fn fun(self) -> Option<Fun> {
        match (self) {
            InferenceCtxOwner::Fun(item) => Some(item),
            _ => None,
        }
    }
    pub fn item_spec(self) -> Option<ItemSpec> {
        match (self) {
            InferenceCtxOwner::ItemSpec(item) => Some(item),
            _ => None,
        }
    }
    pub fn schema(self) -> Option<Schema> {
        match (self) {
            InferenceCtxOwner::Schema(item) => Some(item),
            _ => None,
        }
    }
    pub fn spec_fun(self) -> Option<SpecFun> {
        match (self) {
            InferenceCtxOwner::SpecFun(item) => Some(item),
            _ => None,
        }
    }
    pub fn spec_inline_fun(self) -> Option<SpecInlineFun> {
        match (self) {
            InferenceCtxOwner::SpecInlineFun(item) => Some(item),
            _ => None,
        }
    }
}
impl AstNode for InferenceCtxOwner {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, FUN | ITEM_SPEC | SCHEMA | SPEC_FUN | SPEC_INLINE_FUN)
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            FUN => InferenceCtxOwner::Fun(Fun { syntax }),
            ITEM_SPEC => InferenceCtxOwner::ItemSpec(ItemSpec { syntax }),
            SCHEMA => InferenceCtxOwner::Schema(Schema { syntax }),
            SPEC_FUN => InferenceCtxOwner::SpecFun(SpecFun { syntax }),
            SPEC_INLINE_FUN => InferenceCtxOwner::SpecInlineFun(SpecInlineFun { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            InferenceCtxOwner::Fun(it) => &it.syntax,
            InferenceCtxOwner::ItemSpec(it) => &it.syntax,
            InferenceCtxOwner::Schema(it) => &it.syntax,
            InferenceCtxOwner::SpecFun(it) => &it.syntax,
            InferenceCtxOwner::SpecInlineFun(it) => &it.syntax,
        }
    }
}
impl From<Const> for Item {
    #[inline]
    fn from(node: Const) -> Item { Item::Const(node) }
}
impl From<Enum> for Item {
    #[inline]
    fn from(node: Enum) -> Item { Item::Enum(node) }
}
impl From<Friend> for Item {
    #[inline]
    fn from(node: Friend) -> Item { Item::Friend(node) }
}
impl From<Fun> for Item {
    #[inline]
    fn from(node: Fun) -> Item { Item::Fun(node) }
}
impl From<ItemSpec> for Item {
    #[inline]
    fn from(node: ItemSpec) -> Item { Item::ItemSpec(node) }
}
impl From<Schema> for Item {
    #[inline]
    fn from(node: Schema) -> Item { Item::Schema(node) }
}
impl From<SpecFun> for Item {
    #[inline]
    fn from(node: SpecFun) -> Item { Item::SpecFun(node) }
}
impl From<Struct> for Item {
    #[inline]
    fn from(node: Struct) -> Item { Item::Struct(node) }
}
impl Item {
    pub fn const_(self) -> Option<Const> {
        match (self) {
            Item::Const(item) => Some(item),
            _ => None,
        }
    }
    pub fn enum_(self) -> Option<Enum> {
        match (self) {
            Item::Enum(item) => Some(item),
            _ => None,
        }
    }
    pub fn friend(self) -> Option<Friend> {
        match (self) {
            Item::Friend(item) => Some(item),
            _ => None,
        }
    }
    pub fn fun(self) -> Option<Fun> {
        match (self) {
            Item::Fun(item) => Some(item),
            _ => None,
        }
    }
    pub fn item_spec(self) -> Option<ItemSpec> {
        match (self) {
            Item::ItemSpec(item) => Some(item),
            _ => None,
        }
    }
    pub fn schema(self) -> Option<Schema> {
        match (self) {
            Item::Schema(item) => Some(item),
            _ => None,
        }
    }
    pub fn spec_fun(self) -> Option<SpecFun> {
        match (self) {
            Item::SpecFun(item) => Some(item),
            _ => None,
        }
    }
    pub fn struct_(self) -> Option<Struct> {
        match (self) {
            Item::Struct(item) => Some(item),
            _ => None,
        }
    }
}
impl AstNode for Item {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            CONST | ENUM | FRIEND | FUN | ITEM_SPEC | SCHEMA | SPEC_FUN | STRUCT
        )
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            CONST => Item::Const(Const { syntax }),
            ENUM => Item::Enum(Enum { syntax }),
            FRIEND => Item::Friend(Friend { syntax }),
            FUN => Item::Fun(Fun { syntax }),
            ITEM_SPEC => Item::ItemSpec(ItemSpec { syntax }),
            SCHEMA => Item::Schema(Schema { syntax }),
            SPEC_FUN => Item::SpecFun(SpecFun { syntax }),
            STRUCT => Item::Struct(Struct { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Item::Const(it) => &it.syntax,
            Item::Enum(it) => &it.syntax,
            Item::Friend(it) => &it.syntax,
            Item::Fun(it) => &it.syntax,
            Item::ItemSpec(it) => &it.syntax,
            Item::Schema(it) => &it.syntax,
            Item::SpecFun(it) => &it.syntax,
            Item::Struct(it) => &it.syntax,
        }
    }
}
impl From<MethodCallExpr> for MethodOrPath {
    #[inline]
    fn from(node: MethodCallExpr) -> MethodOrPath { MethodOrPath::MethodCallExpr(node) }
}
impl From<Path> for MethodOrPath {
    #[inline]
    fn from(node: Path) -> MethodOrPath { MethodOrPath::Path(node) }
}
impl From<MethodOrPath> for AnyReferenceElement {
    #[inline]
    fn from(node: MethodOrPath) -> AnyReferenceElement {
        match node {
            MethodOrPath::MethodCallExpr(it) => it.into(),
            MethodOrPath::Path(it) => it.into(),
        }
    }
}
impl MethodOrPath {
    pub fn method_call_expr(self) -> Option<MethodCallExpr> {
        match (self) {
            MethodOrPath::MethodCallExpr(item) => Some(item),
            _ => None,
        }
    }
    pub fn path(self) -> Option<Path> {
        match (self) {
            MethodOrPath::Path(item) => Some(item),
            _ => None,
        }
    }
}
impl AstNode for MethodOrPath {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, METHOD_CALL_EXPR | PATH) }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            METHOD_CALL_EXPR => MethodOrPath::MethodCallExpr(MethodCallExpr { syntax }),
            PATH => MethodOrPath::Path(Path { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            MethodOrPath::MethodCallExpr(it) => &it.syntax,
            MethodOrPath::Path(it) => &it.syntax,
        }
    }
}
impl From<Name> for NameLike {
    #[inline]
    fn from(node: Name) -> NameLike { NameLike::Name(node) }
}
impl From<NameRef> for NameLike {
    #[inline]
    fn from(node: NameRef) -> NameLike { NameLike::NameRef(node) }
}
impl NameLike {
    pub fn name(self) -> Option<Name> {
        match (self) {
            NameLike::Name(item) => Some(item),
            _ => None,
        }
    }
    pub fn name_ref(self) -> Option<NameRef> {
        match (self) {
            NameLike::NameRef(item) => Some(item),
            _ => None,
        }
    }
}
impl AstNode for NameLike {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, NAME | NAME_REF) }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            NAME => NameLike::Name(Name { syntax }),
            NAME_REF => NameLike::NameRef(NameRef { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            NameLike::Name(it) => &it.syntax,
            NameLike::NameRef(it) => &it.syntax,
        }
    }
}
impl From<IdentPat> for Pat {
    #[inline]
    fn from(node: IdentPat) -> Pat { Pat::IdentPat(node) }
}
impl From<PathPat> for Pat {
    #[inline]
    fn from(node: PathPat) -> Pat { Pat::PathPat(node) }
}
impl From<RestPat> for Pat {
    #[inline]
    fn from(node: RestPat) -> Pat { Pat::RestPat(node) }
}
impl From<StructPat> for Pat {
    #[inline]
    fn from(node: StructPat) -> Pat { Pat::StructPat(node) }
}
impl From<TuplePat> for Pat {
    #[inline]
    fn from(node: TuplePat) -> Pat { Pat::TuplePat(node) }
}
impl From<TupleStructPat> for Pat {
    #[inline]
    fn from(node: TupleStructPat) -> Pat { Pat::TupleStructPat(node) }
}
impl From<WildcardPat> for Pat {
    #[inline]
    fn from(node: WildcardPat) -> Pat { Pat::WildcardPat(node) }
}
impl Pat {
    pub fn ident_pat(self) -> Option<IdentPat> {
        match (self) {
            Pat::IdentPat(item) => Some(item),
            _ => None,
        }
    }
    pub fn path_pat(self) -> Option<PathPat> {
        match (self) {
            Pat::PathPat(item) => Some(item),
            _ => None,
        }
    }
    pub fn rest_pat(self) -> Option<RestPat> {
        match (self) {
            Pat::RestPat(item) => Some(item),
            _ => None,
        }
    }
    pub fn struct_pat(self) -> Option<StructPat> {
        match (self) {
            Pat::StructPat(item) => Some(item),
            _ => None,
        }
    }
    pub fn tuple_pat(self) -> Option<TuplePat> {
        match (self) {
            Pat::TuplePat(item) => Some(item),
            _ => None,
        }
    }
    pub fn tuple_struct_pat(self) -> Option<TupleStructPat> {
        match (self) {
            Pat::TupleStructPat(item) => Some(item),
            _ => None,
        }
    }
    pub fn wildcard_pat(self) -> Option<WildcardPat> {
        match (self) {
            Pat::WildcardPat(item) => Some(item),
            _ => None,
        }
    }
}
impl AstNode for Pat {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            IDENT_PAT | PATH_PAT | REST_PAT | STRUCT_PAT | TUPLE_PAT | TUPLE_STRUCT_PAT | WILDCARD_PAT
        )
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            IDENT_PAT => Pat::IdentPat(IdentPat { syntax }),
            PATH_PAT => Pat::PathPat(PathPat { syntax }),
            REST_PAT => Pat::RestPat(RestPat { syntax }),
            STRUCT_PAT => Pat::StructPat(StructPat { syntax }),
            TUPLE_PAT => Pat::TuplePat(TuplePat { syntax }),
            TUPLE_STRUCT_PAT => Pat::TupleStructPat(TupleStructPat { syntax }),
            WILDCARD_PAT => Pat::WildcardPat(WildcardPat { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Pat::IdentPat(it) => &it.syntax,
            Pat::PathPat(it) => &it.syntax,
            Pat::RestPat(it) => &it.syntax,
            Pat::StructPat(it) => &it.syntax,
            Pat::TuplePat(it) => &it.syntax,
            Pat::TupleStructPat(it) => &it.syntax,
            Pat::WildcardPat(it) => &it.syntax,
        }
    }
}
impl From<ChooseExpr> for QuantExpr {
    #[inline]
    fn from(node: ChooseExpr) -> QuantExpr { QuantExpr::ChooseExpr(node) }
}
impl From<ExistsExpr> for QuantExpr {
    #[inline]
    fn from(node: ExistsExpr) -> QuantExpr { QuantExpr::ExistsExpr(node) }
}
impl From<ForallExpr> for QuantExpr {
    #[inline]
    fn from(node: ForallExpr) -> QuantExpr { QuantExpr::ForallExpr(node) }
}
impl QuantExpr {
    pub fn choose_expr(self) -> Option<ChooseExpr> {
        match (self) {
            QuantExpr::ChooseExpr(item) => Some(item),
            _ => None,
        }
    }
    pub fn exists_expr(self) -> Option<ExistsExpr> {
        match (self) {
            QuantExpr::ExistsExpr(item) => Some(item),
            _ => None,
        }
    }
    pub fn forall_expr(self) -> Option<ForallExpr> {
        match (self) {
            QuantExpr::ForallExpr(item) => Some(item),
            _ => None,
        }
    }
    #[inline]
    pub fn quant_binding_list(&self) -> Option<QuantBindingList> {
        match self {
            QuantExpr::ChooseExpr(it) => it.quant_binding_list(),
            QuantExpr::ExistsExpr(it) => it.quant_binding_list(),
            QuantExpr::ForallExpr(it) => it.quant_binding_list(),
        }
    }
    #[inline]
    pub fn where_expr(&self) -> Option<WhereExpr> {
        match self {
            QuantExpr::ChooseExpr(it) => it.where_expr(),
            QuantExpr::ExistsExpr(it) => it.where_expr(),
            QuantExpr::ForallExpr(it) => it.where_expr(),
        }
    }
}
impl AstNode for QuantExpr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, CHOOSE_EXPR | EXISTS_EXPR | FORALL_EXPR) }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            CHOOSE_EXPR => QuantExpr::ChooseExpr(ChooseExpr { syntax }),
            EXISTS_EXPR => QuantExpr::ExistsExpr(ExistsExpr { syntax }),
            FORALL_EXPR => QuantExpr::ForallExpr(ForallExpr { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            QuantExpr::ChooseExpr(it) => &it.syntax,
            QuantExpr::ExistsExpr(it) => &it.syntax,
            QuantExpr::ForallExpr(it) => &it.syntax,
        }
    }
}
impl From<AbortsIfStmt> for Stmt {
    #[inline]
    fn from(node: AbortsIfStmt) -> Stmt { Stmt::AbortsIfStmt(node) }
}
impl From<ExprStmt> for Stmt {
    #[inline]
    fn from(node: ExprStmt) -> Stmt { Stmt::ExprStmt(node) }
}
impl From<LetStmt> for Stmt {
    #[inline]
    fn from(node: LetStmt) -> Stmt { Stmt::LetStmt(node) }
}
impl From<SchemaFieldStmt> for Stmt {
    #[inline]
    fn from(node: SchemaFieldStmt) -> Stmt { Stmt::SchemaFieldStmt(node) }
}
impl From<SpecInlineFun> for Stmt {
    #[inline]
    fn from(node: SpecInlineFun) -> Stmt { Stmt::SpecInlineFun(node) }
}
impl From<SpecPredicateStmt> for Stmt {
    #[inline]
    fn from(node: SpecPredicateStmt) -> Stmt { Stmt::SpecPredicateStmt(node) }
}
impl Stmt {
    pub fn aborts_if_stmt(self) -> Option<AbortsIfStmt> {
        match (self) {
            Stmt::AbortsIfStmt(item) => Some(item),
            _ => None,
        }
    }
    pub fn expr_stmt(self) -> Option<ExprStmt> {
        match (self) {
            Stmt::ExprStmt(item) => Some(item),
            _ => None,
        }
    }
    pub fn let_stmt(self) -> Option<LetStmt> {
        match (self) {
            Stmt::LetStmt(item) => Some(item),
            _ => None,
        }
    }
    pub fn schema_field_stmt(self) -> Option<SchemaFieldStmt> {
        match (self) {
            Stmt::SchemaFieldStmt(item) => Some(item),
            _ => None,
        }
    }
    pub fn spec_inline_fun(self) -> Option<SpecInlineFun> {
        match (self) {
            Stmt::SpecInlineFun(item) => Some(item),
            _ => None,
        }
    }
    pub fn spec_predicate_stmt(self) -> Option<SpecPredicateStmt> {
        match (self) {
            Stmt::SpecPredicateStmt(item) => Some(item),
            _ => None,
        }
    }
}
impl AstNode for Stmt {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            ABORTS_IF_STMT
                | EXPR_STMT
                | LET_STMT
                | SCHEMA_FIELD_STMT
                | SPEC_INLINE_FUN
                | SPEC_PREDICATE_STMT
        )
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            ABORTS_IF_STMT => Stmt::AbortsIfStmt(AbortsIfStmt { syntax }),
            EXPR_STMT => Stmt::ExprStmt(ExprStmt { syntax }),
            LET_STMT => Stmt::LetStmt(LetStmt { syntax }),
            SCHEMA_FIELD_STMT => Stmt::SchemaFieldStmt(SchemaFieldStmt { syntax }),
            SPEC_INLINE_FUN => Stmt::SpecInlineFun(SpecInlineFun { syntax }),
            SPEC_PREDICATE_STMT => Stmt::SpecPredicateStmt(SpecPredicateStmt { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Stmt::AbortsIfStmt(it) => &it.syntax,
            Stmt::ExprStmt(it) => &it.syntax,
            Stmt::LetStmt(it) => &it.syntax,
            Stmt::SchemaFieldStmt(it) => &it.syntax,
            Stmt::SpecInlineFun(it) => &it.syntax,
            Stmt::SpecPredicateStmt(it) => &it.syntax,
        }
    }
}
impl From<Enum> for StructOrEnum {
    #[inline]
    fn from(node: Enum) -> StructOrEnum { StructOrEnum::Enum(node) }
}
impl From<Struct> for StructOrEnum {
    #[inline]
    fn from(node: Struct) -> StructOrEnum { StructOrEnum::Struct(node) }
}
impl From<StructOrEnum> for AnyGenericElement {
    #[inline]
    fn from(node: StructOrEnum) -> AnyGenericElement {
        match node {
            StructOrEnum::Enum(it) => it.into(),
            StructOrEnum::Struct(it) => it.into(),
        }
    }
}
impl From<StructOrEnum> for AnyHasAttrs {
    #[inline]
    fn from(node: StructOrEnum) -> AnyHasAttrs {
        match node {
            StructOrEnum::Enum(it) => it.into(),
            StructOrEnum::Struct(it) => it.into(),
        }
    }
}
impl From<StructOrEnum> for AnyHasVisibility {
    #[inline]
    fn from(node: StructOrEnum) -> AnyHasVisibility {
        match node {
            StructOrEnum::Enum(it) => it.into(),
            StructOrEnum::Struct(it) => it.into(),
        }
    }
}
impl From<StructOrEnum> for AnyHoverDocsOwner {
    #[inline]
    fn from(node: StructOrEnum) -> AnyHoverDocsOwner {
        match node {
            StructOrEnum::Enum(it) => it.into(),
            StructOrEnum::Struct(it) => it.into(),
        }
    }
}
impl From<StructOrEnum> for AnyNamedElement {
    #[inline]
    fn from(node: StructOrEnum) -> AnyNamedElement {
        match node {
            StructOrEnum::Enum(it) => it.into(),
            StructOrEnum::Struct(it) => it.into(),
        }
    }
}
impl StructOrEnum {
    pub fn enum_(self) -> Option<Enum> {
        match (self) {
            StructOrEnum::Enum(item) => Some(item),
            _ => None,
        }
    }
    pub fn struct_(self) -> Option<Struct> {
        match (self) {
            StructOrEnum::Struct(item) => Some(item),
            _ => None,
        }
    }
    #[inline]
    pub fn type_param_list(&self) -> Option<TypeParamList> {
        match self {
            StructOrEnum::Enum(it) => ast::GenericElement::type_param_list(it),
            StructOrEnum::Struct(it) => ast::GenericElement::type_param_list(it),
        }
    }
    #[inline]
    pub fn ability_list(&self) -> Option<AbilityList> {
        match self {
            StructOrEnum::Enum(it) => it.ability_list(),
            StructOrEnum::Struct(it) => it.ability_list(),
        }
    }
}
impl AstNode for StructOrEnum {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, ENUM | STRUCT) }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            ENUM => StructOrEnum::Enum(Enum { syntax }),
            STRUCT => StructOrEnum::Struct(Struct { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            StructOrEnum::Enum(it) => &it.syntax,
            StructOrEnum::Struct(it) => &it.syntax,
        }
    }
}
impl From<LambdaType> for Type {
    #[inline]
    fn from(node: LambdaType) -> Type { Type::LambdaType(node) }
}
impl From<ParenType> for Type {
    #[inline]
    fn from(node: ParenType) -> Type { Type::ParenType(node) }
}
impl From<PathType> for Type {
    #[inline]
    fn from(node: PathType) -> Type { Type::PathType(node) }
}
impl From<RefType> for Type {
    #[inline]
    fn from(node: RefType) -> Type { Type::RefType(node) }
}
impl From<TupleType> for Type {
    #[inline]
    fn from(node: TupleType) -> Type { Type::TupleType(node) }
}
impl From<UnitType> for Type {
    #[inline]
    fn from(node: UnitType) -> Type { Type::UnitType(node) }
}
impl Type {
    pub fn lambda_type(self) -> Option<LambdaType> {
        match (self) {
            Type::LambdaType(item) => Some(item),
            _ => None,
        }
    }
    pub fn paren_type(self) -> Option<ParenType> {
        match (self) {
            Type::ParenType(item) => Some(item),
            _ => None,
        }
    }
    pub fn path_type(self) -> Option<PathType> {
        match (self) {
            Type::PathType(item) => Some(item),
            _ => None,
        }
    }
    pub fn ref_type(self) -> Option<RefType> {
        match (self) {
            Type::RefType(item) => Some(item),
            _ => None,
        }
    }
    pub fn tuple_type(self) -> Option<TupleType> {
        match (self) {
            Type::TupleType(item) => Some(item),
            _ => None,
        }
    }
    pub fn unit_type(self) -> Option<UnitType> {
        match (self) {
            Type::UnitType(item) => Some(item),
            _ => None,
        }
    }
}
impl AstNode for Type {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            LAMBDA_TYPE | PAREN_TYPE | PATH_TYPE | REF_TYPE | TUPLE_TYPE | UNIT_TYPE
        )
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            LAMBDA_TYPE => Type::LambdaType(LambdaType { syntax }),
            PAREN_TYPE => Type::ParenType(ParenType { syntax }),
            PATH_TYPE => Type::PathType(PathType { syntax }),
            REF_TYPE => Type::RefType(RefType { syntax }),
            TUPLE_TYPE => Type::TupleType(TupleType { syntax }),
            UNIT_TYPE => Type::UnitType(UnitType { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Type::LambdaType(it) => &it.syntax,
            Type::ParenType(it) => &it.syntax,
            Type::PathType(it) => &it.syntax,
            Type::RefType(it) => &it.syntax,
            Type::TupleType(it) => &it.syntax,
            Type::UnitType(it) => &it.syntax,
        }
    }
}
impl AnyFieldsOwner {
    #[inline]
    pub fn new<T: ast::FieldsOwner>(node: T) -> AnyFieldsOwner {
        AnyFieldsOwner {
            syntax: node.syntax().clone(),
        }
    }
    #[inline]
    pub fn cast_from<T: ast::FieldsOwner>(t: T) -> AnyFieldsOwner {
        AnyFieldsOwner::cast(t.syntax().to_owned()).expect("required by code generator")
    }
    #[inline]
    pub fn cast_into<T: ast::FieldsOwner>(&self) -> Option<T> { T::cast(self.syntax().to_owned()) }
}
impl AstNode for AnyFieldsOwner {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, STRUCT | VARIANT) }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        Self::can_cast(syntax.kind()).then_some(AnyFieldsOwner { syntax })
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl From<Struct> for AnyFieldsOwner {
    #[inline]
    fn from(node: Struct) -> AnyFieldsOwner { AnyFieldsOwner { syntax: node.syntax } }
}
impl From<Variant> for AnyFieldsOwner {
    #[inline]
    fn from(node: Variant) -> AnyFieldsOwner { AnyFieldsOwner { syntax: node.syntax } }
}
impl AnyGenericElement {
    #[inline]
    pub fn new<T: ast::GenericElement>(node: T) -> AnyGenericElement {
        AnyGenericElement {
            syntax: node.syntax().clone(),
        }
    }
    #[inline]
    pub fn cast_from<T: ast::GenericElement>(t: T) -> AnyGenericElement {
        AnyGenericElement::cast(t.syntax().to_owned()).expect("required by code generator")
    }
    #[inline]
    pub fn cast_into<T: ast::GenericElement>(&self) -> Option<T> { T::cast(self.syntax().to_owned()) }
}
impl AstNode for AnyGenericElement {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, ENUM | FUN | SCHEMA | SPEC_FUN | SPEC_INLINE_FUN | STRUCT)
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        Self::can_cast(syntax.kind()).then_some(AnyGenericElement { syntax })
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl From<Enum> for AnyGenericElement {
    #[inline]
    fn from(node: Enum) -> AnyGenericElement { AnyGenericElement { syntax: node.syntax } }
}
impl From<Fun> for AnyGenericElement {
    #[inline]
    fn from(node: Fun) -> AnyGenericElement { AnyGenericElement { syntax: node.syntax } }
}
impl From<Schema> for AnyGenericElement {
    #[inline]
    fn from(node: Schema) -> AnyGenericElement { AnyGenericElement { syntax: node.syntax } }
}
impl From<SpecFun> for AnyGenericElement {
    #[inline]
    fn from(node: SpecFun) -> AnyGenericElement { AnyGenericElement { syntax: node.syntax } }
}
impl From<SpecInlineFun> for AnyGenericElement {
    #[inline]
    fn from(node: SpecInlineFun) -> AnyGenericElement { AnyGenericElement { syntax: node.syntax } }
}
impl From<Struct> for AnyGenericElement {
    #[inline]
    fn from(node: Struct) -> AnyGenericElement { AnyGenericElement { syntax: node.syntax } }
}
impl AnyHasAttrs {
    #[inline]
    pub fn new<T: ast::HasAttrs>(node: T) -> AnyHasAttrs {
        AnyHasAttrs {
            syntax: node.syntax().clone(),
        }
    }
    #[inline]
    pub fn cast_from<T: ast::HasAttrs>(t: T) -> AnyHasAttrs {
        AnyHasAttrs::cast(t.syntax().to_owned()).expect("required by code generator")
    }
    #[inline]
    pub fn cast_into<T: ast::HasAttrs>(&self) -> Option<T> { T::cast(self.syntax().to_owned()) }
}
impl AstNode for AnyHasAttrs {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            CONST
                | ENUM
                | FUN
                | ITEM_SPEC
                | MODULE
                | MODULE_SPEC
                | NAMED_FIELD
                | SCHEMA
                | SCRIPT
                | SPEC_FUN
                | STRUCT
                | TUPLE_FIELD
                | USE_STMT
                | VARIANT
        )
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        Self::can_cast(syntax.kind()).then_some(AnyHasAttrs { syntax })
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl From<Const> for AnyHasAttrs {
    #[inline]
    fn from(node: Const) -> AnyHasAttrs { AnyHasAttrs { syntax: node.syntax } }
}
impl From<Enum> for AnyHasAttrs {
    #[inline]
    fn from(node: Enum) -> AnyHasAttrs { AnyHasAttrs { syntax: node.syntax } }
}
impl From<Fun> for AnyHasAttrs {
    #[inline]
    fn from(node: Fun) -> AnyHasAttrs { AnyHasAttrs { syntax: node.syntax } }
}
impl From<ItemSpec> for AnyHasAttrs {
    #[inline]
    fn from(node: ItemSpec) -> AnyHasAttrs { AnyHasAttrs { syntax: node.syntax } }
}
impl From<Module> for AnyHasAttrs {
    #[inline]
    fn from(node: Module) -> AnyHasAttrs { AnyHasAttrs { syntax: node.syntax } }
}
impl From<ModuleSpec> for AnyHasAttrs {
    #[inline]
    fn from(node: ModuleSpec) -> AnyHasAttrs { AnyHasAttrs { syntax: node.syntax } }
}
impl From<NamedField> for AnyHasAttrs {
    #[inline]
    fn from(node: NamedField) -> AnyHasAttrs { AnyHasAttrs { syntax: node.syntax } }
}
impl From<Schema> for AnyHasAttrs {
    #[inline]
    fn from(node: Schema) -> AnyHasAttrs { AnyHasAttrs { syntax: node.syntax } }
}
impl From<Script> for AnyHasAttrs {
    #[inline]
    fn from(node: Script) -> AnyHasAttrs { AnyHasAttrs { syntax: node.syntax } }
}
impl From<SpecFun> for AnyHasAttrs {
    #[inline]
    fn from(node: SpecFun) -> AnyHasAttrs { AnyHasAttrs { syntax: node.syntax } }
}
impl From<Struct> for AnyHasAttrs {
    #[inline]
    fn from(node: Struct) -> AnyHasAttrs { AnyHasAttrs { syntax: node.syntax } }
}
impl From<TupleField> for AnyHasAttrs {
    #[inline]
    fn from(node: TupleField) -> AnyHasAttrs { AnyHasAttrs { syntax: node.syntax } }
}
impl From<UseStmt> for AnyHasAttrs {
    #[inline]
    fn from(node: UseStmt) -> AnyHasAttrs { AnyHasAttrs { syntax: node.syntax } }
}
impl From<Variant> for AnyHasAttrs {
    #[inline]
    fn from(node: Variant) -> AnyHasAttrs { AnyHasAttrs { syntax: node.syntax } }
}
impl From<AnyFieldsOwner> for AnyHasAttrs {
    #[inline]
    fn from(node: AnyFieldsOwner) -> AnyHasAttrs { AnyHasAttrs { syntax: node.syntax } }
}
impl From<AnyHasItems> for AnyHasAttrs {
    #[inline]
    fn from(node: AnyHasItems) -> AnyHasAttrs { AnyHasAttrs { syntax: node.syntax } }
}
impl AnyHasItems {
    #[inline]
    pub fn new<T: ast::HasItems>(node: T) -> AnyHasItems {
        AnyHasItems {
            syntax: node.syntax().clone(),
        }
    }
    #[inline]
    pub fn cast_from<T: ast::HasItems>(t: T) -> AnyHasItems {
        AnyHasItems::cast(t.syntax().to_owned()).expect("required by code generator")
    }
    #[inline]
    pub fn cast_into<T: ast::HasItems>(&self) -> Option<T> { T::cast(self.syntax().to_owned()) }
}
impl AstNode for AnyHasItems {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, MODULE | MODULE_SPEC | SCRIPT) }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        Self::can_cast(syntax.kind()).then_some(AnyHasItems { syntax })
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl From<Module> for AnyHasItems {
    #[inline]
    fn from(node: Module) -> AnyHasItems { AnyHasItems { syntax: node.syntax } }
}
impl From<ModuleSpec> for AnyHasItems {
    #[inline]
    fn from(node: ModuleSpec) -> AnyHasItems { AnyHasItems { syntax: node.syntax } }
}
impl From<Script> for AnyHasItems {
    #[inline]
    fn from(node: Script) -> AnyHasItems { AnyHasItems { syntax: node.syntax } }
}
impl AnyHasStmts {
    #[inline]
    pub fn new<T: ast::HasStmts>(node: T) -> AnyHasStmts {
        AnyHasStmts {
            syntax: node.syntax().clone(),
        }
    }
    #[inline]
    pub fn cast_from<T: ast::HasStmts>(t: T) -> AnyHasStmts {
        AnyHasStmts::cast(t.syntax().to_owned()).expect("required by code generator")
    }
    #[inline]
    pub fn cast_into<T: ast::HasStmts>(&self) -> Option<T> { T::cast(self.syntax().to_owned()) }
}
impl AstNode for AnyHasStmts {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, BLOCK_EXPR) }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        Self::can_cast(syntax.kind()).then_some(AnyHasStmts { syntax })
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl From<BlockExpr> for AnyHasStmts {
    #[inline]
    fn from(node: BlockExpr) -> AnyHasStmts { AnyHasStmts { syntax: node.syntax } }
}
impl AnyHasUseStmts {
    #[inline]
    pub fn new<T: ast::HasUseStmts>(node: T) -> AnyHasUseStmts {
        AnyHasUseStmts {
            syntax: node.syntax().clone(),
        }
    }
    #[inline]
    pub fn cast_from<T: ast::HasUseStmts>(t: T) -> AnyHasUseStmts {
        AnyHasUseStmts::cast(t.syntax().to_owned()).expect("required by code generator")
    }
    #[inline]
    pub fn cast_into<T: ast::HasUseStmts>(&self) -> Option<T> { T::cast(self.syntax().to_owned()) }
}
impl AstNode for AnyHasUseStmts {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, BLOCK_EXPR | MODULE | MODULE_SPEC | SCRIPT) }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        Self::can_cast(syntax.kind()).then_some(AnyHasUseStmts { syntax })
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl From<BlockExpr> for AnyHasUseStmts {
    #[inline]
    fn from(node: BlockExpr) -> AnyHasUseStmts { AnyHasUseStmts { syntax: node.syntax } }
}
impl From<Module> for AnyHasUseStmts {
    #[inline]
    fn from(node: Module) -> AnyHasUseStmts { AnyHasUseStmts { syntax: node.syntax } }
}
impl From<ModuleSpec> for AnyHasUseStmts {
    #[inline]
    fn from(node: ModuleSpec) -> AnyHasUseStmts { AnyHasUseStmts { syntax: node.syntax } }
}
impl From<Script> for AnyHasUseStmts {
    #[inline]
    fn from(node: Script) -> AnyHasUseStmts { AnyHasUseStmts { syntax: node.syntax } }
}
impl From<AnyHasItems> for AnyHasUseStmts {
    #[inline]
    fn from(node: AnyHasItems) -> AnyHasUseStmts { AnyHasUseStmts { syntax: node.syntax } }
}
impl From<AnyHasStmts> for AnyHasUseStmts {
    #[inline]
    fn from(node: AnyHasStmts) -> AnyHasUseStmts { AnyHasUseStmts { syntax: node.syntax } }
}
impl AnyHasVisibility {
    #[inline]
    pub fn new<T: ast::HasVisibility>(node: T) -> AnyHasVisibility {
        AnyHasVisibility {
            syntax: node.syntax().clone(),
        }
    }
    #[inline]
    pub fn cast_from<T: ast::HasVisibility>(t: T) -> AnyHasVisibility {
        AnyHasVisibility::cast(t.syntax().to_owned()).expect("required by code generator")
    }
    #[inline]
    pub fn cast_into<T: ast::HasVisibility>(&self) -> Option<T> { T::cast(self.syntax().to_owned()) }
}
impl AstNode for AnyHasVisibility {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, CONST | ENUM | FUN | SPEC_FUN | SPEC_INLINE_FUN | STRUCT)
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        Self::can_cast(syntax.kind()).then_some(AnyHasVisibility { syntax })
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl From<Const> for AnyHasVisibility {
    #[inline]
    fn from(node: Const) -> AnyHasVisibility { AnyHasVisibility { syntax: node.syntax } }
}
impl From<Enum> for AnyHasVisibility {
    #[inline]
    fn from(node: Enum) -> AnyHasVisibility { AnyHasVisibility { syntax: node.syntax } }
}
impl From<Fun> for AnyHasVisibility {
    #[inline]
    fn from(node: Fun) -> AnyHasVisibility { AnyHasVisibility { syntax: node.syntax } }
}
impl From<SpecFun> for AnyHasVisibility {
    #[inline]
    fn from(node: SpecFun) -> AnyHasVisibility { AnyHasVisibility { syntax: node.syntax } }
}
impl From<SpecInlineFun> for AnyHasVisibility {
    #[inline]
    fn from(node: SpecInlineFun) -> AnyHasVisibility { AnyHasVisibility { syntax: node.syntax } }
}
impl From<Struct> for AnyHasVisibility {
    #[inline]
    fn from(node: Struct) -> AnyHasVisibility { AnyHasVisibility { syntax: node.syntax } }
}
impl AnyHoverDocsOwner {
    #[inline]
    pub fn new<T: ast::HoverDocsOwner>(node: T) -> AnyHoverDocsOwner {
        AnyHoverDocsOwner {
            syntax: node.syntax().clone(),
        }
    }
    #[inline]
    pub fn cast_from<T: ast::HoverDocsOwner>(t: T) -> AnyHoverDocsOwner {
        AnyHoverDocsOwner::cast(t.syntax().to_owned()).expect("required by code generator")
    }
    #[inline]
    pub fn cast_into<T: ast::HoverDocsOwner>(&self) -> Option<T> { T::cast(self.syntax().to_owned()) }
}
impl AstNode for AnyHoverDocsOwner {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            CONST
                | ENUM
                | FUN
                | IDENT_PAT
                | MODULE
                | NAMED_FIELD
                | SCHEMA
                | SPEC_FUN
                | SPEC_INLINE_FUN
                | STRUCT
                | VARIANT
        )
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        Self::can_cast(syntax.kind()).then_some(AnyHoverDocsOwner { syntax })
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl From<Const> for AnyHoverDocsOwner {
    #[inline]
    fn from(node: Const) -> AnyHoverDocsOwner { AnyHoverDocsOwner { syntax: node.syntax } }
}
impl From<Enum> for AnyHoverDocsOwner {
    #[inline]
    fn from(node: Enum) -> AnyHoverDocsOwner { AnyHoverDocsOwner { syntax: node.syntax } }
}
impl From<Fun> for AnyHoverDocsOwner {
    #[inline]
    fn from(node: Fun) -> AnyHoverDocsOwner { AnyHoverDocsOwner { syntax: node.syntax } }
}
impl From<IdentPat> for AnyHoverDocsOwner {
    #[inline]
    fn from(node: IdentPat) -> AnyHoverDocsOwner { AnyHoverDocsOwner { syntax: node.syntax } }
}
impl From<Module> for AnyHoverDocsOwner {
    #[inline]
    fn from(node: Module) -> AnyHoverDocsOwner { AnyHoverDocsOwner { syntax: node.syntax } }
}
impl From<NamedField> for AnyHoverDocsOwner {
    #[inline]
    fn from(node: NamedField) -> AnyHoverDocsOwner { AnyHoverDocsOwner { syntax: node.syntax } }
}
impl From<Schema> for AnyHoverDocsOwner {
    #[inline]
    fn from(node: Schema) -> AnyHoverDocsOwner { AnyHoverDocsOwner { syntax: node.syntax } }
}
impl From<SpecFun> for AnyHoverDocsOwner {
    #[inline]
    fn from(node: SpecFun) -> AnyHoverDocsOwner { AnyHoverDocsOwner { syntax: node.syntax } }
}
impl From<SpecInlineFun> for AnyHoverDocsOwner {
    #[inline]
    fn from(node: SpecInlineFun) -> AnyHoverDocsOwner { AnyHoverDocsOwner { syntax: node.syntax } }
}
impl From<Struct> for AnyHoverDocsOwner {
    #[inline]
    fn from(node: Struct) -> AnyHoverDocsOwner { AnyHoverDocsOwner { syntax: node.syntax } }
}
impl From<Variant> for AnyHoverDocsOwner {
    #[inline]
    fn from(node: Variant) -> AnyHoverDocsOwner { AnyHoverDocsOwner { syntax: node.syntax } }
}
impl From<AnyFieldsOwner> for AnyHoverDocsOwner {
    #[inline]
    fn from(node: AnyFieldsOwner) -> AnyHoverDocsOwner { AnyHoverDocsOwner { syntax: node.syntax } }
}
impl From<AnyGenericElement> for AnyHoverDocsOwner {
    #[inline]
    fn from(node: AnyGenericElement) -> AnyHoverDocsOwner { AnyHoverDocsOwner { syntax: node.syntax } }
}
impl From<AnyHasVisibility> for AnyHoverDocsOwner {
    #[inline]
    fn from(node: AnyHasVisibility) -> AnyHoverDocsOwner { AnyHoverDocsOwner { syntax: node.syntax } }
}
impl AnyLoopLike {
    #[inline]
    pub fn new<T: ast::LoopLike>(node: T) -> AnyLoopLike {
        AnyLoopLike {
            syntax: node.syntax().clone(),
        }
    }
    #[inline]
    pub fn cast_from<T: ast::LoopLike>(t: T) -> AnyLoopLike {
        AnyLoopLike::cast(t.syntax().to_owned()).expect("required by code generator")
    }
    #[inline]
    pub fn cast_into<T: ast::LoopLike>(&self) -> Option<T> { T::cast(self.syntax().to_owned()) }
}
impl AstNode for AnyLoopLike {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool { matches!(kind, FOR_EXPR | LOOP_EXPR | WHILE_EXPR) }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        Self::can_cast(syntax.kind()).then_some(AnyLoopLike { syntax })
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl From<ForExpr> for AnyLoopLike {
    #[inline]
    fn from(node: ForExpr) -> AnyLoopLike { AnyLoopLike { syntax: node.syntax } }
}
impl From<LoopExpr> for AnyLoopLike {
    #[inline]
    fn from(node: LoopExpr) -> AnyLoopLike { AnyLoopLike { syntax: node.syntax } }
}
impl From<WhileExpr> for AnyLoopLike {
    #[inline]
    fn from(node: WhileExpr) -> AnyLoopLike { AnyLoopLike { syntax: node.syntax } }
}
impl AnyMslOnly {
    #[inline]
    pub fn new<T: ast::MslOnly>(node: T) -> AnyMslOnly {
        AnyMslOnly {
            syntax: node.syntax().clone(),
        }
    }
    #[inline]
    pub fn cast_from<T: ast::MslOnly>(t: T) -> AnyMslOnly {
        AnyMslOnly::cast(t.syntax().to_owned()).expect("required by code generator")
    }
    #[inline]
    pub fn cast_into<T: ast::MslOnly>(&self) -> Option<T> { T::cast(self.syntax().to_owned()) }
}
impl AstNode for AnyMslOnly {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            ITEM_SPEC | MODULE_SPEC | SCHEMA | SPEC_FUN | SPEC_INLINE_FUN
        )
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        Self::can_cast(syntax.kind()).then_some(AnyMslOnly { syntax })
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl From<ItemSpec> for AnyMslOnly {
    #[inline]
    fn from(node: ItemSpec) -> AnyMslOnly { AnyMslOnly { syntax: node.syntax } }
}
impl From<ModuleSpec> for AnyMslOnly {
    #[inline]
    fn from(node: ModuleSpec) -> AnyMslOnly { AnyMslOnly { syntax: node.syntax } }
}
impl From<Schema> for AnyMslOnly {
    #[inline]
    fn from(node: Schema) -> AnyMslOnly { AnyMslOnly { syntax: node.syntax } }
}
impl From<SpecFun> for AnyMslOnly {
    #[inline]
    fn from(node: SpecFun) -> AnyMslOnly { AnyMslOnly { syntax: node.syntax } }
}
impl From<SpecInlineFun> for AnyMslOnly {
    #[inline]
    fn from(node: SpecInlineFun) -> AnyMslOnly { AnyMslOnly { syntax: node.syntax } }
}
impl AnyNamedElement {
    #[inline]
    pub fn new<T: ast::NamedElement>(node: T) -> AnyNamedElement {
        AnyNamedElement {
            syntax: node.syntax().clone(),
        }
    }
    #[inline]
    pub fn cast_from<T: ast::NamedElement>(t: T) -> AnyNamedElement {
        AnyNamedElement::cast(t.syntax().to_owned()).expect("required by code generator")
    }
    #[inline]
    pub fn cast_into<T: ast::NamedElement>(&self) -> Option<T> { T::cast(self.syntax().to_owned()) }
}
impl AstNode for AnyNamedElement {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            CONST
                | ENUM
                | FUN
                | IDENT_PAT
                | MODULE
                | NAMED_FIELD
                | SCHEMA
                | SPEC_FUN
                | SPEC_INLINE_FUN
                | STRUCT
                | TYPE_PARAM
                | USE_ALIAS
                | VARIANT
        )
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        Self::can_cast(syntax.kind()).then_some(AnyNamedElement { syntax })
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl From<Const> for AnyNamedElement {
    #[inline]
    fn from(node: Const) -> AnyNamedElement { AnyNamedElement { syntax: node.syntax } }
}
impl From<Enum> for AnyNamedElement {
    #[inline]
    fn from(node: Enum) -> AnyNamedElement { AnyNamedElement { syntax: node.syntax } }
}
impl From<Fun> for AnyNamedElement {
    #[inline]
    fn from(node: Fun) -> AnyNamedElement { AnyNamedElement { syntax: node.syntax } }
}
impl From<IdentPat> for AnyNamedElement {
    #[inline]
    fn from(node: IdentPat) -> AnyNamedElement { AnyNamedElement { syntax: node.syntax } }
}
impl From<Module> for AnyNamedElement {
    #[inline]
    fn from(node: Module) -> AnyNamedElement { AnyNamedElement { syntax: node.syntax } }
}
impl From<NamedField> for AnyNamedElement {
    #[inline]
    fn from(node: NamedField) -> AnyNamedElement { AnyNamedElement { syntax: node.syntax } }
}
impl From<Schema> for AnyNamedElement {
    #[inline]
    fn from(node: Schema) -> AnyNamedElement { AnyNamedElement { syntax: node.syntax } }
}
impl From<SpecFun> for AnyNamedElement {
    #[inline]
    fn from(node: SpecFun) -> AnyNamedElement { AnyNamedElement { syntax: node.syntax } }
}
impl From<SpecInlineFun> for AnyNamedElement {
    #[inline]
    fn from(node: SpecInlineFun) -> AnyNamedElement { AnyNamedElement { syntax: node.syntax } }
}
impl From<Struct> for AnyNamedElement {
    #[inline]
    fn from(node: Struct) -> AnyNamedElement { AnyNamedElement { syntax: node.syntax } }
}
impl From<TypeParam> for AnyNamedElement {
    #[inline]
    fn from(node: TypeParam) -> AnyNamedElement { AnyNamedElement { syntax: node.syntax } }
}
impl From<UseAlias> for AnyNamedElement {
    #[inline]
    fn from(node: UseAlias) -> AnyNamedElement { AnyNamedElement { syntax: node.syntax } }
}
impl From<Variant> for AnyNamedElement {
    #[inline]
    fn from(node: Variant) -> AnyNamedElement { AnyNamedElement { syntax: node.syntax } }
}
impl From<AnyFieldsOwner> for AnyNamedElement {
    #[inline]
    fn from(node: AnyFieldsOwner) -> AnyNamedElement { AnyNamedElement { syntax: node.syntax } }
}
impl From<AnyGenericElement> for AnyNamedElement {
    #[inline]
    fn from(node: AnyGenericElement) -> AnyNamedElement { AnyNamedElement { syntax: node.syntax } }
}
impl From<AnyHasVisibility> for AnyNamedElement {
    #[inline]
    fn from(node: AnyHasVisibility) -> AnyNamedElement { AnyNamedElement { syntax: node.syntax } }
}
impl From<AnyHoverDocsOwner> for AnyNamedElement {
    #[inline]
    fn from(node: AnyHoverDocsOwner) -> AnyNamedElement { AnyNamedElement { syntax: node.syntax } }
}
impl AnyReferenceElement {
    #[inline]
    pub fn new<T: ast::ReferenceElement>(node: T) -> AnyReferenceElement {
        AnyReferenceElement {
            syntax: node.syntax().clone(),
        }
    }
    #[inline]
    pub fn cast_from<T: ast::ReferenceElement>(t: T) -> AnyReferenceElement {
        AnyReferenceElement::cast(t.syntax().to_owned()).expect("required by code generator")
    }
    #[inline]
    pub fn cast_into<T: ast::ReferenceElement>(&self) -> Option<T> { T::cast(self.syntax().to_owned()) }
}
impl AstNode for AnyReferenceElement {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            FIELD_REF | IDENT_PAT | METHOD_CALL_EXPR | PATH | STRUCT_LIT_FIELD | STRUCT_PAT_FIELD
        )
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        Self::can_cast(syntax.kind()).then_some(AnyReferenceElement { syntax })
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl From<FieldRef> for AnyReferenceElement {
    #[inline]
    fn from(node: FieldRef) -> AnyReferenceElement { AnyReferenceElement { syntax: node.syntax } }
}
impl From<IdentPat> for AnyReferenceElement {
    #[inline]
    fn from(node: IdentPat) -> AnyReferenceElement { AnyReferenceElement { syntax: node.syntax } }
}
impl From<MethodCallExpr> for AnyReferenceElement {
    #[inline]
    fn from(node: MethodCallExpr) -> AnyReferenceElement { AnyReferenceElement { syntax: node.syntax } }
}
impl From<Path> for AnyReferenceElement {
    #[inline]
    fn from(node: Path) -> AnyReferenceElement { AnyReferenceElement { syntax: node.syntax } }
}
impl From<StructLitField> for AnyReferenceElement {
    #[inline]
    fn from(node: StructLitField) -> AnyReferenceElement { AnyReferenceElement { syntax: node.syntax } }
}
impl From<StructPatField> for AnyReferenceElement {
    #[inline]
    fn from(node: StructPatField) -> AnyReferenceElement { AnyReferenceElement { syntax: node.syntax } }
}
impl std::fmt::Display for AddressRef {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyField {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnyFun {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for BlockOrInlineExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Expr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for FieldList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for IdentPatKind {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for InferenceCtxOwner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Item {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MethodOrPath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for NameLike {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Pat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for QuantExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Stmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for StructOrEnum {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Type {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Ability {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AbilityList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AbortExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AbortsIfStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AbortsIfWith {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AddressDef {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AddressLit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ArgList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AssertMacroExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Attr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AttrItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for BangExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for BinExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for BlockExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for BorrowExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for BreakExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CallExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CastExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ChooseExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Condition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Const {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ContinueExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for DerefExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for DotExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Enum {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ExistsExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ExprStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for FieldRef {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ForCondition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ForExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ForallExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Friend {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Fun {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for IdentPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for IfExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for IndexExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for IndexRef {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for InlineExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for IsExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ItemSpec {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Label {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for LambdaExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for LambdaParam {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for LambdaParamList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for LambdaType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for LambdaTypeParam {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for LetStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Literal {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for LoopExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MatchArm {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MatchArmList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MatchExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MatchGuard {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MethodCallExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Module {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ModuleSpec {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Name {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for NameRef {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for NamedAddress {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for NamedField {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for NamedFieldList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Param {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ParamList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ParenExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ParenType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Path {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PathAddress {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PathExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PathPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PathSegment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PathType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for QuantBinding {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for QuantBindingList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for RangeExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for RefType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ResourceExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for RestPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for RetType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ReturnExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Schema {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SchemaFieldStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Script {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SourceFile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SpecFun {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SpecInlineFun {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SpecPredicateProperty {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SpecPredicatePropertyList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SpecPredicateStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Struct {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for StructLit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for StructLitField {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for StructLitFieldList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for StructPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for StructPatField {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for StructPatFieldList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TupleExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TupleField {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TupleFieldList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TuplePat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TupleStructPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TupleType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TypeArg {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TypeArgList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TypeParam {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TypeParamList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for UnitType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for UseAlias {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for UseGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for UseSpeck {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for UseStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ValueAddress {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Variant {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for VariantList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for VectorLitExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for VisibilityModifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for WhereExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for WhileExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for WildcardPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
