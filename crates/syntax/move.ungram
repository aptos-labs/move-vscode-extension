// Aptos Move Un-Grammar.
//
// This grammar specifies the structure of Rust's concrete syntax tree.
// It does not specify parsing rules (ambiguities, precedence, etc are out of scope).
// Tokens are processed -- contextual keywords are recognised, compound operators glued.
//
// Legend:
//
//   //          -- comment
//   Name =      -- non-terminal definition
//   'ident'     -- token (terminal)
//   A B         -- sequence
//   A | B       -- alternation
//   A*          -- zero or more repetition
//   A?          -- zero or one repetition
//   (A)         -- same as A
//   label:A     -- suggested name for field of AST node

SourceFile = AddressDef* | Module* | ModuleSpec* | Script*

AddressDef =
    'address' AddressRef
    '{' Module* '}'

Module =
    Attr*
    'module' (AddressRef '::')? Name
    '{' UseStmt* Item* '}'

Script =
    Attr* 'script' '{' UseStmt* Item* '}'

Item =
    Friend
    | Fun
    | Const
    | Struct
    | Enum
    | SpecFun
    | Schema
    | ItemSpec

UseStmt =
    Attr* 'use' UseSpeck ';'

UseSpeck =
    Path (UseAlias | ('::' UseGroup) )?

UseAlias =
    'as' Name

UseGroup =
    '{' UseSpeck* '}'

Friend =
    'friend' Path ';'

StructOrEnum =
    Struct | Enum

Struct =
    Attr*
    'struct' Name TypeParamList?
    (NamedFieldList | TupleFieldList)

Enum =
    Attr*
    'enum' Name TypeParamList?
    VariantList

VariantList =
    '{' (Variant (',' Variant)* ','?)? '}'

Variant =
    Attr* Name (NamedFieldList | TupleFieldList)?

FieldList =
    NamedFieldList | TupleFieldList

NamedFieldList =
    '{' fields:(NamedField (',' NamedField)* ','?)? '}'

AnyField =
    NamedField | TupleField

NamedField =
    Attr* Name ':' Type

TupleFieldList =
  '(' fields:(TupleField (',' TupleField)* ','?)? ')'

TupleField =
    Attr* Type

Const =
    Attr* 'const' Name ':' Type '=' body:Expr ';'

Fun =
    Attr* VisibilityModifier?
    'native'? 'entry'? 'inline'?
    'fun' Name TypeParamList? ParamList RetType?
    (body:BlockExpr | ';')

VisibilityModifier =
    ('public' ('(' ('script' | 'package' | 'friend') ')')?)
        | 'package'
        | 'friend'

ParamList =
    '('
        (Param (',' Param)* ','?)?
    ')'

Param = IdentPat (':' Type)?

RetType =
  ':' Type

Pat =
    IdentPat
    | TuplePat
    | StructPat
    | TupleStructPat
    | RestPat
    | WildcardPat

TuplePat =
    '(' fields:(Pat (',' Pat)* ','?)? ')'

TupleStructPat =
    Path '(' fields:(Pat (',' Pat)* ','?)? ')'

StructPat =
    Path StructPatFieldList

StructPatFieldList =
    '{' fields:(StructPatField (',' StructPatField)* ','?)? '}'

StructPatField =
    (NameRef ':' Pat) | IdentPat | RestPat

WildcardPat = '_'
RestPat = '..'
IdentPat = Name

Type =
    PathType
    | RefType

RefType =
    '&' 'mut'? Type

PathType =
    Path

BlockExpr =
    '{'
        UseStmt*
        stmts:Stmt*
        tail_expr:Expr?
    '}'

InlineExpr = Expr

Stmt =
    ';'
    | ExprStmt
    | LetStmt
    | SchemaField
    | SpecInlineFun

LetStmt =
    'let' Pat '=' initializer:Expr ';'

ExprStmt =
    Expr ';'?

Expr =
    BinExpr
    | Literal
    | ParenExpr
    | PathExpr
    | PrefixExpr

ForExpr =
    'for' ForCondition (BlockExpr | InlineExpr)

ForCondition =
    '(' IdentPat 'in' Expr ')'


PrefixExpr =
  op:('-' | '!' | '*' | 'copy' | 'move') Expr

BinExpr =
    Attr*
    lhs:Expr
    op:(
    '||' | '&&'
    | '==' | '!=' | '<=' | '>=' | '<' | '>'
    | '+' | '*' | '-' | '/' | '%' | '<<' | '>>' | '^' | '|' | '&'
    | '=' | '+=' | '/=' | '*=' | '%=' | '>>=' | '<<=' | '-=' | '|=' | '&=' | '^='
    )
    rhs:Expr

StructLit =
    Path StructLitFieldList

StructLitFieldList =
    '{' fields:(StructLitField (',' StructLitField)* ','?)? '}'

StructLitField =
    (NameRef ':')? Expr

Literal =
    Attr* value:(
        '@int_number' | 'true' | 'false'
    )

ParenExpr =
    '(' Expr ')'

PathExpr =
    Path

Path =
    (qualifier:Path '::')? segment:PathSegment

PathSegment =
    PathAddress | (NameRef TypeArgList? )

PathAddress =
    ValueAddress

TypeParamList =
    '<' type_parameters:(TypeParam (',' TypeParam)* ','?)? '>'

TypeParam =
    'phantom'? Name

TypeArgList =
    '<' type_arguments:(TypeArg (',' TypeArg)* ','?)? '>'

TypeArg =
    Type

Attr =
  '#' '!'? '[' AttrItem ']'

AttrItem =
    Path '=' Expr

Name =
    'ident'

AddressRef =
    NamedAddress | ValueAddress

NamedAddress =
    'ident'

ValueAddress =
    'int_number'

NameRef =
    'ident'

// -------------------------- Specifications

ModuleSpec =
    Attr* 'spec' Path '{' UseStmt* Item* '}'

ItemSpec =
    Attr* 'spec' ('module' | NameRef) spec_block:BlockExpr

SpecFun =
    Attr*
    'spec' 'native'? 'fun' Name TypeParamList? ParamList RetType?
    (spec_block:BlockExpr | ';')

SpecInlineFun =
    'native'? 'fun' Name TypeParamList? ParamList RetType?
    (spec_block:BlockExpr | ';')

Schema =
    Attr*
    'spec' 'schema' Name TypeParamList?
    spec_block:BlockExpr

SchemaField =
    'local'? IdentPat ':' Type ';'
