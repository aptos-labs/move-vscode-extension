// Aptos Move Un-Grammar.
//
// This grammar specifies the structure of Rust's concrete syntax tree.
// It does not specify parsing rules (ambiguities, precedence, etc are out of scope).
// Tokens are processed -- contextual keywords are recognised, compound operators glued.
//
// Legend:
//
//   //          -- comment
//   Name =      -- non-terminal definition
//   'ident'     -- token (terminal)
//   A B         -- sequence
//   A | B       -- alternation
//   A*          -- zero or more repetition
//   A?          -- zero or one repetition
//   (A)         -- same as A
//   label:A     -- suggested name for field of AST node

SourceFile = AddressDef* | Module* | ModuleSpec* | Script*

AddressDef =
    'address' AddressRef
    '{' Module* '}'

Module =
    Attr*
    'module' (AddressRef '::')? Name
    '{' UseStmt* Item* '}'

Script =
    Attr* 'script' '{' UseStmt* Item* '}'

Item =
    Friend
    | Fun
    | Const
    | Struct
    | Enum
    | SpecFun
    | Schema
    | ItemSpec

NamedElement =
    Module
    | TypeParam
    | Struct
    | Enum
    | Variant
    | NamedField
    | Const
    | Fun
    | SpecFun
    | SpecInlineFun
    | IdentPat
    | UseAlias
    | Schema
    | GlobalVariableDecl

ReferenceElement =
    Path
    | MethodCallExpr
    | DotExpr
    | StructPatField
    | StructLitField
    | SchemaLitField
    | IdentPat
    | ItemSpecRef
    | ItemSpecTypeParam
    | Label

InferenceCtxOwner =
    Fun | SpecFun | SpecInlineFun | ItemSpec | Schema

IdentPatOwner =
    LetStmt | Param | LambdaParam | SchemaField | QuantBinding | ItemSpecParam | ForCondition

UseStmt =
    Attr* 'use' UseSpeck ';'

UseSpeck =
    Path (UseAlias | ('::' UseGroup) )?

UseAlias =
    'as' Name

UseGroup =
    '{' UseSpeck* '}'

Friend =
    Attr*
    'friend' Path ';'

StructOrEnum =
    Struct | Enum

FieldsOwner =
    Struct | Variant

Struct =
    Attr*
    'struct' Name TypeParamList?
    AbilityList?
    FieldList

Enum =
    Attr*
    'enum' Name TypeParamList?
    AbilityList?
    VariantList

VariantList =
    '{' (Variant (',' Variant)* ','?)? '}'

Variant =
    Attr* Name FieldList?

AbilityList =
    'has' (Ability (',' Ability)* ','?)?

Ability = 'ident'

FieldList =
    NamedFieldList | TupleFieldList

NamedFieldList =
    '{' fields:(NamedField (',' NamedField)* ','?)? '}'

TypeOwner =
    NamedField | TupleField | SchemaField | GlobalVariableDecl

AnyField =
    NamedField | TupleField

NamedField =
    Attr* Name ':' Type

TupleFieldList =
  '(' fields:(TupleField (',' TupleField)* ','?)? ')'

TupleField =
    Attr* Type

Const =
    Attr* 'const' Name ':' Type '=' body:Expr ';'

Fun =
    Attr* VisibilityModifier?
    'native'? 'entry'? 'inline'?
    'fun' Name TypeParamList? ParamList RetType?
    (body:BlockExpr | ';')

VisibilityModifier =
    ('public' ('(' ('script' | 'package' | 'friend') ')')?)
        | 'package'
        | 'friend'

ParamList =
    '(' (Param (',' Param)* ','?)? ')'

Param = (IdentPat | WildcardPat) (':' Type)?

RetType =
  ':' Type

Pat =
    IdentPat
    | TuplePat
    | StructPat
    | TupleStructPat
    | RestPat
    | WildcardPat
    | PathPat
    | ParenPat
    | UnitPat

TuplePat =
    '(' pats:(Pat (',' Pat)* ','?)? ')'
ParenPat =
    '(' Pat ')'
UnitPat = '(' ')'

TupleStructPat =
    Path '(' fields:(Pat (',' Pat)* ','?)? ')'

StructPat =
    Path StructPatFieldList

StructPatFieldList =
    '{' fields:(StructPatField (',' StructPatField)* ','?)? '}'

StructPatField =
    (NameRef ':' Pat) | IdentPat | RestPat | WildcardPat

WildcardPat = '_'
RestPat = '..'
IdentPat = Name
PathPat = Path

Type =
    PathType
    | RefType
    | TupleType
    | UnitType
    | ParenType
    | LambdaType

RefType =
    '&' 'mut'? Type

TupleType =
    '(' types:(Type (',' Type)* ','?)? ')'
UnitType = '(' ')'
ParenType = '(' Type ')'

PathType =
    Path

LambdaType =
    '|' lambda_type_params:(LambdaTypeParam (',' LambdaTypeParam)* ','?)? '|' (return_type:Type)?

LambdaTypeParam =
    Type

BlockExpr =
    '{'
        UseStmt*
        stmts:Stmt*
        tail_expr:Expr?
    '}'

SpecBlockExpr =
    'spec' BlockExpr

InlineExpr = Expr

BlockOrInlineExpr = BlockExpr | InlineExpr

Stmt =
    ';'
    | ExprStmt
    | LetStmt
    | SchemaField | IncludeSchema | ApplySchema
    | SpecPredicateStmt | AbortsIfStmt | AbortsWithStmt | PragmaStmt
    | GenericSpecStmt
    | SpecInlineFun | GlobalVariableDecl

GenericSpecStmt = InvariantStmt | AxiomStmt

LetStmt =
    'let' 'post'? Pat (':' Type) '=' initializer:Expr ';'

ExprStmt =
    Expr ';'?

Expr =
    BinExpr
    | IsExpr
    | Literal
    | ParenExpr
    | UnitExpr
    | PathExpr
    | BorrowExpr | DerefExpr | BangExpr
    | ResourceExpr
    | CallExpr | MethodCallExpr | AssertMacroExpr
    | LambdaExpr
    | RangeExpr | VectorLitExpr | StructLit | TupleExpr
    | IndexExpr
    | DotExpr
    | AbortExpr
    | BlockExpr
    | IfExpr | WhileExpr | ForExpr | LoopExpr
    | BreakExpr | ContinueExpr | ReturnExpr
    | CastExpr
    | MatchExpr
    | ForallExpr | ExistsExpr | ChooseExpr
    | SpecBlockExpr

BorrowExpr =
    '&' 'mut'? Expr

DerefExpr =
    '*' Expr

BangExpr =
    '!' Expr

ResourceExpr =
    ('move' | 'copy') Expr

BinExpr =
    lhs:Expr
    op:(
    '||' | '&&'
    | '==' | '!=' | '<=' | '>=' | '<' | '>'
    | '+' | '*' | '-' | '/' | '%' | '<<' | '>>' | '^' | '|' | '&'
    | '=' | '+=' | '/=' | '*=' | '%=' | '>>=' | '<<=' | '-=' | '|=' | '&=' | '^=' | '==>'
    )
    rhs:Expr

DotExpr =
    receiver_expr:Expr '.' NameRef

MethodOrDotExpr =
    MethodCallExpr | DotExpr

IndexExpr =
    base_expr:Expr '[' arg_expr:Expr ']'

AbortExpr =
    'abort' Expr?

StructLit =
    Path StructLitFieldList

StructLitFieldList =
    '{' fields:(StructLitField (',' StructLitField)* ','?)? '}'

StructLitField =
    (NameRef ':')? Expr

ParenExpr =
    '(' Expr ')'

UnitExpr =
    '(' ')'

IfExpr =
    'if' Condition then_branch:BlockOrInlineExpr ('else' else_branch:BlockOrInlineExpr)?

WhileExpr =
    LabelDecl? 'while' Condition loop_body_expr:BlockOrInlineExpr

Condition =
    '(' Expr ')'

LoopExpr =
    LabelDecl? 'loop' loop_body_expr:BlockOrInlineExpr

ForExpr =
    LabelDecl? 'for' ForCondition loop_body_expr:BlockOrInlineExpr

ForCondition =
    '(' IdentPat 'in' Expr ')'

LoopLike =
    LoopExpr | WhileExpr | ForExpr

BreakExpr =
    'break' Label?

ContinueExpr =
    'continue' Label?

ReturnExpr =
    'return' Expr?

CastExpr =
    Expr 'as' Type

LabelDecl =
    'quote_ident' ':'

Label =
    'quote_ident'

LambdaExpr =
    LambdaParamList (body_expr:Expr)?

LambdaParamList =
    '|' lambda_params:(LambdaParam (',' LambdaParam)* ','?)? '|'

LambdaParam =
    (IdentPat | WildcardPat) (':' Type)?

IsExpr =
    Expr 'is' types:(Type ('|' Type)*)

MatchExpr =
    'match' '(' Expr ')' MatchArmList

MatchArmList =
    '{' MatchArm* '}'

MatchArm =
    Pat MatchGuard? '=>' Expr ','?

MatchGuard =
    'if' Expr

AnyCallExpr =
    CallExpr | MethodCallExpr | AssertMacroExpr

CallExpr =
    Expr ValueArgList

MethodCallExpr =
    receiver_expr:Expr '.' NameRef ('::' TypeArgList)? ValueArgList

AssertMacroExpr =
    'ident' '!' ValueArgList

RangeExpr =
    start_expr:Expr '..' end_expr:Expr

VectorLitExpr =
    'ident' TypeArgList? '[' arg_exprs:(Expr (',' Expr)* ','?)? ']'

TupleExpr =
    '(' exprs:(Expr*) ')'

MethodOrPath =
    MethodCallExpr | Path

ValueArgList =
    '(' args:(ValueArg (',' ValueArg)* ','?)? ')'

ValueArg =
    Expr

PathExpr =
    Path

Path =
    (qualifier:Path '::')? segment:PathSegment

PathSegment =
    PathAddress | (NameRef TypeArgList? )

PathAddress =
    ValueAddress

GenericElement =
    Fun
    | SpecFun
    | SpecInlineFun
    | Struct
    | Enum
    | Schema
    | GlobalVariableDecl

TypeParamList =
    '<' type_parameters:(TypeParam (',' TypeParam)* ','?)? '>'

TypeParam =
    'phantom'? Name AbilityBoundList?

AbilityBoundList =
    ':' abilities:(Ability (',' Ability)* ','?)?

TypeArgList =
    '<' type_arguments:(TypeArg (',' TypeArg)* ','?)? '>'

TypeArg =
    Type

Attr =
  '#' '!'? '[' AttrItem ']'

AttrItem =
    Path '=' Expr

NameLike =
    Name | NameRef

Name =
    'ident'

// not present in syntax tree
AddressRef =
    NamedAddress | ValueAddress

NamedAddress =
    'ident'

ValueAddress =
    'int_number'

NameRef =
    'ident' | 'int_number'

Literal =
    'int_number' | 'byte_string' | 'hex_string' | 'true' | 'false' | AddressLit

AddressLit = '@' (NamedAddress | ValueAddress)

// -------------------------- Specifications

ModuleSpec =
    Attr* 'spec' Path '{' UseStmt* Item* '}'

ItemSpec =
    Attr* 'spec' ('module' | (ItemSpecRef ItemSpecTypeParamList? ItemSpecParamList?)) spec_block:BlockExpr

ItemSpecRef = NameRef

ItemSpecTypeParamList =
    '<' (ItemSpecTypeParam (',' ItemSpecTypeParam)* ','?)? '>'

ItemSpecParamList =
    '(' (ItemSpecParam (',' ItemSpecParam)* ','?)? ')'

ItemSpecTypeParam =
    NameRef

ItemSpecParam =
    IdentPat (':' Type)?

SpecFun =
    Attr*
    'spec' 'native'? 'fun' Name TypeParamList? ParamList RetType?
    (spec_block:BlockExpr | ';')

SpecInlineFun =
    Attr*
    'native'? 'fun' Name TypeParamList? ParamList RetType?
    (spec_block:BlockExpr | ';')

AnyFun =
    Fun | SpecFun | SpecInlineFun

Schema =
    Attr*
    'spec' 'schema' Name TypeParamList?
    spec_block:BlockExpr

SchemaField =
    Attr* 'local'? IdentPat ':' Type ';'

IncludeSchema =
    'include' SpecPredicatePropertyList? IncludeExpr ';'

IncludeExpr =
    SchemaIncludeExpr | AndIncludeExpr | ImplyIncludeExpr | IfElseIncludeExpr

SchemaIncludeExpr =
    SchemaLit

AndIncludeExpr =
    left_schema_lit:SchemaLit and_op:'&&' right_schema_lit:SchemaLit

ImplyIncludeExpr =
    Expr '==>' SchemaLit

IfElseIncludeExpr =
    'if' Condition then_schema_lit:SchemaLit 'else' else_schema_lit:SchemaLit

SchemaLit =
    Path SchemaLitFieldList?

SchemaLitFieldList =
    '{' fields:(SchemaLitField (',' SchemaLitField)* ','?)? '}'

SchemaLitField =
    (NameRef ':')? Expr

GlobalVariableDecl =
    Attr* 'global' Name TypeParamList? ':' Type ('=' Expr)? ';'

SpecPredicateStmt =
    ('assert' | 'assume' | 'requires' | 'ensures' | 'decreases' | 'modifies')
    SpecPredicatePropertyList?
    Expr ';'

InvariantStmt =
    'invariant' spec_type_param_list:TypeParamList? 'update'? SpecPredicatePropertyList? Expr ';'

AbortsIfStmt =
    'aborts_if' SpecPredicatePropertyList? Expr AbortsIfWith? ';'

AbortsIfWith =
    'with' Expr

AbortsWithStmt =
    'aborts_with' SpecPredicatePropertyList? '(' exprs:(Expr (',' Expr)* ','?)? ')' ';'

PragmaStmt =
    'pragma' attr_items:(PragmaAttrItem (',' PragmaAttrItem)* ','?)? ';'

PragmaAttrItem =
    'ident' ('=' Expr)?

SpecPredicatePropertyList =
    '[' properties:(SpecPredicateProperty (',' SpecPredicateProperty)* ','?)? ']'

SpecPredicateProperty =
    'ident' '=' Literal

QuantExpr =
    ForallExpr | ExistsExpr | ChooseExpr

ForallExpr =
    'forall' QuantBindingList WhereExpr? ':' Expr

ExistsExpr =
    'exists' QuantBindingList WhereExpr? ':' Expr

ChooseExpr =
    'choose' 'min'? QuantBindingList WhereExpr?

QuantBindingsOwner =
    ForallExpr | ExistsExpr | ChooseExpr

QuantBindingList =
    bindings:(QuantBinding (',' QuantBinding)* ','?)?

QuantBinding =
    IdentPat ('in' Expr) | (':' Type)

WhereExpr =
    'where' Expr

AxiomStmt =
    'axiom' spec_type_param_list:TypeParamList? SpecPredicatePropertyList? Expr ';'

ApplySchema =
    'apply' SchemaLit ApplyTo ApplyExcept? ';'

ApplyTo =
    'to' '(' wildcards:(WildcardPattern (',' WildcardPattern)* ','?)? ')'

ApplyExcept =
    'except' '(' wildcards:(WildcardPattern (',' WildcardPattern)* ','?)? ')'

WildcardPattern =
    WildcardPatternModifier? 'wildcard_ident' spec_type_param_list:TypeParamList?

WildcardPatternModifier =
    'public' | 'internal'
