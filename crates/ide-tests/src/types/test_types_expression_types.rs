//! Generated by `cargo testgen`, do not edit by hand.

use crate::types::check_expr_type;

// language=Move
#[test]
fn test_for_expr_index_partial() {
    check_expr_type(
        r#"
module 0x1::m {
    fun main() {
        for (i in ) {
            i;
          //^ <unknown>  
        };
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_unknown_does_not_influence_integer_type_for_function_for_rhs() {
    check_expr_type(
        r#"
module 0x1::option {
    fun some<Element>(e: Element): Element { e }
    fun main() {
        let unknown/*: unknown*/ = unknown_variable;
        let a2 = 1;
        unknown == some(a2);
                   //^ integer
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_nested_lambda_expr() {
    check_expr_type(
        r#"
module 0x1::m {
    fun call<Element>(g: || |Element| Element) {}
    fun main() {
        let g = || { let f = |m| m; f };
        call(|| { |m: u8| m });
                        //^ u8  
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_integer_type_of_shift_right() {
    check_expr_type(
        r#"
module 0x1::m {
    fun main() {
        let a = 1u8;
        (a >> 32);
      //^ u8  
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_abort_expr_never_type() {
    check_expr_type(
        r#"
module 0x1::m {
    fun main() {
        abort 1  
        //^ <never>
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_tuple_type() {
    check_expr_type(
        r#"
module 0x1::M {
    fun m() {
        (1u64, 1u64);
      //^ (u64, u64)  
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_struct_unpacking_type() {
    check_expr_type(
        r#"
module 0x1::m {
    struct S<CoinType> { amount: CoinType }
    fun call<CallCoinType>(s: S<CallCoinType>) {
        let S { amount: my_amount } = s;
        my_amount;
        //^ CallCoinType
    }
}               
"#,
    )
}

// language=Move
#[test]
fn test_incomplete_range_expr() {
    check_expr_type(
        r#"
module 0x1::m {
    spec module {
        let a = 1..;
        a;
      //^ range<num>  
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_vector_lit_with_inferred_type_from_call_expr() {
    check_expr_type(
        r#"
module 0x1::main {
    fun call(a: vector<u8>) {}
    fun main() {
        let vv = vector[];
        call(vv);
        vv;
       //^ vector<u8>   
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_less_expr() {
    check_expr_type(
        r#"
script {
    fun main() {
        (1 < 1);
      //^ bool
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_for_expr_index_range_expr_int_type() {
    check_expr_type(
        r#"
module 0x1::m {
    fun main() {
        for (i in 1..10) {
            i;
          //^ integer  
        };
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_parens_type() {
    check_expr_type(
        r#"
module 0x1::main {
    fun call(a: (u8)) {
        a;
      //^ u8  
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_infer_match_expr_variant_rhs() {
    check_expr_type(
        r#"
module 0x1::m {
    enum S { One, Two }
    fun main(s: S) {
        match (s) {
            S::One => s
                    //^ 0x1::m::S
        }
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_infer_generic_enum_call_expr_type() {
    check_expr_type(
        r#"
module 0x1::m {
    enum BigOrderedMap<K: store, V: store> has store { BPlusTreeMap }
    public native fun borrow<K: drop + copy + store, V: store>(self: &BigOrderedMap<K, V>, key: &K): &V;
    fun main() {
        let map = BigOrderedMap<vector<u8>, vector<u8>>::BPlusTreeMap;
        borrow(&map, &vector[1]);
        //^ &vector<u8>
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_schema_field_type() {
    check_expr_type(
        r#"
module 0x1::M {
    spec schema SS {
        val: num;
        val;
        //^ num
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_positional_field_lookup_generic_type() {
    check_expr_type(
        r#"
module 0x1::m {
    struct S<T>(T)
    fun main() {
        let s = S(true);
        s.0;
        //^ bool
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_call_expr_with_implicit_type_and_type_error() {
    check_expr_type(
        r#"
module 0x1::main {
    fun call<T>(a: T, b: T): T {
        b        
    }    
    fun main() {
        let aa = call(1u8, 1u128);
        aa;
      //^ u8  
    }    
}        
"#,
    )
}

// language=Move
#[test]
fn test_imported_table_with_alias() {
    check_expr_type(
        r#"
module 0x1::table_with_length {
    struct TableWithLength<phantom K: copy + drop, phantom V> has store {}
}
module 0x1::pool {
    use 0x1::table_with_length::TableWithLength as Table;
    struct Pool has store {
        shares: Table<address, u128>,
    }

    fun add_shares(pool: &mut Pool) {
        let shares = pool.shares;
        shares;
        //^ 0x1::table_with_length::TableWithLength<address, u128>
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_struct_field_vector_u8_in_spec() {
    check_expr_type(
        r#"
module 0x1::M {
    struct S { vec: vector<u8> } 
    spec module {
        let s = S { vec: b"" };
        s.vec
        //^ vector<num>
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_if_expr_with_incompatible_else() {
    check_expr_type(
        r#"
module 0x1::M {
    fun m() {
        let a = if (true) 1 else true;
        a;
      //^ <unknown>
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_unknown_type_for_tuple_struct_pattern_if_more_than_number_of_fields() {
    check_expr_type(
        r#"
module 0x1::m {
    struct S(u8);
    fun main(s: S) {
        let S ( field1, field2 ) = s;
        field2;
        //^ <unknown>
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_lambda_expr() {
    check_expr_type(
        r#"
module 0x1::m {
    inline fun main<Element>(f: |Element|) {
        f;
      //^ |Element| -> ()  
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_forall_quantifier_range_vector_binding_expr() {
    check_expr_type(
        r#"
module 0x1::m {
    fun call() {}
    spec call {
        forall i in vector[true, false]: i;
                                       //^ bool
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_bit_xor() {
    check_expr_type(
        r#"
module 0x1::main {
    fun main() {
        (1 ^ 1);
      //^ integer  
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_type_of_binding_of_tuple_of_single_variable() {
    check_expr_type(
        r#"
module 0x1::m {
    fun call() {
        let (a) = 1;
        a;
      //^ integer  
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_infer_match_variant_field_with_reference_shorthand() {
    check_expr_type(
        r#"
module 0x1::m {
    struct Inner { field: u8 }
    enum Outer { None { inner: Inner } }

    public fun non_exhaustive(o: &Outer) {
        match (o) {
            None { inner } => inner
                              //^ &0x1::m::Inner
        }
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_call_expr_from_alias() {
    check_expr_type(
        r#"
module 0x1::string {
    public fun call(): u8 { 1 }
}        
module 0x1::main {
    use 0x1::string::call as mycall;
    fun main() {
        let a = mycall();
        a;
      //^ u8  
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_struct_field_as_vector() {
    check_expr_type(
        r#"
module 0x1::M {
    struct NFT {}
    struct Collection { nfts: vector<NFT> }
    fun m(coll: Collection) {
        (coll.nfts);
      //^ vector<0x1::M::NFT>  
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_return_value_from_block() {
    check_expr_type(
        r#"
module 0x1::M {
    fun main() {
        let a = { 1u8 };
        a;
      //^ u8  
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_msl_mut_ref_is_type() {
    check_expr_type(
        r#"
module 0x1::M {
    struct S {}
    fun ref_mut(): &mut S {}
    spec module {
        let a = ref_mut();
        a;
      //^ 0x1::M::S
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_integer_type_of_shift_left() {
    check_expr_type(
        r#"
module 0x1::m {
    fun main() {
        let a = 1u8;
        (a << 32);
      //^ u8  
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_no_error_for_eq_exprs_when_combining_unknown_type_items() {
    check_expr_type(
        r#"
module 0x1::option {
    struct Option<Element> has copy, drop, store {
        vec: vector<Element>
    }
    fun some<Element>(e: Element): Option<Element> { Option { vec: vector[e] } }
    fun main() {
        let unknown/*: unknown*/ = unknown_variable;
        let a2 = @0x1;
        unknown != some(a2);
        unknown == some(a2);
                   //^ 0x1::option::Option<address>
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_generic_enum_variant_with_positional_fields() {
    check_expr_type(
        r#"
module 0x1::m {
    enum S<T> { One(T, T) }
    fun main() {
        let a = S<u8>::One(1, 1);
        a;
      //^ 0x1::m::S<u8>  
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_infer_two_param_lambda_expr() {
    check_expr_type(
        r#"
module 0x1::m {
    inline fun for_each<Element>(v: vector<Element>, f: |Element, Element|) {}
    fun main() {
        for_each(vector[1, 2, 3], |elem1, elem2| { elem2; });
                                                  //^ integer
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_if_else_return() {
    check_expr_type(
        r#"
module 0x1::M {
    fun main() {
        if (true) { return 1 } else { return 2 };
      //^ <never>  
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_num_type() {
    check_expr_type(
        r#"
module 0x1::m {
    spec module {
        let a: num;
        a;
      //^ num  
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_lambda_expr_from_assigned_variable() {
    check_expr_type(
        r#"
module 0x1::m {
    inline fun main<Element>(f: |Element|) {
        let g = f;
        g;
      //^ |Element| -> ()  
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_deref_address_in_lambda() {
    check_expr_type(
        r#"
module 0x1::vector {
    public fun enumerate_ref<Element>(self: vector<Element>, _f: |&Element| Element) {}
}
module 0x1::m {
    fun main() {
        let f = |to| (*to);
                      //^ &address
        vector[@0x1].enumerate_ref(f);
    }
}     
"#,
    )
}

// language=Move
#[test]
fn test_unpack_tuple_of_structs() {
    check_expr_type(
        r#"
    module 0x1::M {
    struct S { val: u8 }
    fun s(): (S, S) { (S { val: 10 }, S { val: 10 }) }
    fun main() {
        let (s, t) = s();
        s;
      //^ 0x1::M::S   
    }
}            
"#,
    )
}

// language=Move
#[test]
fn test_if_expr() {
    check_expr_type(
        r#"
module 0x1::M {
    fun m() {
        let a = if (true) 1 else 2;
        a;
      //^ integer 
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_tuple_result_type_of_spec_function_with_generic() {
    check_expr_type(
        r#"
module 0x1::m {
    struct Option<Element> has copy, drop, store {
        vec: vector<Element>
    }
    fun upsert(): Option<u8> { Option { vec: vector[1] } }
    spec upsert {
        result;
        //^ 0x1::m::Option<num>
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_integer_inference_with_spec_blocks_outside_block() {
    check_expr_type(
        r#"
module 0x1::main {
    spec fun get_num(): num { 1 }
    fun main() {
        let myint = 1;
        myint + 1u8;
        spec {
            myint + get_num();
        };
        myint;
        //^ u8
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_lambda_variable_vector() {
    check_expr_type(
        r#"
module 0x1::m {
    fun call<Element>(i: Element, f: |vector<Element>|) {}
    fun main() {
        let f = |amounts| {
            let amount = amounts[0];
            amount;
            //^ u8
        };
        call(1u8, f);
        
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_bang_expr() {
    check_expr_type(
        r#"
script {
    fun main() {
        !true;
      //^ bool
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_add_expr_with_untyped_and_typed_integer_reversed() {
    check_expr_type(
        r#"
module 0x1::M {
    fun main() {
        (1u8 + 1);
      //^ u8  
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_sub_expr() {
    check_expr_type(
        r#"
script {
    fun main() {
        (1u8 - 1u8);
      //^ u8
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_dot_access_to_primitive_field() {
    check_expr_type(
        r#"
module 0x1::M {
    struct S { addr: address }
    fun main() {
        let s = S { addr: @0x1 };
        ((&s).addr);
      //^ address 
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_enum_variant_struct_as_value_with_generics() {
    check_expr_type(
        r#"
module 0x1::m {
    enum Option<T> { Some { element: T } }
    fun main() {
        let a = Option::Some { element: 1u8 };
        a;
      //^ 0x1::m::Option<u8>  
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_lambda_variable_struct() {
    check_expr_type(
        r#"
module 0x1::m {
    struct S { val: u8 }
    fun call_on<Element>(i: Element, f: |Element|) {}
    fun main() {
        let select_val = |s| {
            s.val;
             //^ u8
        };
        let s = S { val: 1 };
        call_on(s, select_val);
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_infer_match_expr_variant_field() {
    check_expr_type(
        r#"
module 0x1::m {
    enum S { One { field: u8 }, Two { field: u8 } }
    fun main(s: S) {
        match (s) {
            One => s.field,
                    //^ u8
        }
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_for_expr_index_with_range_as_variable() {
    check_expr_type(
        r#"
module 0x1::m {
    fun main() {
        let vec = 1..10;
        for (i in vec) {
            i;
          //^ integer  
        }
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_vector_lit_with_implicit_type_and_type_error() {
    check_expr_type(
        r#"
module 0x1::main {
    fun main() {
        let vv = vector[1u8, 1u64];
        vv;
       //^ vector<u8>   
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_dot_expr_with_dot_expr_incomplete_1() {
    check_expr_type(
        r#"
module 0x1::m {
    struct Pool { field: u8 }
    fun main(pool: &mut Pool) {
        pool.field
        //^ &mut 0x1::m::Pool
        pool.field
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_positional_field_lookup_type() {
    check_expr_type(
        r#"
module 0x1::m {
    struct S(u8);
    fun main(s: S) {
        s.0;
        //^ u8
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_old_function_type_for_spec() {
    check_expr_type(
        r#"
module 0x1::M {
    struct S {}
    fun call(a: S) {}
    spec call {
        old(a);
      //^ 0x1::M::S 
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_const_int_in_spec() {
    check_expr_type(
        r#"
module 0x1::M {
    const MY_INT: u8 = 1;
    spec module {
        MY_INT;
        //^ num
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_infer_let_post_binding_pat_type_in_spec_block_arbitrary_order() {
    check_expr_type(
        r#"
module 0x1::m {
    spec module {
        addr;
        //^ address
        let post addr = @0x1;
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_for_expr_index_range_expr_bool_type() {
    check_expr_type(
        r#"
module 0x1::m {
    fun main() {
        for (i in false..true) {
            i;
          //^ bool  
        };
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_return_type_of_unit_returning_function() {
    check_expr_type(
        r#"
module 0x1::M {
    fun call(): () {}
    fun m() {
        call();
      //^ ()
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_outer_variable_in_nested_lambda() {
    check_expr_type(
        r#"
module 0x1::m {
    fun main() {
        let ind = 1;
        || {
            || {
                ind;
               //^ integer     
            };
        }
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_dot_expr_chained() {
    check_expr_type(
        r#"
module 0x1::m {
    struct Pool { field: u8 }
    fun main(pool: &mut Pool) {
        pool.
        //^ &mut 0x1::m::Pool
        pool.field;
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_global_variable_for_schema() {
    check_expr_type(
        r#"
module 0x1::m {
    spec module {
        global supply: num;
    }
    spec schema MySchema {
        ensures supply == 1;
                  //^ num   
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_enum_variant_for_tuple_struct_literal() {
    check_expr_type(
        r#"
module 0x1::m {
    enum S<T> { One(T) }
    fun main() {
        let s = S::One(true);
        s; 
      //^ 0x1::m::S<bool>   
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_msl_ref_is_type() {
    check_expr_type(
        r#"
module 0x1::M {
    struct S {}
    fun ref(): &S { &S {} }
    spec module {
        let a = ref();
        a;
      //^ 0x1::M::S
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_result_of_return_type_of_function_spec() {
    check_expr_type(
        r#"
module 0x1::m {
    public fun get_fees_distribution(): u128 {
        1
    }
    spec get_fees_distribution {
        aborts_if false;
        ensures result == 1;
                 //^ num
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_lambda_expr_integer_return_type() {
    check_expr_type(
        r#"
module 0x1::m {
    inline fun main<Element>(e: Element, f: |Element| u8) {
        f(e);
      //^ u8  
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_types_for_fields_in_tuple_struct_pattern() {
    check_expr_type(
        r#"
module 0x1::m {
    struct S(u8, u8);
    fun main(s: S) {
        let S ( field1, field2 ) = s;
        field1;
        //^ u8
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_compound_assignment_returns_unit_type() {
    check_expr_type(
        r#"
module 0x1::m {
    fun main() {
        let a = 1;
        (a += 1)
      //^ ()  
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_int2bv_and_bv_type() {
    check_expr_type(
        r#"
module 0x1::m {
    fun call() {}
    spec call {
        let a = int2bv(100);
        a;
      //^ bv  
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_vector_lit_with_explicit_type() {
    check_expr_type(
        r#"
module 0x1::main {
    fun main() {
        let vv = vector<u8>[];
        vv;
       //^ vector<u8>   
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_struct_literal_expr_with_unresolved_type_param() {
    check_expr_type(
        r#"
module 0x1::M {
    struct R<CoinType> {}
    fun main() {
        R {};
      //^ 0x1::M::R<<unknown>>  
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_integer_type_inference_with_equality_expr() {
    check_expr_type(
        r#"
module 0x1::m {
    fun main() {
        let a = 1;
        a == 2u8;
        a;
      //^ u8  
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_integer_type_inference_with_ordering_expr() {
    check_expr_type(
        r#"
module 0x1::m {
    fun main() {
        let a = 1;
        a > 2u8;
        a;
      //^ u8  
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_deref_type_with_generics() {
    check_expr_type(
        r#"
module 0x1::m {
    struct Coin<CoinType> { val: u8 }
    struct BTC {}
    fun main() {
        let a = &mut Coin { val: 10 };
        let b: Coin<BTC> = *a;
        a;
      //^ &mut 0x1::m::Coin<0x1::m::BTC>  
    }        
} 
"#,
    )
}

// language=Move
#[test]
fn test_deref_expr() {
    check_expr_type(
        r#"
module 0x1::M {
    fun main(s: &signer) {
        *s;
      //^ signer 
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_index_of_spec_function_is_not_resolved_so_integer_parameter_cannot_be_inferred() {
    check_expr_type(
        r#"
module 0x1::m {
    fun main() {
        let vect = vector[1u8];
        let ind = 1;
        index_of(vect, ind);
        ind;
        //^ integer
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_type_for_tuple_struct_literal() {
    check_expr_type(
        r#"
module 0x1::m {
    struct S<T>(T);
    fun main() {
        let s = S(true);
        s; 
      //^ 0x1::m::S<bool>   
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_type_of_plus_with_invalid_arguments() {
    check_expr_type(
        r#"
module 0x1::M {
    fun add(a: bool, b: bool) {
        (a + b);
      //^ <unknown>  
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_tuple_struct_destructuring_for_unknown_type() {
    check_expr_type(
        r#"
module 0x1::m {
    fun main() {
        let S(i, j) = s;
        i;
      //^ <unknown>  
    }
 }        
"#,
    )
}

// language=Move
#[test]
fn test_bit_shift_right() {
    check_expr_type(
        r#"
module 0x1::main {
    fun main() {
        (1 >> 1);
      //^ integer  
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_field_type_for_tuple_struct_pattern_if_more_than_number_of_fields_but_field_is_there() {
    check_expr_type(
        r#"
module 0x1::m {
    struct S(u8);
    fun main(s: S) {
        let S ( field1, field2 ) = s;
        field1;
        //^ u8
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_infer_identity_lambda_expr() {
    check_expr_type(
        r#"
module 0x1::m {
    inline fun for_each<Element>(v: vector<Element>, f: |Element| Element) {}
    fun main() {
        for_each(vector[1, 2, 3], |elem| elem);
                                          //^ integer
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_ref_expr_of_function_item() {
    check_expr_type(
        r#"
module 0x1::m {
    fun call() {}
    fun main() {
        call;
      //^ <unknown>  
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_add_expr() {
    check_expr_type(
        r#"
script {
    fun main() {
        (1u8 + 1u8);
      //^ u8
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_x_string() {
    check_expr_type(
        r#"
module 0x1::M {
    fun m() {
        x"1234";
        //^ vector<u8>
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_spec_expr_with_visibility_inferred() {
    check_expr_type(
        r#"
module 0x1::m {
    spec module {
        let i = false;
        invariant [suspendable] i;
                              //^ bool
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_mutable_borrow_expr() {
    check_expr_type(
        r#"
module 0x1::M {
    fun main(s: signer) {
        &mut s;
      //^ &mut signer 
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_infer_outer_type_variable_with_lambda_body() {
    check_expr_type(
        r#"
module 0x1::vector {
    public native fun for_each_ref<Element>(self: &vector<Element>, f: |&Element|);
    public native fun contains<Element>(self: &vector<Element>, e: &Element): bool;
}
module 0x1::account {
    use 0x1::vector;
    struct Account { account_address: address }
    fun create_accounts(accounts: vector<Account>) {
        let unique_accounts = vector[];
        accounts.for_each_ref(|account| {
            assert!(
                !vector::contains(&unique_accounts, &account.account_address),
                1,
            );
        });
        unique_accounts;
        //^ vector<address>
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_type_for_tuple_struct_literal_with_multiple_type_parameters_and_explicit_type() {
    check_expr_type(
        r#"
module 0x1::m {
    struct S<T>(T, T);
    fun main() {
        let s = S<u8>(1, 1);
        s; 
      //^ 0x1::m::S<u8>   
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_nested_struct_literal_inferred_type() {
    check_expr_type(
        r#"
module 0x1::main {
    struct V<VT> { val: VT }
    struct S<ST> { val: V<ST> }
    fun main() {
        let s = S { val: V { val: 1u64 }};
        s;
      //^ 0x1::main::S<u64>  
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_recursive_type() {
    check_expr_type(
        r#"
module 0x1::main {
    struct S { val: S }
    fun main() {
        let s = S { val: };
        s;
      //^ 0x1::main::S  
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_spec_vector_slice() {
    check_expr_type(
        r#"
module 0x1::m {
    spec module {
        let v = vector[true, false];
        let slice = v[0..1];
        slice;
        //^ vector<bool>
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_range_as_variable() {
    check_expr_type(
        r#"
module 0x1::m {
    fun main() {
        let vec = 1..10;
        vec;
        //^ range<integer>
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_tuple_struct_pat_with_rest_at_the_beginning() {
    check_expr_type(
        r#"
module 0x1::m {
    struct S(u8, u8, bool);
    fun main(s: S) {
        let S(.., f1) = s;
        f1;
       //^ bool
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_forall_quantifier_range_binding_expr() {
    check_expr_type(
        r#"
module 0x1::m {
    fun call() {}
    spec call {
        forall i in 0..10: i < 20;
                         //^ num
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_item_spec_struct_field() {
    check_expr_type(
        r#"
module 0x1::m {
    struct Option<Element> has copy, drop, store {
        vec: vector<Element>
    }
    struct S { aggregator: Option<u8> }
    spec S {
        aggregator;
        //^ 0x1::m::Option<num>
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_mul_expr() {
    check_expr_type(
        r#"
script {
    fun main() {
        (1u8 * 1u8);
      //^ u8
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_borrow_expr() {
    check_expr_type(
        r#"
module 0x1::M {
    fun main(s: signer) {
        &s;
      //^ &signer 
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_add_expr_with_untyped_and_typed_integer() {
    check_expr_type(
        r#"
module 0x1::M {
    fun main() {
        (1 + 1u8);
      //^ u8  
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_binding_inside_code_block() {
    check_expr_type(
        r#"
module 0x1::main {
    fun main() {
        let b = {
            let in = 1;
            in;
          //^ integer  
        };
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_if_else_with_references_coerced_to_less_specific_one() {
    check_expr_type(
        r#"
module 0x1::M {
    struct S {}
    fun m(s: &S, s_mut: &mut S) {
        let cond = true;
        (if (cond) s_mut else s);
      //^ &0x1::M::S  
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_infer_quant_variable_in_where() {
    check_expr_type(
        r#"
module 0x1::m {}        
spec 0x1::m {
    spec Table {
        let left_length = 100;
        let left = vector[];
        let right = vector[];
        ensures forall i: u64 where i < left_length: left[i] == right[i];
                                  //^ num
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_outer_vector_inside_lambda_expr() {
    check_expr_type(
        r#"
module 0x1::m {
    fun main(amounts: vector<u8>) {
        let f = |i| {
            let amount = amounts[i];
            amount;
            //^ u8
        };
        
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_infer_integer_with_explicit_tuple_literal_type_in_assignment() {
    check_expr_type(
        r#"
module 0x1::m {
    fun call<Element>(v: Element): Element {}
    fun main() {
        let u = 1;
        let (a, b): (u8, u8);
        (a, b) = (call(u), call(u));
        u;
      //^ u8  
    }        
} 
"#,
    )
}

// language=Move
#[test]
fn test_simple_map_vector_field() {
    check_expr_type(
        r#"
module 0x1::simple_map {
    struct SimpleMap<Value> has copy, drop, store {
        data: vector<Value>,
    }

    /// Create an empty vector.
    native public fun vector_empty<Element>(): vector<Element>;
    
    public fun create<FunValue: store>(): SimpleMap<FunValue> {
        SimpleMap {
            data: vector_empty(),
        }
    }
    
    fun main() {
        let map = create<u64>();
        let map_data = &map.data;
        map_data;
        //^ &vector<u64>
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_lambda_expr_unit_type() {
    check_expr_type(
        r#"
module 0x1::m {
    inline fun main<Element>(f: |Element|) {
        f();
      //^ ()  
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_range_expr() {
    check_expr_type(
        r#"
module 0x1::m {
    spec module {
        let a = 1..10;
        a;
      //^ range<num>   
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_while_expr_returns_unit() {
    check_expr_type(
        r#"
module 0x1::M {
    fun main() {
        let a = while (true) { 1; };
        a;
      //^ <never>  
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_infer_result_for_spec() {
    check_expr_type(
        r#"
module 0x1::main {
    struct S { val: u8 }
    fun call(): S { S { val: 1 } }
    spec call {
        ensures result.val == 1;
                      //^ num
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_infer_integer_with_explicit_tuple_literal_type_in_let_statement() {
    check_expr_type(
        r#"
module 0x1::m {
    fun call<Element>(v: Element): Element {}
    fun main() {
        let u = 1;
        let (a, b): (u8, u8) = (call(u), call(u));
        u;
      //^ u8  
    }        
} 
"#,
    )
}

// language=Move
#[test]
fn test_explicit_generic_type_struct() {
    check_expr_type(
        r#"
module 0x1::M {
    struct Option<Element> {}
    fun call() {
        let a = Option<u8> {};
        a;
      //^ 0x1::M::Option<u8>  
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_type_of_fun_param_in_spec() {
    check_expr_type(
        r#"
module 0x1::M {
    fun call(addr: address) {}
    spec call {
        addr;
        //^ address
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_ref_expr_of_struct_item() {
    check_expr_type(
        r#"
module 0x1::m {
    struct S {}
    fun main() {
        S;
      //^ <unknown>  
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_less_equal_expr() {
    check_expr_type(
        r#"
script {
    fun main() {
        (1 <= 1);
      //^ bool
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_builtin_const_in_spec() {
    check_expr_type(
        r#"
module 0x1::m {
    spec module {
        assert 1 <= MAX_U128;
                       //^ num
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_spec_block_type() {
    check_expr_type(
        r#"
module 0x1::m {
    fun main() {
        spec {}
        //^ ()
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_struct_destructuring_for_unknown_type() {
    check_expr_type(
        r#"
module 0x1::m {
    fun main() {
        let S { i } = s;
        i;
      //^ <unknown>  
    }
 }        
"#,
    )
}

// language=Move
#[test]
fn test_function_with_explicit_integer_parameter_return_type() {
    check_expr_type(
        r#"
module 0x1::m {
    fun call<T>(t: T): T { t }
    fun main() {
        let a = call<u8>(1);
        a;
      //^ u8  
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_infer_match_variant_field_with_reference() {
    check_expr_type(
        r#"
module 0x1::m {
    struct Inner { field: u8 }
    enum Outer { None { inner: Inner } }

    public fun non_exhaustive(o: &Outer) {
        match (o) {
            None { inner: myinner } => myinner
                                        //^ &0x1::m::Inner
        }
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_enum_variant_destructuring_for_unknown_type() {
    check_expr_type(
        r#"
module 0x1::m {
    enum S {  }
    fun main() {
        let S::Inner { i } = s;
        i;
      //^ <unknown>  
    }
 }        
"#,
    )
}

// language=Move
#[test]
fn test_move_expr() {
    check_expr_type(
        r#"
script {
    fun main() {
        move 1u8;
      //^ u8
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_bit_or() {
    check_expr_type(
        r#"
module 0x1::main {
    fun main() {
        (1 | 1);
      //^ integer  
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_generic_enum_variant() {
    check_expr_type(
        r#"
module 0x1::m {
    enum S<phantom T> { One }
    fun main() {
        let a = S<u8>::One;
        a;
      //^ 0x1::m::S<u8>
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_integer_parameter_has_type_num_in_inline_spec_block() {
    check_expr_type(
        r#"
module 0x1::m {
    fun main(degree: u8) {
        spec {
            degree;
            //^ num
        }
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_unpack_struct_reference() {
    check_expr_type(
        r#"
module 0x1::m {
    struct Field { id: u8 }
    fun main() {
        let Field { id } = &Field { id: 1 };
        id;
       //^ &u8 
    }
}                
"#,
    )
}

// language=Move
#[test]
fn test_dot_expr_with_dot_expr_incomplete_2() {
    check_expr_type(
        r#"
module 0x1::m {
    struct Pool { field: u8 }
    fun main(pool: &mut Pool) {
        pool.unknown
        pool.field
            //^ u8
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_dot_access_to_field_with_struct_type() {
    check_expr_type(
        r#"
module 0x1::M {
    struct Addr {}
    struct S { addr: Addr }
    fun main() {
        let s = S { addr: Addr {} };
        ((&s).addr);
      //^ 0x1::M::Addr 
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_tuple_struct_pat_with_rest_in_the_middle() {
    check_expr_type(
        r#"
module 0x1::m {
    struct S(u8, u8, u8, bool);
    fun main(s: S) {
        let S(f1, .., fb) = s;
        fb;
       //^ bool
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_forall_quantifier_range_expr() {
    check_expr_type(
        r#"
module 0x1::m {
    fun call() {}
    spec call {
        forall i in 0..10: i < 20;
                    //^ range<num>
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_infer_match_expr() {
    check_expr_type(
        r#"
module 0x1::m {
    enum S { One, Two }
    fun main(s: S) {
        match (s) {
             //^ 0x1::m::S 
            One => true,
        }
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_enum_variant_as_value() {
    check_expr_type(
        r#"
module 0x1::m {
    enum Option { None }
    fun main() {
        let a = Option::None;
        a;
      //^ 0x1::m::Option  
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_result_2_of_return_tuple_in_function_spec() {
    check_expr_type(
        r#"
module 0x1::m {
    public fun get_fees_distribution(): (u128, bool) {
        (1, false)
    }
    spec get_fees_distribution {
        aborts_if false;
        ensures result_2 == 1;
                 //^ bool
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_result_1_of_return_tuple_in_function_spec() {
    check_expr_type(
        r#"
module 0x1::m {
    public fun get_fees_distribution(): (u128, u128) {
        (1, 1)
    }
    spec get_fees_distribution {
        aborts_if false;
        ensures result_1 == 1;
                 //^ num
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_binding_inside_else_block() {
    check_expr_type(
        r#"
module 0x1::main {
    fun main() {
        if (true) {} else {
            let in = 1;
            in;
          //^ integer  
        }
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_borrow_expr_of_dot_access() {
    check_expr_type(
        r#"
module 0x1::M {
    struct Addr {}
    struct S { addr: Addr }
    fun main() {
        let s = S { addr: Addr {} };
        &mut s.addr;
      //^ &mut 0x1::M::Addr 
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_msl_num() {
    check_expr_type(
        r#"
module 0x1::M {
    spec module {
        1;
      //^ num  
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_mod_expr() {
    check_expr_type(
        r#"
script {
    fun main() {
        (1u8 % 10);
      //^ u8
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_infer_lambda_identity_type() {
    check_expr_type(
        r#"
module 0x1::vector {
    /// Apply the function to each element in the vector, consuming it.
    public inline fun for_each<Element>(self: vector<Element>, _f: |Element| Element) {
    }
}
module 0x1::m {
    fun main() {
        let f = |m| m;
        vector[1u8].for_each(f);
        f;
      //^ |u8| -> u8                
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_infer_vector_type_binding_of_spec_fun() {
    check_expr_type(
        r#"
module 0x1::m {
    spec module {
        fun eq_push_back<Element>(v1: vector<Element>, v2: vector<Element>, e: Element): bool {
            let res = 
            (len(v1) == len(v2) + 1 &&
                v1[len(v1)-1] == e &&
                v1[0..len(v1)-1] == v2[0..len(v2)]);
            res
            //^ bool
        }
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_infer_index_expr_of_generic_call_expr() {
    check_expr_type(
        r#"
module 0x1::m {
    fun identity<T>(t: T): T { t }
    fun main() {
        (identity(vector[1])[0]);
      //^ integer   
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_lambda_expr_returning_type() {
    check_expr_type(
        r#"
module 0x1::m {
    inline fun main<Element>(f: |Element| Element) {
        f();
      //^ Element  
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_pattern_with_rest() {
    check_expr_type(
        r#"
module 0x1::m {
    struct S { f1: u8, f2: u8 }
    fun main(s: S) {
        let S { f1, .. } = s;
        f1;
       //^ u8
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_integer_inference_with_spec_blocks_inside_block() {
    check_expr_type(
        r#"
module 0x1::main {
    spec fun get_num(): num { 1 }
    fun main() {
        let myint = 1;
        myint + 1u8;
        spec {
            myint
            //^ num
        };
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_if_expr_without_else() {
    check_expr_type(
        r#"
module 0x1::M {
    fun m() {
        let a = if (true) 1;
        a;
      //^ () 
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_vector_lit_with_inferred_type() {
    check_expr_type(
        r#"
module 0x1::main {
    fun main() {
        let vv = vector[1u8];
        vv;
       //^ vector<u8>   
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_infer_no_return_lambda_expr() {
    check_expr_type(
        r#"
module 0x1::m {
    inline fun for_each<Element>(v: vector<Element>, f: |Element|) {}
    fun main() {
        for_each(vector[1, 2, 3], |elem| { elem; });
                                          //^ integer
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_bit_and() {
    check_expr_type(
        r#"
module 0x1::main {
    fun main() {
        (1 & 1);
      //^ integer  
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_global_function_type_for_spec() {
    check_expr_type(
        r#"
module 0x1::M {
    struct S has key {}
    spec module {
        let a = global<S>(@0x1);
        a;
      //^ 0x1::M::S 
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_recursive_type_with_nested_struct() {
    check_expr_type(
        r#"
module 0x1::main {
    struct S { val: vector<vector<S>> }
    fun main() {
        let s = S { val: };
        s;
      //^ 0x1::main::S  
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_infer_single_param_lambda_two_param_expected() {
    check_expr_type(
        r#"
module 0x1::m {
    inline fun for_each<Element>(v: vector<Element>, f: |Element, Element|) {}
    fun main() {
        for_each(vector[1, 2, 3], |elem| { elem; });
                                            //^ integer
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_call_expr_with_explicit_type_and_type_error() {
    check_expr_type(
        r#"
module 0x1::main {
    fun call<T>(a: T, b: T): T {
        b        
    }    
    fun main() {
        let aa = call<u8>(1u64, 1u128);
        aa;
      //^ u8  
    }    
}        
"#,
    )
}

// language=Move
#[test]
fn test_unpack_struct_mut_reference() {
    check_expr_type(
        r#"
module 0x1::m {
    struct Field { id: u8 }
    fun main() {
        let Field { id } = &mut Field { id: 1 };
        id;
       //^ &mut u8 
    }
}                
"#,
    )
}

// language=Move
#[test]
fn test_infer_match_expr_variant_field_destructuring_rhs_full() {
    check_expr_type(
        r#"
module 0x1::m {
    enum S { One { field: u8 }, Two }
    fun main(s: S) {
        match (s) {
            One { field: myfield } => myfield,
                                     //^ u8
        }
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_type_of_u8_fun_param_in_spec() {
    check_expr_type(
        r#"
module 0x1::M {
    fun call(n: u8) {}
    spec call {
        n;
      //^ num  
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_infer_lambda_noop_type() {
    check_expr_type(
        r#"
module 0x1::vector {
    /// Apply the function to each element in the vector, consuming it.
    public inline fun for_each<Element>(self: vector<Element>, _f: |Element|) {
    }
}
module 0x1::m {
    fun main() {
        let f = |m|;
        vector[1u8].for_each(f);
        f;
      //^ |u8| -> ()                
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_exists_quantifier_expr() {
    check_expr_type(
        r#"
module 0x1::m {
    fun call() {}
    spec call {
        let a = exists i in 0..10: i == 1;
        a;
      //^ bool  
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_vector_lit_with_inferred_integer_type() {
    check_expr_type(
        r#"
module 0x1::main {
    fun main() {
        let vv = vector[1];
        vv;
       //^ vector<integer>   
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_no_error_with_type_inference_with_pragma() {
    check_expr_type(
        r#"
module 0x1::m {
    struct Table { length: u64 }
}        
spec 0x1::m {
    spec Table {
        pragma map_length = length;
                            //^ num
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_nested_struct_literal_explicit_type() {
    check_expr_type(
        r#"
module 0x1::main {
    struct V<T> { val: T }
    struct S<T> { val: V<T> }
    fun main() {
        let s = S { val: V<u64> { val: }};
        s;
      //^ 0x1::main::S<u64>  
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_greater_expr() {
    check_expr_type(
        r#"
script {
    fun main() {
        (1 > 1);
      //^ bool
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_break_expr_never_type() {
    check_expr_type(
        r#"
module 0x1::m {
    fun main() {
        while (true) {
            break  
            //^ <never>
        }
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_unpack_struct_into_field() {
    check_expr_type(
        r#"
    module 0x1::M {
    struct S { val: u8 }
    fun s(): S { S { val: 10 } }
    fun main() {
        let s = s();
        s;
      //^ 0x1::M::S   
    }
}            
"#,
    )
}

// language=Move
#[test]
fn test_cast_expr() {
    check_expr_type(
        r#"
script {
    fun main() {
        (1 as u8);
      //^ u8
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_binding_inside_if_block() {
    check_expr_type(
        r#"
module 0x1::main {
    fun main() {
        if (true) {
            let in = 1;
            in;
          //^ integer  
        }
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_type_for_tuple_struct_literal_with_multiple_type_parameters() {
    check_expr_type(
        r#"
module 0x1::m {
    struct S<T, U>(T, U);
    fun main() {
        let s = S(true, 1u8);
        s; 
      //^ 0x1::m::S<bool, u8>   
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_bit_shift_left() {
    check_expr_type(
        r#"
module 0x1::main {
    fun main() {
        (1 << 1);
      //^ integer  
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_vector_lit_inside_specs() {
    check_expr_type(
        r#"
module 0x1::main {
    spec module {
        let vv = vector[1];
        vv;
       //^ vector<num>   
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_unknown_does_not_influence_integer_type_for_function_for_lhs() {
    check_expr_type(
        r#"
module 0x1::option {
    fun some<Element>(e: Element): Element { e }
    fun main() {
        let unknown/*: unknown*/ = unknown_variable;
        let a2 = 1;
        some(a2) == unknown;
        //^ integer
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_tuple_enum_variant_destructuring_for_unknown_type() {
    check_expr_type(
        r#"
module 0x1::m {
    enum S {}
    fun main() {
        let S::Inner(i, j) = s;
        i;
      //^ <unknown>                   
    }
 }        
"#,
    )
}

// language=Move
#[test]
fn test_struct_lit_with_generic_of_type_with_incorrect_abilities() {
    check_expr_type(
        r#"
module 0x1::M {
    struct S<phantom Message: store> {}
    struct R has copy {  }
    fun main() {
        S<R> {};
      //^ 0x1::M::S<0x1::M::R>  
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_infer_let_binding_pat_type_in_spec_block_arbitrary_order() {
    check_expr_type(
        r#"
module 0x1::m {
    spec module {
        addr;
        //^ address
        let addr = @0x1;
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_copy_expr() {
    check_expr_type(
        r#"
script {
    fun main() {
        copy 1u8;
      //^ u8
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_vector_lit_with_explicit_type_and_type_error() {
    check_expr_type(
        r#"
module 0x1::main {
    fun main() {
        let vv = vector<u8>[1u64];
        vv;
       //^ vector<u8>   
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_msl_callable_num() {
    check_expr_type(
        r#"
module 0x1::M {
    fun call(): u8 { 1 }
    spec module {
        call();
        //^ num
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_infer_quant_variable_in_quant_body() {
    check_expr_type(
        r#"
module 0x1::m {}        
spec 0x1::m {
    spec Table {
        let left_length = 100;
        let left = vector[];
        let right = vector[];
        ensures forall i: u64 where i < left_length: left[i] == right[i];
                                                        //^ num
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_if_expr_return_type() {
    check_expr_type(
        r#"
module 0x1::m {
    enum S1 { One, Two }
    fun main(s: S1) {
        let ret = s is One;
        ret;
      //^ bool 
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_ref_expr_of_schema_item() {
    check_expr_type(
        r#"
module 0x1::m {
    spec schema S {}
    fun main() {
        S;
      //^ <unknown>  
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_greater_equal_expr() {
    check_expr_type(
        r#"
script {
    fun main() {
        (1 >= 1);
      //^ bool
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_enum_variant_for_tuple_struct_literal_field() {
    check_expr_type(
        r#"
module 0x1::m {
    enum S<T> { One(T) }
    fun main() {
        let s = S::One(true);
        s.0; 
        //^ bool   
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_type_of_binding_of_tuple_of_single_variable_with_comma() {
    check_expr_type(
        r#"
module 0x1::m {
    fun call() {
        let (a,) = 1;
        a;
      //^ integer  
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_continue_expr_never_type() {
    check_expr_type(
        r#"
module 0x1::m {
    fun main() {
        while (true) {
            continue 
            //^ <never>
        }
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_modifies_expr() {
    check_expr_type(
        r#"
module 0x1::m {
    struct Coin has key {}
    spec module {
        modifies (global<Coin>(@0x1));
               //^ 0x1::m::Coin
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_forall_quantifier_type_binding_expr() {
    check_expr_type(
        r#"
module 0x1::m {
    fun call() {}
    spec call {
        forall i: num : i < 20;
                      //^ num
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_div_expr() {
    check_expr_type(
        r#"
script {
    fun main() {
        (1u8 / 1u8);
      //^ u8
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_int2bv_bv2int() {
    check_expr_type(
        r#"
module 0x1::m {
    fun call() {}
    spec call {
        let a = bv2int(int2bv(100));
        a;
      //^ num  
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_infer_match_expr_variant_field_destructuring_rhs() {
    check_expr_type(
        r#"
module 0x1::m {
    enum S { One { field: u8 }, Two P }
    fun main(s: S) {
        match (s) {
            One { field } => field,
                               //^ u8
        }
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_forall_quantifier_expr() {
    check_expr_type(
        r#"
module 0x1::m {
    fun call() {}
    spec call {
        let a = forall i in 0..10: i < 20;
        a;
      //^ bool  
    }
}        
"#,
    )
}
