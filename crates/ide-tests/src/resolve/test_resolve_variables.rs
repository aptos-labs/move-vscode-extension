//! Generated by `cargo testgen`, do not edit by hand.

use crate::resolve::check_resolve;

// language=Move
#[test]
fn test_for_loop_name_resolution() {
    check_resolve(
        r#"
module 0x1::m {
    fun main() {
        for (ind in 0..10) {
            //X
            ind;
            //^
        }
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_variable_defined_in_nested_block() {
    check_resolve(
        r#"
module 0x1::M {
    fun main() {
        let a = {
            let b = 1;
              //X
            b + 1
          //^  
        };
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_function_signer_with_the_address_name_with_existing_named_address() {
    check_resolve(
        r#"
module 0x1::m {
    #[test(std = @0x1)]
    fun test_address(std: &signer) {
                    //X
        std;
       //^ 
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_binding_for_shortcut_field_for_enum_variant() {
    check_resolve(
        r#"
module 0x1::m {
    enum S { One { field: u8 }, Two }
    fun main() {
        let m = 1;
        match (m) {
            S::One { field }
                    //X
                => field
                    //^
        }
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_field_for_struct_pat_in_enum() {
    check_resolve(
        r#"
module 0x1::m {
    enum S { One { field: u8 }, Two }
                    //X
    fun main(s: S::One) {
        let S::One { field } = s;
                    //^
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_item_in_match_arm_body_1() {
    check_resolve(
        r#"
module 0x1::m {
    enum S { One, Two }
    fun main() {
        let m = 1;
          //X
        match (m) {
            S::One => m
                    //^
        }
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_enum_variant_for_struct_pat_2() {
    check_resolve(
        r#"
module 0x1::m {
    enum S { One { field: u8 }, Two }
           //X
    fun main(s: S::One) {
        let S::One { field } = s;
              //^
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_test_attribute_to_test_function_parameter() {
    check_resolve(
        r#"
module 0x1::M {
    #[test(acc = @0x1)]
          //^
    fun test_add(acc: signer) {
                //X
    
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_locals() {
    check_resolve(
        r#"
script {
    fun main() {
        let z = 1;
          //X
        z;
      //^
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_field_reassignment_for_struct_lit_enum_variant_binding() {
    check_resolve(
        r#"
module 0x1::m {
    enum S { One { field: u8 }, Two }
    fun main(s: S::One) {
        let f = 1;
          //X
        let s = S::One { field: f };
                              //^
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_enum_variant_with_fields() {
    check_resolve(
        r#"
module 0x1::m {
    enum S { One { field: u8 }, Two }
            //X
    fun main() {
        let m = 1;
        match (m) {
            S::One { field: f } => f
              //^
        }
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_const_expected_failure() {
    check_resolve(
        r#"
module 0x1::string {
    const ERR_ADMIN: u64 = 1;
          //X
}        
#[test_only]
module 0x1::string_tests {
    use 0x1::string;
    
    #[test]
    #[expected_failure(abort_code = string::ERR_ADMIN)]
                                            //^
    fun test_abort() {
        
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_function_argument() {
    check_resolve(
        r#"
script {
    fun main(account: &signer) {
           //X
        account;
      //^
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_type_params_used_in_as_statement() {
    check_resolve(
        r#"
module 0x1::M {
    fun convert<T>() {
              //X
        1 as T
           //^
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_variable_in_match_expr() {
    check_resolve(
        r#"
module 0x1::m {
    fun main() {
        let m = 1;
          //X
        match (m) {
             //^
        }
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_field_reassignment_for_struct_pat_in_enum_binding() {
    check_resolve(
        r#"
module 0x1::m {
    enum S { One { field: u8 }, Two }
    fun main(s: S::One) {
        let S::One { field: f } = s;
                          //X
        f;
      //^  
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_type_in_match_arm_3() {
    check_resolve(
        r#"
module 0x1::m {
    enum S { One, Two }
                 //X
    fun main() {
        let m = 1;
        match (m) {
            S::One => true
            S::Two => false
              //^
        }
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_fq_const_expected_failure() {
    check_resolve(
        r#"
module 0x1::string {
    const ERR_ADMIN: u64 = 1;
          //X
}        
#[test_only]
module 0x1::string_tests {
    #[test]
    #[expected_failure(abort_code = 0x1::string::ERR_ADMIN)]
                                                //^
    fun test_abort() {
        
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_shortcut_field_for_enum_variant_in_match_arm() {
    check_resolve(
        r#"
module 0x1::m {
    enum S { One { field: u8 }, Two }
                   //X
    fun main() {
        let m = 1;
        match (m) {
            S::One { field } => field
                    //^
        }
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_cannot_resolve_path_address() {
    check_resolve(
        r#"
module 0x1::m {
    fun main() {
        0x1::;
        //^ unresolved
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_field_reassignment_for_struct_lit_enum_variant() {
    check_resolve(
        r#"
module 0x1::m {
    enum S { One { field: u8 }, Two }
                   //X
    fun main(s: S::One) {
        let f = 1;
        let s = S::One { field: f };
                         //^
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_const_accessible_from_spec_functions() {
    check_resolve(
        r#"
module 0x1::features {
    const PERMISSIONED_SIGNER: u64 = 84;
           //X
    
}
module 0x1::m {}
spec 0x1::m {
    spec fun is_permissioned_signer(): bool {
        use 0x1::features::PERMISSIONED_SIGNER;
        PERMISSIONED_SIGNER;
        //^
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_local_variable_has_priority_over_function_variable() {
    check_resolve(
        r#"
script {
    fun main(z: u8) {
        let z = z + 1;
          //X
        z;
      //^  
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_tuple_destructuring() {
    check_resolve(
        r#"
module 0x1::M {
    fun main() {
        let (a, b) = call();
           //X
        a;
      //^  
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_enum_variant_for_struct_lit() {
    check_resolve(
        r#"
module 0x1::m {
    enum S { One { field: u8 }, Two }
                   //X
    fun main(s: S::One) {
        let f = 1;
        let s = S::One { field: f };
                         //^
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_const_item_expected_failure() {
    check_resolve(
        r#"
module 0x1::string {
    const ERR_ADMIN: u64 = 1;
          //X
}        
#[test_only]
module 0x1::string_tests {
    use 0x1::string::ERR_ADMIN;
    
    #[test]
    #[expected_failure(abort_code = ERR_ADMIN)]
                                     //^
    fun test_abort() {
        
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_no_test_attribute_resolution_if_not_on_function() {
    check_resolve(
        r#"
module 0x1::M {
    fun test_add(acc: signer) {
        #[test(acc = @0x1)]
              //^ unresolved
        use 0x1::M;            
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_test_only_function_in_test_function() {
    check_resolve(
        r#"
module 0x1::M {
    #[test_only]
    fun call() {}
       //X
    
    #[test]
    fun test_a() {
        call();
       //^
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_resolve_tuple_struct_pattern() {
    check_resolve(
        r#"
module 0x1::m {
    struct S(u8, u8);
         //X
    fun main(s: S) {
        let S ( field1, field2 ) = s;
          //^
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_shadowing_of_variable_with_another_variable() {
    check_resolve(
        r#"
script {
    fun main() {
        let z = 1;
        let z = z + 1;
          //X
        z;
      //^
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_compound_assigment_lhs_binding() {
    check_resolve(
        r#"
module 0x1::m {
    fun main() {
        let x = 1;
          //X
        x += 1;
      //^  
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_shadowing_does_not_happen_until_end_of_statement() {
    check_resolve(
        r#"
script {
    fun main(z: u8) {
           //X
        let z = z + 1;
              //^
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_outer_block_variable_with_inner_block_variable() {
    check_resolve(
        r#"
module 0x1::m {
    fun main() {
        let supply = 1;
        spec {
            let supply = 2;
                //X
            supply;
            //^ 
        }
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_unknown_struct_literal_variable_is_resolvable_with_shorthand() {
    check_resolve(
        r#"
module 0x1::m {
    fun main() {
        let myfield = 1;
             //X
        Unknown { myfield };
                   //^
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_compound_assigment_rhs_binding() {
    check_resolve(
        r#"
module 0x1::m {
    fun main() {
        let x = 1;
        let y = 2;
          //X
        x += y;
           //^
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_destructuring_of_struct() {
    check_resolve(
        r#"
module 0x1::M {
    struct MyStruct {
        val: u8
    }
    
    fun destructure() {
        let MyStruct { val } = get_struct();
                     //X
        val;
      //^  
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_const_item_same_module_expected_failure() {
    check_resolve(
        r#"
#[test_only]
module 0x1::string_tests {
    const ERR_ADMIN: u64 = 1;
        //X
    
    #[test]
    #[expected_failure(abort_code = ERR_ADMIN)]
                                     //^
    fun test_abort() {
        
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_attribute_location_for_named_address() {
    check_resolve(
        r#"
module aptos_std::m {
          //X  
    fun main() {
    }
    #[test(location=aptos_std::m)]
                             //^
    fun test_main() {
        
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_binding_for_field_reassignment_for_enum_variant() {
    check_resolve(
        r#"
module 0x1::m {
    enum S { One { field: u8 }, Two }
    fun main() {
        let m = 1;
        match (m) {
            S::One { field: myfield }
                            //X
                => myfield
                    //^
        }
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_consts() {
    check_resolve(
        r#"
module 0x1::M {
    const ENOT_GENESIS: u64 = 0;
        //X
    fun main() {
        let a = ENOT_GENESIS;
              //^
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_pattern_with_rest() {
    check_resolve(
        r#"
module 0x1::m {
    struct S { f1: u8, f2: u8 }
             //X
    fun main(s: S) {
        let S { f1, .. } = s;
               //^
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_no_attr_item_signer_reference_for_not_direct_children_of_test() {
    check_resolve(
        r#"
module 0x1::m {
    #[test(unknown_attr(my_signer = @0x1))]
                         //^ unresolved
    fun test_main(my_signer: signer) {
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_no_attribute_resolution_if_not_a_test_attribute() {
    check_resolve(
        r#"
module 0x1::M {
    #[test]
    #[expected_failure(abort_code = 1)]
                         //^ unresolved
    fun call(abort_code: signer) {
        
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_shadow_global_spec_variable_with_local_one() {
    check_resolve(
        r#"
module 0x1::m {
    spec module {
        global supply<CoinType>: num;
    }
    fun main() {
        let supply = 1;
            //X
        spec {
            supply;
            //^ 
        }
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_redefinition_in_nested_block() {
    check_resolve(
        r#"
script {
    fun main() {
        let a = 1;
          //X
        {
            let a = 2;
        };
        a;
      //^  
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_unknown_struct_literal_variable_is_resolvable_with_full_field() {
    check_resolve(
        r#"
module 0x1::m {
    fun main() {
        let myfield = 1;
             //X
        Unknown { field: myfield };
                        //^
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_field_reassignment_for_struct_pat_in_enum() {
    check_resolve(
        r#"
module 0x1::m {
    enum S { One { field: u8 }, Two }
                    //X
    fun main(s: S::One) {
        let S::One { field: f } = s;
                    //^
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_function_parameters_in_specs() {
    check_resolve(
        r#"
module 0x1::main {
    fun call(a: u8, b: u8) {}
           //X
}
spec 0x1::main {
    spec call(a: u8, b: u8) {}
            //^
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_function_with_match_name() {
    check_resolve(
        r#"
module 0x1::m {
    fun match() {}
      //X
    fun main() {
        match();
          //^
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_type_in_match_arm_2() {
    check_resolve(
        r#"
module 0x1::m {
    enum S { One, Two }
            //X
    fun main() {
        let m = 1;
        match (m) {
            S::One => true
              //^
            S::Two => false
        }
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_attribute_location() {
    check_resolve(
        r#"
module 0x1::m {
          //X  
    fun main() {
    }
    #[test(location=0x1::m)]
                       //^
    fun test_main() {
        
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_test_only_const_in_test_function() {
    check_resolve(
        r#"
module 0x1::M {
    #[test_only]
    const TEST_CONST: u64 = 1;
          //X
    #[test]
    fun test_a() {
        TEST_CONST;
            //^
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_resolve_type_in_match_arm_1() {
    check_resolve(
        r#"
module 0x1::m {
    enum S { One, Two }
       //X
    fun main() {
        let m = 1;
        match (m) {
            S::One => true
          //^  
            S::Two => false
        }
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_const_import_expected_failure() {
    check_resolve(
        r#"
module 0x1::string {
    const ERR_ADMIN: u64 = 1;
          //X
}        
#[test_only]
module 0x1::string_tests {
    use 0x1::string::ERR_ADMIN;
                     //^
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_item_in_match_arm_body_2() {
    check_resolve(
        r#"
module 0x1::m {
    enum S { One, Two }
    fun main(s: S) {
           //X
        let m = 1;
        match (m) {
            S::One => s
                    //^
        }
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_enum_variant_for_struct_pat() {
    check_resolve(
        r#"
module 0x1::m {
    enum S { One { field: u8 }, Two }
       //X
    fun main(s: S::One) {
        let S::One { field } = s;
          //^
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_variables_in_tuple_struct_pattern() {
    check_resolve(
        r#"
module 0x1::m {
    struct S(u8, u8);
    fun main(s: S) {
        let S ( field1, field2 ) = s;
                  //X
        field1;
        //^
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_fields_for_enum_variant_in_match_arm() {
    check_resolve(
        r#"
module 0x1::m {
    enum S { One { field: u8 }, Two }
                   //X
    fun main() {
        let m = 1;
        match (m) {
            S::One { field: f } => f
                    //^
        }
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_destructuring_of_struct_with_variable_rename() {
    check_resolve(
        r#"
module 0x1::M {
    struct MyStruct {
        val: u8
    }
    
    fun destructure() {
        let MyStruct { val: myval } = get_struct();
                          //X
        myval;
      //^  
    }
}
"#,
    )
}
