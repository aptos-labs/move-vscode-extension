//! Generated by `cargo testgen`, do not edit by hand.

use crate::resolve::check_resolve;

// language=Move
#[test]
fn test_resolve_struct_item_of_resource_index_expr() {
    check_resolve(
        r#"
module 0x1::m {
    struct Ss has key { val: u8 }
          //X
    fun main() {
        &mut Ss[@0x1];
           //^
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_item_unresolved_with_duplicate_import() {
    check_resolve(
        r#"
module aptos_std::m1 {
    struct Type { val: u8 }
}
module 0x1::m {
    use aptos_std::m1::Type;
    use aptos_std::m1::Type;
    fun main(s: Type) {}
               //^ unresolved
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_enum_type_from_fully_qualified() {
    check_resolve(
        r#"
module 0x1::m { 
    enum S { One, Two }
       //X
}
module 0x1::main {
    fun main(one: 0x1::m::S) {
                        //^
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_expr_with_enum_variant_no_expected_type() {
    check_resolve(
        r#"
module 0x1::m {
    enum S { One, Two }
    fun main() {
        let a = One;
               //^ unresolved
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_unresolved_enum_variant_if_argument_type_does_not_have_this_variant_1() {
    check_resolve(
        r#"
module 0x1::m {
    enum S1 { One, Two }
    enum S2 {}
    fun main(s: S2) {
        match (s) {
            One => true,
            //^ unresolved
        }
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_unresolved_enum_variant_if_argument_type_does_not_have_this_variant_2() {
    check_resolve(
        r#"
module 0x1::m {
    enum S1 { One { field: u8 }, Two }
    enum S2 {}
    fun main(s: S2) {
        match (s) {
            One { field } => true,
            //^ unresolved
        }
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_match_on_unqualified_enum_variant_with_fields() {
    check_resolve(
        r#"
module 0x1::m {
    enum S { One { field: u8 }, Two }
            //X
    fun main(s: S): bool {
        match (s) {
            One { field: _ } => true
           //^ 
        }
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_struct_from_another_module_for_import() {
    check_resolve(
        r#"
module 0x1::s {
    struct MyStruct {}
            //X
}
module 0x1::m {
    use 0x1::s::MyStruct;
                //^
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_expr_with_enum_variant_with_explicit_type_but_ambiguous() {
    check_resolve(
        r#"
module 0x1::m {
    enum S { One, Two }
           //X
    enum T { One, Two }
    fun main() {
        let a: S = One;
                  //^
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_struct_unresolved_in_name_expr() {
    check_resolve(
        r#"
address 0x1 {
    module A {
        struct S {}
    }
    module B {
        use 0x1::A;
        fun call() {
            A::S
             //^ unresolved                   
        }
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_type_from_usage() {
    check_resolve(
        r#"
address 0x1 {
    module Transaction {
        struct Sender {}
             //X
    }
}
script {
    use 0x1::Transaction::Sender;

    fun main(n: Sender) {}
              //^
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_struct_type_param_inside_vector() {
    check_resolve(
        r#"
module 0x1::m {
    struct MyStruct<T> {
                  //X
        val: vector<T>
                  //^
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_struct_as_acquires_type() {
    check_resolve(
        r#"
module 0x1::m {
    struct MyStruct {}
         //X
    
    fun call() acquires MyStruct {}
                      //^
}
"#,
    )
}

// language=Move
#[test]
fn test_match_on_qualified_enum_variant() {
    check_resolve(
        r#"
module 0x1::m {
    enum S { One, Two }
            //X
    fun main(s: S): bool {
        match (s) {
            S::One => true
              //^ 
        }
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_function_return_type_param_to_type_param() {
    check_resolve(
        r#"
module 0x1::m {
    struct Coin<Token> {}
    
    fun main<Token>()
           //X
            : Coin<Token> {}
                 //^
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_match_variant_with_reference_and_nested_enum_variant_no_qualifier() {
    check_resolve(
        r#"
module 0x1::m {
    enum Inner { Inner1, Inner2 }
                //X
    enum Outer { One { inner: Inner } }
    
    public fun non_exhaustive(o: &Outer) {
        match (o) {
            One { inner: Inner1 } => Inner1
                         //^
        }
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_cannot_create_enum_variant_from_other_module_fq() {
    check_resolve(
        r#"
module 0x1::m {
    enum S { One, Two }
}
module 0x1::main {
    fun main() {
        let s = 0x1::m::S::One;
                           //^ unresolved
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_return_type_with_alias() {
    check_resolve(
        r#"
module 0x1::Transaction {
    struct Sender { val: u8 }
          //X
}
module 0x1::m {
    use 0x1::Transaction::Sender as MySender;
    fun main(): MySender {}
              //^
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_match_variant_with_reference_and_nested_struct_pat_struct() {
    check_resolve(
        r#"
module 0x1::m {
    struct Inner { field: u8 }
          //X
    enum Outer { One { inner: Inner } }
    
    public fun non_exhaustive(o: &Outer) {
        match (o) {
            One { inner: Inner { field } } => field
                         //^
        }
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_native_function_return_type_param_to_type_param() {
    check_resolve(
        r#"
module 0x1::m {
    struct Coin<Token> {}
    
    native fun main<Token>()
                  //X
            : Coin<Token>;
                 //^
}
"#,
    )
}

// language=Move
#[test]
fn test_cannot_create_enum_variants_in_another_module_2() {
    check_resolve(
        r#"
module 0x1::m { 
    enum S { One, Two }
}
module 0x1::main {
    use 0x1::m;
    fun main() {
        let a = m::S::One;
                     //^ unresolved
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_struct_lit_with_enum_variant() {
    check_resolve(
        r#"
module 0x1::m {
    enum S { One { field: u8 }, Two }
           //X
    fun main() {
        let a: S = One { field: 1 };
                 //^
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_type_imported_with_a_different_named_address_with_same_value() {
    check_resolve(
        r#"
module aptos_std::m1 {
    struct Type { val: u8 }
          //X
}
module aptos_framework::m2 {
}
module 0x1::m {
    use aptos_framework::m1::Type;
    fun main(s: Type) {}
               //^
}        
"#,
    )
}

// language=Move
#[test]
fn test_cannot_resolve_enum_variant_from_different_module() {
    check_resolve(
        r#"
module 0x1::m {
    enum S { One, Two }
}
module 0x1::main {
    use 0x1::m;
    fun main() {
        let a = m::S::One;
                     //^ unresolved
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_unresolved_for_unresolved_alias() {
    check_resolve(
        r#"
module 0x1::m {
    use 0x1::Transaction::Sender as MySender;
    fun main(n: MySender) {}
              //^ unresolved
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_enum_variant_in_is_expr() {
    check_resolve(
        r#"
module 0x1::m {
    enum S1 { One, Two }
             //X  
    enum S2 { One, Two }
    fun main(s: S1) {
        if (s is One) true;
                //^
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_struct_type_with_generics() {
    check_resolve(
        r#"
module 0x1::m {
    struct Native<T> {}
         //X
    fun main(n: Native<u8>): u8 {}
              //^
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_struct_as_struct_pattern_destructuring() {
    check_resolve(
        r#"
module 0x1::m {
    struct MyStruct { val: u8 }
         //X
    
    fun call() {
        let MyStruct { val } = get_struct();
          //^
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_enum_variant_in_call_position_even_it_is_not_a_tuple_struct() {
    check_resolve(
        r#"
module 0x1::m {
    enum S { One(u8), Two }
                     //X
    fun main() {
        S::Two(1);
          //^
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_type_with_alias() {
    check_resolve(
        r#"
module 0x1::Transaction {
    struct Sender { val: u8 }
          //X
}
module 0x1::m {
    use 0x1::Transaction::Sender as MySender;
    fun main(n: MySender) {}
              //^
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_expr_with_enum_variant_fq() {
    check_resolve(
        r#"
module 0x1::m {
    enum S { One, Two }
           //X
    fun main() {
        let a: S = S::One;
                     //^
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_match_variant_with_reference_and_nested_struct_pat_field_decl() {
    check_resolve(
        r#"
module 0x1::m {
    struct Inner { field: u8 }
                     //X
    enum Outer { One { inner: Inner } }
    
    public fun non_exhaustive(o: &Outer) {
        match (o) {
            One { inner: Inner { field: myfield } } => myfield
                                //^
        }
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_enum_variant_tuple_struct() {
    check_resolve(
        r#"
module 0x1::m {
    enum S { One(u8), Two }
            //X
    fun main() {
        S::One(1);
          //^  
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_struct_as_function_param_type() {
    check_resolve(
        r#"
module 0x1::m {
    struct MyStruct {}
         //X
    
    fun call(s: MyStruct) {}
              //^
}
"#,
    )
}

// language=Move
#[test]
fn test_cannot_use_enum_variant_as_type_argument_in_is_expr() {
    check_resolve(
        r#"
module 0x1::m {
    enum S1<T> { One, Two }
    enum S2 { Inner }
    fun main(s: S1) {
        if (s is S1<S2::Inner>::One) true;
                       //^ unresolved
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_struct_from_use_item() {
    check_resolve(
        r#"
module 0x1::M {
    struct MyStruct {}
           //X
}    
module 0x1::Main {
    use 0x1::M::{Self, MyStruct};
                      //^
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_struct_for_struct_literal() {
    check_resolve(
        r#"
module 0x1::m {
    struct MyStruct {}
         //X
    
    fun call() {
        let a = MyStruct {};
              //^
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_type_for_local_import_in_spec() {
    check_resolve(
        r#"
module 0x1::table {
    struct Table {}
           //X
}        
module 0x1::main {
    struct S<phantom T> has key {}
    fun main() {}
}   
spec 0x1::main {
    spec main {
        use 0x1::table::Table;
        
        assert!(exists<S<Table>>(@0x1), 1);
                         //^
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_expr_with_enum_variant() {
    check_resolve(
        r#"
module 0x1::m {
    enum S { One, Two }
           //X
    fun main() {
        let a: S = One;
                  //^
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_type_for_local_import() {
    check_resolve(
        r#"
module 0x1::table {
    struct Table {}
           //X
}        
module 0x1::main {
    struct S<phantom T> has key {}
    fun main() {
        use 0x1::table::Table;
        
        assert!(exists<S<Table>>(@0x1), 1);
                         //^
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_enum_type_from_module_with_the_same_name() {
    check_resolve(
        r#"
module 0x1::S { 
    enum S { One, Two }
       //X
}
module 0x1::main {
    use 0x1::S;
    fun main(one: S::S) {
                   //^
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_cannot_resolve_enum_variant_in_type_position_from_import() {
    check_resolve(
        r#"
module 0x1::m { 
    enum S { One, Two }
}
module 0x1::main {
    use 0x1::m::S;
    fun main(a: S::One) {
                  //^ unresolved
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resource_index_expr() {
    check_resolve(
        r#"
module 0x1::m {
    struct S has key {}
         //X
    fun main() {
        S[@0x1];
      //^   
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_struct_lit_with_enum_variant_ambiguous() {
    check_resolve(
        r#"
module 0x1::m {
    enum S { One { field: u8 }, Two }
           //X
    enum T { One { field: u8 }, Two }
    fun main() {
        let a: S = One { field: 1 };
                  //^
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_type_param_in_native_function_in_spec() {
    check_resolve(
        r#"
module 0x1::M {
    spec module {
        native fun serialize<MoveValue>(
                                //X
            v: &MoveValue
                //^
        ): vector<u8>;
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_function_return_type_to_type_param() {
    check_resolve(
        r#"
module 0x1::m {
    fun main<Token>()
           //X
        : Token {}
        //^
}
"#,
    )
}

// language=Move
#[test]
fn test_module_unresolved_with_duplicate_import() {
    check_resolve(
        r#"
module aptos_std::m1 {
    struct Type { val: u8 }
}
module 0x1::m {
    use aptos_std::m1;
    use aptos_std::m1;
    fun main(s: m1::Type) {}
                   //^ unresolved
}        
"#,
    )
}

// language=Move
#[test]
fn test_match_with_guard() {
    check_resolve(
        r#"
module 0x1::m {
    enum S { One, Two }
    fun consume() {}
       //X
    fun main(s: S): bool {
        match (s) {
            S::One if consume() => true
                      //^
        }
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_enum_variant_cannot_be_resolved_on_the_right_side_of_match_arm() {
    check_resolve(
        r#"
module 0x1::m {
    enum Inner { Inner1, Inner2 }
                //X
    enum Outer { One { inner: Inner } }
    
    public fun non_exhaustive(o: &Outer) {
        match (o) {
            One { inner: Inner1 } => Inner1
                                     //^ unresolved
        }
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_cannot_resolve_enum_value_by_itself_with_no_type_guidance_in_type() {
    check_resolve(
        r#"
module 0x1::m {
    enum Ss { One }
    fun main(s: One) {
                //^ unresolved  
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_cannot_resolve_enum_variant_in_let_expr_for_different_enum_type() {
    check_resolve(
        r#"
module 0x1::m {
    enum S1 { One, Two }
    enum S2 { }
    fun main(_: S1) {
        let s: S2 = One;
                   //^ unresolved
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_match_variant_with_reference_and_nested_struct_pat_field_variable() {
    check_resolve(
        r#"
module 0x1::m {
    struct Inner { field: u8 }
    enum Outer { One { inner: Inner } }
    
    public fun non_exhaustive(o: &Outer) {
        match (o) {
            One { inner: Inner { field: myfield } }
                                       //X
                => myfield
                    //^
        }
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_enum_variant() {
    check_resolve(
        r#"
module 0x1::m {
    enum S { One, Two }
           //X
    fun main(one: S::One) {
        let a = S::One;
                  //^
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_match_expr_enum_variant_with_presence_of_another_of_the_same_name_2() {
    check_resolve(
        r#"
module 0x1::m {
    enum S1 { One { field: u8 }, Two }
             //X
    enum S2 { One { field: u8 }, Two }
    fun main(s: S1) {
        match (s) {
            One { field } => field,
            //^ 
        }
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_struct_as_type_argument() {
    check_resolve(
        r#"
module 0x1::m {
    struct MyStruct {}
             //X
    
    fun call() {
        let a = move_from<MyStruct>();
                        //^
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_match_variant_with_reference_struct_pat() {
    check_resolve(
        r#"
module 0x1::m {
    enum Outer { None { i: u8 } }
                //X

    public fun non_exhaustive(o: &Outer) {
        match (o) {
            None { _ } => {}
            //^
        }
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_match_on_unqualified_enum_variant_mut_ref() {
    check_resolve(
        r#"
module 0x1::m {
    enum S { One, Two }
            //X
    fun main(s: &mut S): bool {
        match (s) {
            One => true
           //^ 
        }
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_cannot_resolve_enum_variant_in_type_position() {
    check_resolve(
        r#"
module 0x1::m {
    enum S { One, Two }
    fun main(one: S::One) {
                    //^ unresolved
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_cannot_resolve_enum_variant_in_is_expr_for_different_enum_type() {
    check_resolve(
        r#"
module 0x1::m {
    enum S1 { One, Two }
    enum S2 {  }
    fun main(s: S2) {
        s is One;
            //^ unresolved
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_module_resolution_not_available_on_type_position() {
    check_resolve(
        r#"
module 0x1::Transaction {
    struct Type {
        val: u8                   
    }
}
module 0x1::M {
    fun main(a: 0x1::Transaction::Transaction) {
                                   //^ unresolved
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_enum_variant_in_let_expr_if_explicit_type_is_provided() {
    check_resolve(
        r#"
module 0x1::m {
    enum S1 { One, Two }
             //X  
    enum S2 { One, Two }
    fun main(_: S1) {
        let s: S1 = One;
                   //^
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_match_expr_enum_variant_with_presence_of_another_of_the_same_name_1() {
    check_resolve(
        r#"
module 0x1::m {
    enum S1 { One, Two }
             //X
    enum S2 { One, Two }
    fun main(s: S1) {
        match (s) {
            One => true,
            //^ 
        }
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_match_variant_with_reference_and_nested_enum() {
    check_resolve(
        r#"
module 0x1::m {
    enum Inner { Inner1, Inner2 }
          //X
    enum Outer { One { inner: Inner } }
    
    public fun non_exhaustive(o: &Outer) {
        match (o) {
            One { inner: Inner::Inner1 } => field
                         //^
        }
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_types_with_shadowing() {
    check_resolve(
        r#"
module 0x1::m {
    struct VestingContract {}
    fun main<VestingContract>() {
               //X
        let t: VestingContract;
                  //^
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_struct_lit_with_enum_variant_fq() {
    check_resolve(
        r#"
module 0x1::m {
    enum S { One { field: u8 }, Two }
           //X
    fun main() {
        let a: S = S::One { field: 1 };
                     //^
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_type_from_import() {
    check_resolve(
        r#"
address 0x1 {
    module Transaction {
        struct Sender {}
             //X
    }
}
script {
    use 0x1::Transaction::Sender;
                        //^
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_enum_variant_in_is_expr_fq() {
    check_resolve(
        r#"
module 0x1::m {
    enum S1 { One, Two }
             //X  
    enum S2 { One, Two }
    fun main(s: S1) {
        if (s is S1::One) true;
                    //^
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_type_parameter_in_return() {
    check_resolve(
        r#"
module 0x1::m {
    public fun remove<K: copy + drop, V>(
                                    //X
        val: V
    ): V {
     //^
        val
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_cannot_resolve_enum_value_by_itself_with_no_type_guidance_in_expr() {
    check_resolve(
        r#"
module 0x1::m {
    enum Ss { One }
    fun main() {
        One;
      //^ unresolved  
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_struct_type_param() {
    check_resolve(
        r#"
module 0x1::m {
    struct MyStruct<T> {
                  //X
        val: T
           //^
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_type_of_field_with_alias() {
    check_resolve(
        r#"
module 0x1::m {
    struct S { field: u8 }
         //X
}
module 0x1::main {
    use 0x1::m::S as MyS;
    struct R { field: MyS }
                     //^
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_match_variant_with_reference_and_nested_enum_variant() {
    check_resolve(
        r#"
module 0x1::m {
    enum Inner { Inner1, Inner2 }
                //X
    enum Outer { One { inner: Inner } }
    
    public fun non_exhaustive(o: &Outer) {
        match (o) {
            One { inner: Inner::Inner1 } => field
                                //^
        }
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_enum_variant_from_module_fully_qualified_same_module() {
    check_resolve(
        r#"
module 0x1::m {
    enum S { One, Two }
           //X
    fun main() {
        let s = 0x1::m::S::One;
                           //^
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_tuple_struct_as_a_name() {
    check_resolve(
        r#"
module 0x1::m {
    struct S(u8);
         //X
    fun main() {
        S(1);
      //^  
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_cannot_resolve_struct_for_struct_literal_from_another_module() {
    check_resolve(
        r#"
module 0x1::s {
    struct MyStruct {}
}
module 0x1::m {
    use 0x1::s::MyStruct;
    fun call() {
        let a = MyStruct {};
              //^ unresolved
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_cannot_create_enum_variants_in_another_module_1() {
    check_resolve(
        r#"
module 0x1::m { 
    enum S { One, Two }
}
module 0x1::main {
    use 0x1::m;
    fun main() {
        let a = m::S::One;
                 //^ unresolved
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_type_parameters_in_specs() {
    check_resolve(
        r#"
module 0x1::main {
    fun call<T>(a: u8, b: u8) {}
           //X
}
spec 0x1::main {
    spec call<T>(a: u8, b: u8) {}
            //^
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_enum_with_variant_in_type_position_from_import() {
    check_resolve(
        r#"
module 0x1::m { 
    enum S { One, Two }
       //X
}
module 0x1::main {
    use 0x1::m::S;
    fun main(a: S::One) {
              //^
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_enum_as_a_qualifier_of_enum_variant_in_type_position() {
    check_resolve(
        r#"
module 0x1::m {
    enum S { One, Two }
       //X
    fun main(one: S::One) {
                //^
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_struct_as_return_type() {
    check_resolve(
        r#"
module 0x1::m {
    struct MyStruct {}
         //X
    fun call(): MyStruct {}
              //^
}
"#,
    )
}

// language=Move
#[test]
fn test_enum_expr_cannot_be_used_with_import_from_another_module() {
    check_resolve(
        r#"
module 0x1::m { 
    enum S { One, Two }
}
module 0x1::main {
    use 0x1::m::S;
    fun main() {
        let a = S::One;
              //^ unresolved
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_match_on_unqualified_enum_variant_ref() {
    check_resolve(
        r#"
module 0x1::m {
    enum S { One, Two }
            //X
    fun main(s: &S): bool {
        match (s) {
            One => true
           //^ 
        }
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_match_variant_with_reference() {
    check_resolve(
        r#"
module 0x1::m {
    enum Outer { None }
                //X

    public fun non_exhaustive(o: &Outer) {
        match (o) {
            None => {}
            //^
        }
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_enum_type_from_module() {
    check_resolve(
        r#"
module 0x1::m { 
    enum S { One, Two }
       //X
}
module 0x1::main {
    use 0x1::m;
    fun main(one: m::S) {
                   //^
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_enum_variant_in_is_expr_with_or() {
    check_resolve(
        r#"
module 0x1::m {
    enum S1 { One, Two }
                  //X  
    enum S2 { One, Two }
    fun main(s: S1) {
        s is One | Two;
                  //^
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_match_on_unqualified_enum_variant() {
    check_resolve(
        r#"
module 0x1::m {
    enum S { One, Two }
            //X
    fun main(s: S): bool {
        match (s) {
            One => true
           //^ 
        }
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_enum_item_of_resource_index_expr() {
    check_resolve(
        r#"
module 0x1::m {
    enum Ss has key { Empty }
       //X
    fun main() {
        &mut Ss[@0x1];
           //^
    }
}        
"#,
    )
}
