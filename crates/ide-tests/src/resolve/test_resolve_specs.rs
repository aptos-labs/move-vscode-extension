//! Generated by `cargo testgen`, do not edit by hand.

use crate::resolve::check_resolve;

// language=Move
#[test]
fn test_resolve_item_specs_in_test_only_module() {
    check_resolve(
        r#"
#[test_only]
module 0x1::m {
    public fun simple_share(o: Obj) {
               //X
    }
    spec simple_share {
            //^
    }

}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_schema_parameters() {
    check_resolve(
        r#"
module 0x1::M {
    spec module {
        let a = @0x1;
        include MySchema { addr: a };
                          //^
    }
    
    spec schema MySchema {
        addr: address;
        //X
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_resolve_schema_element_to_schema() {
    check_resolve(
        r#"
module 0x1::M {
    spec module {
        include MySchema;
                 //^
    }
    spec schema MySchema {}
                //X
}    
"#,
    )
}

// language=Move
#[test]
fn test_resolve_spec_variable_to_function_param() {
    check_resolve(
        r#"
module 0x1::M {
    fun call(count: u8) {}
            //X
    spec call {
        requires count > 1;
                //^
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_resolve_let_post_sees_pre() {
    check_resolve(
        r#"
module 0x1::M {
    fun call() {}
    spec call {
        let count = 1;
           //X
        let post count2 = count + 1;
                         //^ 
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_spec_struct_resolves_to_field() {
    check_resolve(
        r#"
module 0x1::M {
    struct S { val: u8 }
              //X
    spec S {
        invariant val > 1;
                 //^ 
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_resolve_spec_to_function() {
    check_resolve(
        r#"
module 0x1::M {
    fun length(): u8 { 1 }
       //X
    spec length {
         //^   
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_spec_fun_parameters() {
    check_resolve(
        r#"
module 0x1::M {
    spec fun call(val: num) {
                 //X
        val;
       //^ 
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_resolve_spec_fun_defined_in_another_module() {
    check_resolve(
        r#"
module 0x1::m {
    spec fun spec_now_microseconds(): u64 {
              //X
        1
    }            
}
module 0x1::main {
    use 0x1::m;
    spec module {
        m::spec_now_microseconds();
             //^
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_spec_item_function_parameter() {
    check_resolve(
        r#"
module 0x1::main {
    fun call(account: &signer) {}
             //X
}        
spec 0x1::main {
    spec call(account: &signer) {
                //^
    
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_schema_lit_with_imply_operator() {
    check_resolve(
        r#"
module 0x1::M {
    spec schema MySchema {}
                 //X
    spec module {
        include true ==> MySchema;
                          //^
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_resolve_global_variable_accessible_with_qual_name() {
    check_resolve(
        r#"
module 0x1::coin {
}
spec 0x1::coin {
    spec module {
        global supply<CoinType>: num;
              //X
    }
}        
module 0x1::transaction {
    fun main() {}
}
spec 0x1::transaction {
    spec main {
        use 0x1::coin;
        ensures coin::supply<CoinType> == 1;
                        //^
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_spec_inline_function_from_module_item_spec_is_not_accessible_in_non_msl_scope() {
    check_resolve(
        r#"
module 0x1::m {
}
spec 0x1::m {
    spec module { 
        fun spec_now_microseconds(): u64 {
            1
        }       
    }
}
module 0x1::main {
    use 0x1::m;
    fun main() {
        m::spec_now_microseconds();
           //^ unresolved
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_spec_functions_are_available_in_spec_code() {
    check_resolve(
        r#"
module 0x1::main {
    fun call() {
    }
    spec call {
        spec_add();
        //^
    }
}    
spec 0x1::main {
    spec fun spec_add(): u8 { 1 }
             //X
}
"#,
    )
}

// language=Move
#[test]
fn test_global_spec_variable_not_accessible_from_main_code() {
    check_resolve(
        r#"
module 0x1::m {
    spec module {
        global supply: num;
    }
    fun main() {
        supply;
        //^ unresolved
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_from_let_statement_to_another_let_statement() {
    check_resolve(
        r#"
module 0x1::M {
    fun call() {}
    spec call {
        let count = 1;
           //X
        let count2 = count + 1;
                   //^
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_module_name_in_spec_module() {
    check_resolve(
        r#"
module 0x1::Module {
            //X        
}    
spec 0x1::Module {
            //^
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_schema_from_current_scope() {
    check_resolve(
        r#"
module 0x1::Module {}    
spec 0x1::Module {
    spec schema MySchema {
               //X
    }
    spec schema MySchema2 {
        include MySchema;
                 //^
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_schema_in_apply() {
    check_resolve(
        r#"
module 0x1::M {
    spec schema MySchema {}
                //X
    spec module {
        apply MySchema to *;
              //^
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_module_has_separate_scope_from_bindings() {
    check_resolve(
        r#"
module 0x1::m {
    fun call(account: &signer) {}
                //X
    spec call {
        use aptos_framework::account;
        signer::address_of(account);
                          //^
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_native_fun_defined_in_spec_module() {
    check_resolve(
        r#"
module 0x1::m {
    spec module {
        native fun serialize<MoveValue>(v: &MoveValue): vector<u8>;
                    //X
    }
}
module 0x1::main {
    use 0x1::m;
    spec module {
        m::serialize(&true);
           //^
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_global_variable_for_inline_spec_defined_in_module_spec() {
    check_resolve(
        r#"
module 0x1::m {
    fun main() {
        spec {
            assert supply<CoinType> == 1;
                      //^    
        }
    }
}        
spec 0x1::m {
    spec module {
        global supply<CoinType>: num;
               //X
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_schema_vars_in_schema_reverse_order() {
    check_resolve(
        r#"
module 0x1::M {
    spec schema MySchema {
        var1;
       //^  
        var1: address;
        //X
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_spec_call_to_module_fun() {
    check_resolve(
        r#"
module 0x1::M {
    fun mod_exists(): bool { true }
       //X
    fun call() {}
    spec call {
        ensures mod_exists();
                //^
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_dot_access_resolution_for_spec_parameters() {
    check_resolve(
        r#"
module 0x1::M {
    struct S { val: u8 }
             //X
    spec schema SS {
        s: S;
        s.val;
        //^
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_spec_module_has_access_to_item_imports_locally() {
    check_resolve(
        r#"
module 0x1::signer {
          //X
    fun address_of(addr: address) {}
}     
module 0x1::mod {
}    
spec 0x1::mod {
    spec schema MySchema {
        use 0x1::signer;
        let a = signer::;  
               //^
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_function_name_in_spec_module() {
    check_resolve(
        r#"
module 0x1::Module {
    public fun call() {}
               //X
}    
spec 0x1::Module {
    spec call {}
        //^
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_module_in_spec() {
    check_resolve(
        r#"
module 0x1::main {
           //X
}
spec 0x1::main {
         //^
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_type_in_spec_global_function() {
    check_resolve(
        r#"
module 0x1::main {
    struct S has key { val: u8 }
         //X
}
spec 0x1::main {
    spec fun spec_now(): u8 {
        global<S>(@0x1);
             //^
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_dot_field_for_fields_in_module() {
    check_resolve(
        r#"
module 0x1::main {
    struct S has key { val: u8 }
                      //X
}
spec 0x1::main {
    spec fun spec_now() {
        global<S>(@0x1).val;
                       //^
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_exists_binding() {
    check_resolve(
        r#"
module 0x1::M {
    spec module {
        invariant exists addr: address
                       //X
            : addr != @0x1;
            //^
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_fun_can_be_defined_in_spec_module() {
    check_resolve(
        r#"
module 0x1::M {
    fun call() {}
    spec call {
        spec_fun()
        //^
    }
    spec module {
        fun spec_fun() {}
           //X
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_resolve_local_schema_parameters() {
    check_resolve(
        r#"
module 0x1::M {
    spec module {
        let a = @0x1;
        include MySchema { addr: a };
                          //^
    }
    
    spec schema MySchema {
        local addr: address;
             //X
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_spec_function_from_module_item_spec_is_not_accessible_in_non_msl_scope() {
    check_resolve(
        r#"
module 0x1::m {
}
spec 0x1::m {
    spec fun spec_now_microseconds(): u64 {
        1
    }       
}
module 0x1::main {
    use 0x1::m;
    fun main() {
        m::spec_now_microseconds();
           //^ unresolved
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_another_module_consts_are_accessible_from_msl() {
    check_resolve(
        r#"
module 0x1::M {
    const MY_CONST: u8 = 1;
          //X
}    
module 0x1::M2 {
    use 0x1::M;
    spec module {
        M::MY_CONST;
             //^            
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_spec_fun_call_to_spec_fun() {
    check_resolve(
        r#"
module 0x1::M {
    spec fun call() {
        spec_exists();
            //^
    }
    spec fun spec_exists() { true }
            //X
}    
"#,
    )
}

// language=Move
#[test]
fn test_spec_fun_from_spec_module_reachable_in_spec_module() {
    check_resolve(
        r#"
module 0x1::M {
    spec module {
        fun call() {}
           //X
        fun m() {
            call();
            //^
        }
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_resolve_spec_type_param_to_function_type_param() {
    check_resolve(
        r#"
module 0x1::M {
    fun m<CoinType>() {}
         //X
    spec m {
        ensures exists<CoinType>(@0x1);
                       //^
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_fun_can_be_defined_right_in_spec() {
    check_resolve(
        r#"
module 0x1::M {
    fun m() {}
    spec m {
        fun call() {}
           //X
        call();
        //^
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_another_module_consts_are_not_accessible_from_non_msl() {
    check_resolve(
        r#"
module 0x1::M {
    const MY_CONST: u8 = 1;
}    
module 0x1::M2 {
    use 0x1::M;
    fun main() {
        M::MY_CONST;
             //^ unresolved            
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_item_spec_of_verify_only_function() {
    check_resolve(
        r#"
module 0x1::m {
    #[verify_only]
    fun call(): u8 { 1 }
       //X
    spec call {}
        //^
}        
"#,
    )
}

// language=Move
#[test]
fn test_spec_functions_are_available_in_spec_module_code() {
    check_resolve(
        r#"
module 0x1::main {
    fun call() {
    }
}    
spec 0x1::main {
    spec fun spec_add(): u8 { 1 }
             //X
    spec call {
        spec_add();
        //^
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_schema_vars_in_schema_local() {
    check_resolve(
        r#"
module 0x1::M {
    spec schema MySchema {
        local ensures: address;
             //X
        update ensures = 1;
              //^  
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_schema_lit_with_if_else_operator_else() {
    check_resolve(
        r#"
module 0x1::M {
    spec schema MySchema {}
                 //X
    spec module {
        include if (true) MySchema else MySchema;
                                        //^
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_resolve_let_pre_does_not_see_let_post() {
    check_resolve(
        r#"
module 0x1::M {
    fun call() {}
    spec call {
        let post count = 1;
        let count2 = count + 1;
                      //^ unresolved
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_spec_module_has_access_to_module_imports() {
    check_resolve(
        r#"
module 0x1::signer {
          //X
    fun address_of(addr: address) {}
}     
module 0x1::Module {
    use 0x1::signer;
}    
spec 0x1::Module {
    spec schema MySchema {
        let a = signer::;  
               //^
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_invariant_index_variable_in_loop_condition_spec_with_variable_present() {
    check_resolve(
        r#"
module 0x1::m {
    fun main() {
        let ind = 0;
        while ({
            spec {
                invariant forall ind in 0..10:
                               //X
                    ind < 10;
                  //^
            };
            true
        }) {
            
        }
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_result_field_for_spec() {
    check_resolve(
        r#"
module 0x1::main {
    struct S { val: u8 }
               //X
    fun call(): S { S { val: 1 } }
    spec call {
        ensures result.val == 1;
                      //^
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_spec_to_struct() {
    check_resolve(
        r#"
module 0x1::M {
    struct S {}
         //X
    spec S {
       //^   
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_global_variable_for_schema() {
    check_resolve(
        r#"
module 0x1::m {
    spec module {
        global supply<CoinType>: num;
               //X
    }
    spec schema MySchema {
        ensures supply<CoinType> == 1;
                  //^    
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_schema_from_another_module() {
    check_resolve(
        r#"
module 0x1::M {
    spec schema MySchema {}
               //X
}
module 0x1::M2 {
    use 0x1::M;
    
    spec module {
        include M::MySchema;
                  //^
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_spec_fun_from_another_module() {
    check_resolve(
        r#"
module 0x1::M {
    spec fun myfun(): bool { true }
           //X
}
module 0x1::M2 {
    use 0x1::M;
    spec module {
        M::myfun();
          //^
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_forall_binding() {
    check_resolve(
        r#"
module 0x1::M {
    spec module {
        invariant forall ind in 0..len(bytes)
                       //X
            : ind != 0;
            //^
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_schema_vars_in_schema() {
    check_resolve(
        r#"
module 0x1::M {
    spec schema MySchema {
        var1: address;
        //X
        var1;
       //^  
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_resolve_schema_from_spec_module() {
    check_resolve(
        r#"
module 0x1::call {}
spec 0x1::call {
    spec schema MySchema {}
                //X
}
module 0x1::main {
    use 0x1::call::MySchema;
    
    spec module {
        include MySchema;
                //^
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_spec_fun_defined_in_another_spec_module_item_spec() {
    check_resolve(
        r#"
module 0x1::m {
}
spec 0x1::m {
    spec module {
        fun spec_now_microseconds(): u64 {
                  //X
            1
        }            
    }
}
module 0x1::main {
    use 0x1::m;
    spec module {
        m::spec_now_microseconds();
             //^
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_spec_item_type_parameter() {
    check_resolve(
        r#"
module 0x1::main {
    fun call<CoinType>() {}
             //X
}        
spec 0x1::main {
    spec call<CoinType>() {
                //^
    
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_spec_module_has_access_to_item_imports() {
    check_resolve(
        r#"
module 0x1::signer {
          //X
    fun address_of(addr: address) {}
}     
module 0x1::mod {
    use 0x1::signer;
}    
spec 0x1::mod {
    spec schema MySchema {
        let a = signer::;  
               //^
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_schema_lit_with_if_else_operator_if() {
    check_resolve(
        r#"
module 0x1::M {
    spec schema MySchema {}
                 //X
    spec module {
        include if (true) MySchema else MySchema;
                          //^
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_spec_module_has_access_to_all_items_of_module() {
    check_resolve(
        r#"
module 0x1::Module {
    fun address_of(addr: address) {}
       //X
}    
spec 0x1::Module {
    spec schema MySchema {
        let a = address_of(@0x1);  
                //^
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_spec_functions_not_available_in_main_code() {
    check_resolve(
        r#"
module 0x1::main {
    fun call() {
        spec_add();
        //^ unresolved
    }
}    
spec 0x1::main {
    spec fun spec_add(): u8 { 1 }
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_spec_fun_defined_in_another_module_spec() {
    check_resolve(
        r#"
module 0x1::m {
}
spec 0x1::m {
    spec fun spec_now_microseconds(): u64 {
              //X
        1
    }            
}
module 0x1::main {
    use 0x1::m;
    spec module {
        m::spec_now_microseconds();
             //^
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_global_variable_for_inline_spec() {
    check_resolve(
        r#"
module 0x1::m {
    spec module {
        global supply<CoinType>: num;
               //X
    }
    fun main() {
        spec {
            assert supply<CoinType> == 1;
                      //^    
        }
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_spec_fun_from_module_item_spec_in_the_same_module() {
    check_resolve(
        r#"
module 0x1::m {
    fun call<T>() {}
}
spec 0x1::m {
    spec module {
        fun deserializable<T>(bytes: vector<u8>): bool;
            //X
    }
    spec call<T>() {
        deserializable<T>();
        //^
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_struct_name_in_spec_module() {
    check_resolve(
        r#"
module 0x1::Module {
    struct MyStruct {}
          //X
}    
spec 0x1::Module {
    spec MyStruct {}
        //^
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_spec_variable_to_let_statement() {
    check_resolve(
        r#"
module 0x1::M {
    fun call() {}
    spec call {
        let count = 1;
           //X
        requires count > 1;
                //^
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_type_parameters_of_axiom() {
    check_resolve(
        r#"
module 0x1::m {
    spec module {
            // `deserialize` is an injective function.
        axiom<T> forall b1: vector<u8>, b2: vector<u8>:
            //X
            (deserialize<T>(b1) == deserialize<T>(b2) ==> b1 == b2);
                       //^
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_schema_lit_with_and_operator() {
    check_resolve(
        r#"
module 0x1::M {
    spec schema MySchema {}
                 //X
    spec module {
        include MySchema && MySchema;
                 //^
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_resolve_funs_in_spec_in_test_only_module() {
    check_resolve(
        r#"
#[test_only]
module 0x1::m {
    public fun simple_share(o: Obj) {
               //X
    }
    spec fun call(): u128 {
        simple_share(); 1
        //^
    }

}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_spec_variable_to_let_statement_in_any_order() {
    check_resolve(
        r#"
module 0x1::M {
    fun call() {}
    spec call {
        requires count > 1;
                //^
        let count = 1;
           //X
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_spec_call_to_spec_fun() {
    check_resolve(
        r#"
module 0x1::M {
    fun call() {}
    spec call {
        ensures spec_exists();
                //^
    }
    spec fun spec_exists() { true }
            //X
}    
"#,
    )
}

// language=Move
#[test]
fn test_resolve_let_post_sees_post() {
    check_resolve(
        r#"
module 0x1::M {
    fun call() {}
    spec call {
        let post count = 1;
                //X
        let post count2 = count + 1;
                         //^ 
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_spec_fun_type_parameters() {
    check_resolve(
        r#"
module 0x1::M {
    spec fun call<TypeParam>() {
                    //X
        spec_exists<TypeParam>();
                   //^
    }
    spec fun spec_exists<TypeParam>() { true }
}    
"#,
    )
}

// language=Move
#[test]
fn test_unresolved_if_let_declared_after_the_first_let() {
    check_resolve(
        r#"
module 0x1::M {
    fun call() {}
    spec call {
        let count2 = count + 1;
                    //^ unresolved
        let count = 1;
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_global_variable_in_spec_module() {
    check_resolve(
        r#"
module 0x1::m {}
spec 0x1::m {
    spec module {
        global supply<CoinType>: num;
               //X
    }
    spec schema MySchema {
        ensures supply<CoinType> == 1;
                  //^    
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_schema_type_parameter_in_apply() {
    check_resolve(
        r#"
module 0x1::M {
    spec schema SS<Type> {}
    spec module {
        apply SS<Type>
                 //^
            to *<Type>;
                 //X
    }
}    
"#,
    )
}
