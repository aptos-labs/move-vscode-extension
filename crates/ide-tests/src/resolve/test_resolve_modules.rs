//! Generated by `cargo testgen`, do not edit by hand.

use crate::resolve::check_resolve;

// language=Move
#[test]
fn test_unresolved_if_alias_points_to_unresolved_item() {
    check_resolve(
        r#"
module 0x1::m {
    use 0x1::Transaction as MyTransaction;
                            //X
    fun main() {
        let a = MyTransaction::create();
              //^
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_test_failure_location_to_module() {
    check_resolve(
        r#"
module 0x1::string {}
            //X

#[test_only]
module 0x1::string_tests {
    #[test]
    #[expected_failure(abort_code = 1, location = 0x1::string)]
                                                      //^
    fun test_abort() {
        
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_module_in_the_same_address_block_cannot_be_resolved_without_use() {
    check_resolve(
        r#"
module 0x1::A {
    public fun create() {}
}
module 0x1::B {
    fun main() {
        let a = A::create();
              //^ unresolved
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_module_with_different_address() {
    check_resolve(
        r#"
module 0x2::A {}
          //X
module 0x1::B {
    use 0x2::A;
    
    fun main() {
        let a = A::create();
              //^
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_friend_module_with_named_address() {
    check_resolve(
        r#"
module aptos_std::myfriend {}
                  //X
module aptos_std::main {
    friend aptos_std::myfriend;
                       //^ 
}    
"#,
    )
}

// language=Move
#[test]
fn test_friend_no_module_resolution_for_test_only_modules_in_non_test_only_case() {
    check_resolve(
        r#"
module 0x1::M {
    friend 0x1::MTest;
               //^ unresolved
}    
#[test_only]
module 0x1::MTest {}
"#,
    )
}

// language=Move
#[test]
fn test_import_module_itself_with_Self_import() {
    check_resolve(
        r#"
module 0x1::m {
          //X
    fun create() {}
}
module 0x1::main {
    use 0x1::m::Self;
    fun main() {
        let a = m::create();
              //^
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_module_from_Self() {
    check_resolve(
        r#"
module 0x1::M {
          //X
    struct MyStruct {}
}    
module 0x1::Main {
    use 0x1::M::{Self, MyStruct};
                //^
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_module_from_import_with_value_address() {
    check_resolve(
        r#"
module aptos_framework::m1 {}
                      //X
module 0x1::m {
    use 0x1::m1;
           //^
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_module_from_Self_with_alias() {
    check_resolve(
        r#"
module 0x1::M {
          //X
    struct MyStruct {}
}    
module 0x1::Main {
    use 0x1::M::{Self as MyM, MyStruct};
                //^
}
"#,
    )
}

// language=Move
#[test]
fn test_import_module_itself_with_Self_group_import() {
    check_resolve(
        r#"
address 0x1 {
    module Transaction {
         //X
        fun create() {}
    }
    
    module M {
        use 0x1::Transaction::{Self};
        fun main() {
            let a = Transaction::create();
                  //^
        }
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_module_to_address_block_from_script() {
    check_resolve(
        r#"
address 0x2 {
    module A {
         //X
    }
}

script {
    use 0x2::A;
    
    fun main() {
        let a = A::create();
              //^
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_module_to_different_one_in_same_address_block() {
    check_resolve(
        r#"
address 0x1 {
    module A {
         //X
    }

    module B {
        use 0x1::A;
        
        fun main() {
            let a = A::create();
                  //^
        }
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_friend_module_resolution_for_test_only_modules() {
    check_resolve(
        r#"
module 0x1::M {
    #[test_only]
    friend 0x1::MTest;
               //^
}    
#[test_only]
module 0x1::MTest {}
           //X
"#,
    )
}

// language=Move
#[test]
fn test_cannot_resolve_module_if_imported_one_has_different_address() {
    check_resolve(
        r#"
module 0x1::transaction {}
module 0x1::m {
    fun main() {
        let a = 0x3::transaction::create();
                     //^ unresolved
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_module_to_imported_module_with_alias() {
    check_resolve(
        r#"
module 0x1::Transaction {}
module 0x1::m {
    use 0x1::Transaction as MyTransaction;
                          //X
    fun main() {
        let a = MyTransaction::create();
              //^
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_use_module_Self_in_use_group() {
    check_resolve(
        r#"
module 0x1::transaction {
              //X
}
module 0x1::main {
    use 0x1::transaction::{Self};
                          //^
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_Self_to_current_module() {
    check_resolve(
        r#"
module 0x1::transaction {
            //X
    fun create() {}
    fun main() {
        let a = Self::create();
              //^
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_unresolved_value_address() {
    check_resolve(
        r#"
module 0x1::m {
    use 0x1::account;
        //^ unresolved
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_fq_module_with_named_address() {
    check_resolve(
        r#"
module std::mymodule {
           //X
    public fun call() {}
}
module 0x1::main {
    fun main() {
        std::mymodule::call();
             //^
    }
}         
"#,
    )
}

// language=Move
#[test]
fn test_cannot_resolve_path_inside_friend_to_a_function() {
    check_resolve(
        r#"
module 0x1::myfriend {
    public fun call() {}
}
module 0x1::main {
    use 0x1::myfriend;
    
    friend myfriend::call;
                     //^ unresolved 
}    
"#,
    )
}

// language=Move
#[test]
fn test_use_module_Self() {
    check_resolve(
        r#"
module 0x1::transaction {
              //X
}
module 0x1::main {
    use 0x1::transaction::Self;
                         //^
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_friend_module() {
    check_resolve(
        r#"
module 0x1::myfriend {}
             //X
module 0x1::main {
    friend 0x1::myfriend;
               //^ 
}    
"#,
    )
}

// language=Move
#[test]
fn test_resolve_to_address_block_fully_qualified() {
    check_resolve(
        r#"
address 0x2 {
    module A {
         //X
    }
}

address 0x1 {
    module B {
        fun main() {
            let a = 0x2::A::create();
                       //^
        }
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_module_import_inside_code_block() {
    check_resolve(
        r#"
module 0x1::string {
          //X
    public fun utf8() {}
}
module 0x1::main {
    fun main() {
        use 0x1::string;
        string::utf8();
        //^
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_unresolved_named_address() {
    check_resolve(
        r#"
module 0x1::m {
    use aptos_framework::account;
        //^ unresolved
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_fq_item_with_named_address() {
    check_resolve(
        r#"
module std::mymodule {
    public fun call() {}
              //X
}
module 0x1::main {
    fun main() {
        std::mymodule::call();
                       //^
    }
}         
"#,
    )
}

// language=Move
#[test]
fn test_cannot_resolve_named_address_in_incomplete_path_use_stmt() {
    check_resolve(
        r#"
module 0x1::m {
    use aptos_framework
       //^ unresolved
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_to_address_block_import_with_address_normalization() {
    check_resolve(
        r#"
address 0x0002 {
    module A {
         //X
    }
}

address 0x1 {
    module B {
        use 0x02::A;
        
        fun main() {
            let a = A::create();
                  //^
        }
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_module_to_the_current_one_with_fq_path() {
    check_resolve(
        r#"
module 0x1::m {
          //X
    struct Option {}
    fun main(): 0x1::m::Option {}
                   //^
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_module_from_import_with_named_address() {
    check_resolve(
        r#"
module aptos_framework::m1 {}
                      //X
module 0x1::m {
    use aptos_framework::m1;
                       //^
}        
"#,
    )
}

// language=Move
#[test]
fn test_cannot_resolve_module_with_unknown_named_address() {
    check_resolve(
        r#"
module aptos_framework::m1 {}
module 0x1::m {
    use aptos_framework::m1;
                       //^ unresolved
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_module_to_different_one_from_import() {
    check_resolve(
        r#"
address 0x1 {
    module A {
         //X
    }

    module B {
        use 0x1::A;
               //^
    }
}
"#,
    )
}
