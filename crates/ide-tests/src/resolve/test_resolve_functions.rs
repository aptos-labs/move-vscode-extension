//! Generated by `cargo testgen`, do not edit by hand.

use crate::resolve::check_resolve;

// language=Move
#[test]
fn test_resolve_friend_function_with_named_address() {
    check_resolve(
        r#"
module aptos_std::original {
    friend aptos_std::m;
    public(friend) fun call() {}
                     //X
}
module aptos_std::m {
    use aptos_std::original;
    fun main() {
        original::call();
                 //^
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_call_should_resolve_to_parameter_then_warn_not_callable() {
    check_resolve(
        r#"
module 0x1::mod {
    public inline fun fold<Accumulator, Element>(elem: Element, func: |Element| Accumulator): Accumulator {
                                                  //X
        elem(1);
        //^
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_verify_only_function_accessible_in_spec() {
    check_resolve(
        r#"
module 0x1::m {
    #[verify_only]
    fun call(): u8 { 1 }
       //X
    fun main() {}
    spec main {
        let _ = call();
               //^
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_use_item_spec_fun_defined_in_module_spec_verify_scope_always_available() {
    check_resolve(
        r#"
module 0x1::m {
}        
spec 0x1::m {
    spec module {
        fun spec_sip_hash();
            //X
    }
}
module 0x1::main {
    use 0x1::m::spec_sip_hash;
               //^
    spec fun main(): u128 {
        spec_sip_hash(); 1
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_lambda_function_call_expr() {
    check_resolve(
        r#"
module 0x1::mod {
    public inline fun fold<Accumulator, Element>(elem: Element, func: |Element| Accumulator): Accumulator {
                                                               //X
        func(elem);
        //^
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_unresolved_friend_function_if_friend_of_another_module() {
    check_resolve(
        r#"
module 0x1::m1 {
    friend 0x1::main;
}
module 0x1::m2 {
    friend fun call() {}
}
module 0x1::main {
    use 0x1::m2;
    fun main() {
        m2::call();
           //^ unresolved
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_local_function_when_module_with_same_name_is_imported() {
    check_resolve(
        r#"
module 0x1::royalty {}
module 0x1::m {
    use 0x1::royalty;
    public fun royalty() {}
                //X
    public fun main() {
        royalty();
        //^
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_fun_in_test_only_module_from_another_test_only() {
    check_resolve(
        r#"
#[test_only] 
module 0x1::M1 {
    public fun call() {}
              //X
}   
#[test_only] 
module 0x1::M2 {
    use 0x1::M1::call;
    
    fun main() {
        call();
        //^
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_friend_function_is_unresolved_in_scripts() {
    check_resolve(
        r#"
module 0x1::original {
    friend 0x1::m;
    public(friend) fun call() {}
}
module 0x1::m {}
script { 
    use 0x1::original;
    fun main() {
        original::call();
                //^ unresolved
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_use_item() {
    check_resolve(
        r#"
module 0x1::string {
    public fun utf8() {}
              //X
}
module 0x1::main {
    use 0x1::string::utf8;
                   //^
}        
"#,
    )
}

// language=Move
#[test]
fn test_cannot_resolve_local_function_when_duplicate_function_is_imported() {
    check_resolve(
        r#"
module 0x1::royalty {
    public fun royalty() {}
}
module 0x1::m {
    use 0x1::royalty::royalty;
    public fun royalty() {}
    public fun main() {
        royalty();
        //^ unresolved
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_inline_function_from_same_module() {
    check_resolve(
        r#"
module 0x1::string {
    inline fun foreach<Element>(v: vector<Element>, f: |Element|) {}
              //X
    fun main() {
        foreach(vector[1, 2, 3], |e| print(e))
        //^
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_cannot_resolve_spec_fun_main_scope() {
    check_resolve(
        r#"
module 0x1::m {
}        
spec 0x1::m {
    spec module {
        fun spec_sip_hash();
    }
}
module 0x1::main {
    use 0x1::m::spec_sip_hash;
    fun main() {
        spec_sip_hash();
        //^ unresolved
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_lambda_from_let_stmt() {
    check_resolve(
        r#"
module 0x1::m {
    fun main() {
        let select_f = |s|;
              //X
        select_f(1);
        //^
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_verify_only_function_accessible_in_other_verify_only_function() {
    check_resolve(
        r#"
module 0x1::m {
    #[verify_only]
    fun call(): u8 { 1 }
       //X
    #[verify_only]
    fun main() {
        let _ = call();
               //^
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_variable_shadows_lambda_parameter_with_the_same_name_even_if_not_callable() {
    check_resolve(
        r#"
module 0x1::mod {
    public inline fun fold<Accumulator, Element>(elem: Element, func: |Element| Accumulator): Accumulator {
        let func = 1;
           //X                                                                       
        func(elem);
        //^
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_unittest_functions_are_not_accessible_as_module_items() {
    check_resolve(
        r#"
#[test_only]    
module 0x1::M1 {
    #[test]
    entry fun test_a() {}
}    
#[test_only]
module 0x1::M2 {
    use 0x1::M1; 
    
    entry fun main() {
        M1::test_a();
           //^ unresolved    
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_resolve_public_entry_function() {
    check_resolve(
        r#"
address 0x1 {
module Original {
    public entry fun call() {}
                     //X
}
}

script {
    use 0x1::Original;
    fun main() {
        Original::call();
                //^
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_resolve_function_from_use_group() {
    check_resolve(
        r#"
module 0x1::m {
    public fun call() {}
              //X
}        
module 0x1::main {
    use 0x1::m::{call};
    public fun main() {
        call();
        //^
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_type_param_in_return_pos() {
    check_resolve(
        r#"
module 0x1::m {
    fun call<T>
           //X 
            (): T {}
              //^
}
"#,
    )
}

// language=Move
#[test]
fn test_test_only_function_is_not_accessible_from_non_test_only_module() {
    check_resolve(
        r#"
module 0x1::M1 {
    #[test_only]
    public fun call() {}
}        
module 0x1::M2 {
    use 0x1::M1;
    fun call() {
        M1::call();
           //^ unresolved             
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_type_param_in_param_pos() {
    check_resolve(
        r#"
module 0x1::m {
    fun call<T>
           //X
            (val: T) {}
                //^
}
"#,
    )
}

// language=Move
#[test]
fn test_use_item_inside_function_block() {
    check_resolve(
        r#"
module 0x1::string {
    public fun utf8() {}
              //X
}
module 0x1::main {
    fun main() {
        use 0x1::string::utf8;
        utf8();
        //^
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_reference_to_function() {
    check_resolve(
        r#"
module 0x1::m {
    fun call(): u8 {
      //X
        1
    }
    
    fun main() {
        call();
      //^
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_reference_to_function_via_Self() {
    check_resolve(
        r#"
module 0x1::m {
    fun call(): u8 {
      //X
        1
    }
    
    fun main() {
        Self::call();
            //^
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_function_with_module_alias_cannot_use_original_module_name() {
    check_resolve(
        r#"
module 0x1::m {
    public fun call() {}
}

module 0x1::main {
    use 0x1::m as m_alias;
    
    fun main() {
        m::call();
         //^ unresolved
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_resolve_function_to_another_module_with_module_alias() {
    check_resolve(
        r#"
module 0x1::m {
    public fun call() {}
             //X
}

module 0x1::main {
    use 0x1::m as m_alias;
    
    fun main() {
        m_alias::call();
                //^
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_cannot_resolve_function_that_friend_without_friend_statement() {
    check_resolve(
        r#"
module 0x1::m {
    public(friend) fun call() {}
}        
module 0x1::main {
    use 0x1::m::call;
    fun main() {
        call()
        //^ unresolved
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_inline_function_lambda_variable() {
    check_resolve(
        r#"
module 0x1::m {
    public inline fun for_each<Element>(o: Element, f: |Element|) {}
    fun main() {
        for_each(1, |value|
                     //X
            value
            //^
        )
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_type_params_used_in_call_expr() {
    check_resolve(
        r#"
module 0x1::m {
    fun convert<T>() {
              //X
        call<T>()
           //^
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_function_to_another_module_with_local_module_alias() {
    check_resolve(
        r#"
module 0x1::m {
    public fun call() {}
             //X
}

module 0x1::main {
    fun main() {
        use 0x1::m as m_alias;
        m_alias::call();
                //^
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_unittest_functions_are_not_accessible_as_items() {
    check_resolve(
        r#"
#[test_only]    
module 0x1::M {
    #[test]
    fun test_a() {}
    fun main() {
        test_a();
       //^ unresolved 
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_resolve_friend_function_with_public_friend_modifier() {
    check_resolve(
        r#"
address 0x1 {
module Original {
    friend 0x1::M;
    public(friend) fun call() {}
                     //X
}

module M {
    use 0x1::Original;
    fun main() {
        Original::call();
                //^
    }
}    
}
"#,
    )
}

// language=Move
#[test]
fn test_cannot_resolve_private_entry_function_from_script() {
    check_resolve(
        r#"
address 0x1 {
module Original {
    entry fun call() {}
}
}

script {
    use 0x1::Original;
    fun main() {
        Original::call();
                //^ unresolved
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_resolve_function_from_import() {
    check_resolve(
        r#"
module 0x1::original {
    public fun call() {}
             //X
}
module 0x1::m {
    use 0x1::original::call;
                     //^
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_local_test_only_import_into_test_only_item() {
    check_resolve(
        r#"
module 0x1::m {
    #[test_only]
    public fun call() {}
              //X
}        
module 0x1::main {
    #[test]                        
    fun main() {
    use 0x1::m::call;
                //^
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_local_function_when_module_with_same_name_is_imported_as_Self() {
    check_resolve(
        r#"
module 0x1::royalty {}
module 0x1::m {
    use 0x1::royalty::Self;
    public fun royalty() {}
                //X
    public fun main() {
        royalty();
        //^
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_unresolved_if_main_scope_and_test_only_item() {
    check_resolve(
        r#"
module 0x1::minter {
    struct S {}
    public fun mint() {}    
}        
module 0x1::main {
    #[test_only]
    use 0x1::minter::{Self, mint};
    
    public fun main() {
        mint();
        //^ unresolved 
    }
}          
"#,
    )
}

// language=Move
#[test]
fn test_resolve_type_param_in_acquires() {
    check_resolve(
        r#"
module 0x1::m {
    fun call<T>
           //X 
            () acquires T {}
                      //^
}
"#,
    )
}

// language=Move
#[test]
fn test_cannot_resolve_private_function_from_import() {
    check_resolve(
        r#"
module 0x1::original {
    fun call() {}
}
module 0x1::m {
    use 0x1::original::call;
                     //^ unresolved
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_with_self_alias() {
    check_resolve(
        r#"
module 0x1::string {
    public fun utf8() {}
              //X
}
module 0x1::main {
    use 0x1::string::Self as mystring;
    fun main() {
        mystring::utf8();
                //^
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_function_from_use_group_in_use() {
    check_resolve(
        r#"
module 0x1::m {
    public fun call() {}
              //X
}        
module 0x1::main {
    use 0x1::m::{call};
                //^
}
"#,
    )
}

// language=Move
#[test]
fn test_test_only_module_is_not_accessible_from_non_test_only_module() {
    check_resolve(
        r#"
#[test_only]
module 0x1::M1 {
    public fun call() {}
}        
module 0x1::M2 {
    use 0x1::M1;
    fun call() {
        M1::call();
       //^ unresolved
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_test_only_not_accessible_in_the_regular_code_for_local_functions() {
    check_resolve(
        r#"
module 0x1::m {
    #[test_only]
    fun call(): u8 { 1 }
    fun main() {
        let _ = call();
               //^ unresolved
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_local_function_when_module_imported_with_the_same_alias() {
    check_resolve(
        r#"
module 0x1::myroyalty {}
module 0x1::m {
    use 0x1::myroyalty as royalty;
    public fun royalty() {}
                //X
    public fun main() {
        royalty();
        //^
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_reference_to_native_function() {
    check_resolve(
        r#"
module 0x1::m {
    native fun call(): u8;
             //X
    
    fun main() {
        call();
      //^
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_fully_qualified_path_from_the_same_module() {
    check_resolve(
        r#"
module 0x1::M {
    public fun call() {}
             //X
    fun main() {
        0x1::M::call();
                //^  
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_test_function_is_not_available_in_name_resolution() {
    check_resolve(
        r#"
module 0x1::main {
    public fun call() { test_main(); }
                          //^ unresolved
    #[test]
    fun test_main() {}
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_function_to_the_same_module_full_path() {
    check_resolve(
        r#"
module 0x1::m {
    public fun call() {}
             //X
    fun main() {
        0x1::m::call();
              //^
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_lambda_variable_does_not_shadow_function_with_the_same_name() {
    check_resolve(
        r#"
module 0x1::mod {
    fun name() {}
       //X
    fun main() {
        let name = || 1;
        name();
         //^
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_function_qualed_with_module() {
    check_resolve(
        r#"
address 0x1 {
    module Original {
        public fun call() {}
                 //X
    }
}
address 0x2 {
    module M {
        use 0x1::Original;
        
        fun main() {
            Original::call();
                    //^  
        }
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_through_member_import() {
    check_resolve(
        r#"
address 0x1 {
    module Original {
        public fun call() {}
                 //X
    }
}
address 0x2 {
    module M {
        use 0x1::Original::call;
        
        fun main() {
            call();
          //^  
        }
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_private_entry_function_is_not_available_from_another_module() {
    check_resolve(
        r#"
module 0x1::m {
    entry fun call() {}
              //X
}
module 0x1::main {
    use 0x1::m;
    fun main() {
        m::call();
           //^ unresolved
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_module_and_spec_module_blocks_share_the_same_namespace() {
    check_resolve(
        r#"
module 0x1::caller {
    public fun call() {}
              //X
}
module 0x1::main {
    public fun main() {
        call();
        //^
    }
}    
spec 0x1::main {
    use 0x1::caller::call;
}
"#,
    )
}

// language=Move
#[test]
fn test_cannot_resolve_const_from_item() {
    check_resolve(
        r#"
address 0x1 {
module Original {
    const MY_CONST: u8 = 1;
}

module M {
    use 0x1::Original::MY_CONST;
    fun main() {
        MY_CONST;
        //^ unresolved
    }
}    
}
"#,
    )
}

// language=Move
#[test]
fn test_verify_only_not_accessible_in_the_regular_code_for_local_functions() {
    check_resolve(
        r#"
module 0x1::m {
    #[verify_only]
    fun call(): u8 { 1 }
    fun main() {
        let _ = call();
               //^ unresolved
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_entry_function_is_unresolved_in_friend_modules() {
    check_resolve(
        r#"
module 0x1::Original {
    friend 0x1::M;
    entry fun call() {}
}
module 0x1::M {
    use 0x1::Original;
    fun main() {
        Original::call();
                //^ unresolved
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_public_script_is_the_same_as_public_entry() {
    check_resolve(
        r#"
address 0x1 {
module Original {
    public(script) fun call() {}
                     //X
}

module M {
    use 0x1::Original;
    fun main() {
        Original::call();
                //^
    }
}
}    
"#,
    )
}

// language=Move
#[test]
fn test_resolve_function_to_another_module_full_path() {
    check_resolve(
        r#"
module 0x1::original {
    public fun call() {}
               //X
}
module 0x1::m {
    fun call() {}
    
    fun main() {
        0x1::original::call();
                     //^
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_inline_function_from_different_module() {
    check_resolve(
        r#"
module 0x1::string {
    public inline fun foreach<Element>(v: vector<Element>, f: |Element|) {}
                      //X
}
module 0x1::main {
    use 0x1::string::foreach;
    fun main() {
        foreach(vector[1, 2, 3], |e| print(e))
        //^
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_spec_fun_from_import() {
    check_resolve(
        r#"
module 0x1::m {
}        
spec 0x1::m {
    spec module {
        fun spec_sip_hash();
            //X
    }
}
module 0x1::main {
    use 0x1::m::spec_sip_hash;
               //^
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_function_to_import_alias() {
    check_resolve(
        r#"
module 0x1::original {
    public fun call() {}
}    
module 0x1::m {
    use 0x1::original::call as mycall;
                             //X
    fun main() {
        mycall();
      //^  
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_resolve_call_expr_to_variable_even_if_not_lambda() {
    check_resolve(
        r#"
module 0x1::m {
    fun main() {
        let select_f = 1;
              //X
        select_f(1);
        //^
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_test_function_cannot_be_used() {
    check_resolve(
        r#"
module 0x1::m1 {
    #[test]
    public fun test_a() {}
}  
module 0x1::m2 {
    use 0x1::m1::test_a;
    
    #[test_only]
    fun main() {
        test_a();
        //^ unresolved
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_resolve_function_to_another_module_by_module_import() {
    check_resolve(
        r#"
module 0x1::original {
    public fun call() {}
             //X
}
module 0x1::m {
    use 0x1::original;
    
    fun call() {}
    
    fun main() {
        original::call();
                //^
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_resolve_friend_function_with_friend_modifier() {
    check_resolve(
        r#"
address 0x1 {
module Original {
    friend 0x1::M;
    friend fun call() {}
               //X
}

module M {
    use 0x1::Original;
    fun main() {
        Original::call();
                //^
    }
}    
}
"#,
    )
}

// language=Move
#[test]
fn test_unresolved_if_main_scope_and_verify_only_item() {
    check_resolve(
        r#"
module 0x1::minter {
    struct S {}
    public fun mint() {}    
}        
module 0x1::main {
    #[verify_only]
    use 0x1::minter::{Self, mint};
    
    public fun main() {
        mint();
        //^ unresolved 
    }
}          
"#,
    )
}

// language=Move
#[test]
fn test_public_test_function_still_cannot_be_imported() {
    check_resolve(
        r#"
module 0x1::m1 {
    #[test]
    public fun test_a() {}
}  
module 0x1::m2 {
    use 0x1::m1::test_a;
               //^ unresolved
}    
"#,
    )
}

// language=Move
#[test]
fn test_resolve_spec_fun_defined_in_module_spec() {
    check_resolve(
        r#"
module 0x1::m {
}        
spec 0x1::m {
    spec module {
        fun spec_sip_hash();
            //X
    }
}
module 0x1::main {
    use 0x1::m::spec_sip_hash;
    spec fun main(): u128 {
        spec_sip_hash(); 1
               //^
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_friend_function_from_another_module_with_spaces_after_public() {
    check_resolve(
        r#"
module 0x1::A {
    friend 0x1::B; 
    public ( friend) fun call_a() {}
                        //X
}        
module 0x1::B {
    use 0x1::A;
    
    fun main() {
        A::call_a();
              //^
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_private_entry_function_is_not_available_from_another_module_entry_function() {
    check_resolve(
        r#"
module 0x1::m {
    entry fun call() {}
              //X
}
module 0x1::main {
    use 0x1::m;
    entry fun main() {
        m::call();
           //^ unresolved
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_script_function() {
    check_resolve(
        r#"
address 0x1 {
module Original {
    public(script) fun call() {}
                     //X
}
}

script {
    use 0x1::Original;
    fun main() {
        Original::call();
                //^
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_if_there_is_non_lambda_function_prioritize_it_over_variables() {
    check_resolve(
        r#"
module 0x1::m {
    fun select_f(val: u8) {}
         //X
    fun main() {
        let select_f = 1;
        select_f(1);
        //^
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_inline_function_lambda_two_variables() {
    check_resolve(
        r#"
module 0x1::m {
    public inline fun for_each<Element>(o: Element, f: |Element|) {}
    fun main() {
        for_each(1, |value1, value2|
                           //X
            value2
            //^
        )
    }
}        
"#,
    )
}
