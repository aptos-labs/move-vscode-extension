// Copyright Â© Aptos Foundation
// SPDX-License-Identifier: Apache-2.0

// This file contains code originally from rust-analyzer, licensed under Apache License 2.0.
// Modifications have been made to the original code.

//! Generated by `cargo testgen`, do not edit by hand.

use crate::resolve::check_resolve;

// language=Move
#[test]
fn test_resolve_fields_from_dot_access_to_struct_mutable_reference() {
    check_resolve(
        r#"
module 0x1::M {
    struct Option<Element> has copy, drop, store {
        vec: vector<Element>
      //X  
    }
    
    public fun is_none<Element>(t: &mut Option<Element>): bool {
        &t.vec;
          //^
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_resolve_reference_to_field_from_constructor() {
    check_resolve(
        r#"
module 0x1::M {
    struct T {
        my_field: u8
      //X  
    }

    fun main() {
        let t = T { my_field: 1 };
                  //^
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_field_inside_incomplete_plus_expr() {
    check_resolve(
        r#"
module 0x1::m {
    struct S { val: u8 }
              //X
    fun main() {
        let s: S;
        assert!(s.val +)
                 //^
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_struct_from_another_module_can_be_created_in_specs() {
    check_resolve(
        r#"
module 0x1::m {
    struct Coin { val: u8 }
          //X
}
module 0x1::main {
    use 0x1::m;
    spec module {
        let _ = m::Coin { val: 10 };
                   //^
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_positional_struct_type_as_a_type() {
    check_resolve(
        r#"
module 0x1::m {
    struct S(u8);
         //X
    fun main(s: S) {
              //^  
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_access_fields_of_imported_structs_in_specs() {
    check_resolve(
        r#"
module 0x1::coin {
    struct Coin { value: u64 }
                 //X
    public fun get_coin(): Coin { Coin { value: 10 } }
}        
module 0x1::m {
    use 0x1::coin::get_coin;
    
    spec module {
        get_coin().value;
                     //^
    } 
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_field_for_vector_inferred_type() {
    check_resolve(
        r#"
module 0x1::M {
    struct ValidatorInfo { field: u8 }
                          //X
    native public fun vector_empty<El>(): vector<El>;
    native public fun vector_push_back<PushElement>(v: &mut vector<PushElement>, e: PushElement);
    native public fun vector_borrow_mut<BorrowElement>(v: &mut vector<BorrowElement>, i: u64): &mut BorrowElement;
    fun call() {
        let v = vector_empty();
        let item = ValidatorInfo { field: 10 };
        vector_push_back(&mut v, item);
        vector_borrow_mut(&mut v, 10).field;
                                      //^
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_reference_to_field_from_pattern() {
    check_resolve(
        r#"
module 0x1::M {
    struct T {
        my_field: u8
      //X  
    }

    fun main() {
        let T { my_field: my_field_1 } = call();
              //^
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_positional_field_lookup_type() {
    check_resolve(
        r#"
module 0x1::m {
    struct S(u8);
            //X
    fun main(s: S) {
        s.0;
        //^
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_field_in_test() {
    check_resolve(
        r#"
module 0x1::M {
    struct S<K, V> { val: u8 }
                   //X
    fun get_s<K, V>(): S<K, V> { S<u8, u8> { val: 10} }
    #[test]
    fun test_s() {
        let s = get_s();
        s.val;
         //^
    }
} 
"#,
    )
}

// language=Move
#[test]
fn est_resolve_field_for_borrow_global_mut() {
    check_resolve(
        r#"
module 0x1::M {
    struct CapState<phantom Feature> has key { delegates: vector<address> }
                                                 //X
    fun m() acquires CapState {
        borrow_global_mut<CapState<u8>>(@0x1).delegates;
                                               //^
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_resolve_field_from_include_schema() {
    check_resolve(
        r#"
module 0x1::m {
    struct S { val: u8 }
              //X
    spec schema MySchema {
        schema_val: u8;
    }
    spec module {
        let s = S { val: 10 };
        include MySchema {
            schema_val: s.val
                         //^
        };
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_field_inside_incomplete_inequal_expr() {
    check_resolve(
        r#"
module 0x1::m {
    struct S { val: u8 }
              //X
    fun main() {
        let s: S;
        assert!(s.val !=)
                 //^
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_reference_to_field_from_pattern_shorthand() {
    check_resolve(
        r#"
module 0x1::M {
    struct T {
        my_field: u8
      //X  
    }

    fun main() {
        let T { my_field } = call();
              //^
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_reference_to_field_from_lit_shorthand() {
    check_resolve(
        r#"
module 0x1::M {
    struct T {
        my_field: u8
      //X
    }

    fun main() {
        let my_field = 1;
             //X
        T { my_field };
           //^
    }
}
"#,
    )
}

// language=Move
#[test]
fn test_resolve_field_inside_incomplete_equal_expr() {
    check_resolve(
        r#"
module 0x1::m {
    struct S { val: u8 }
              //X
    fun main() {
        let s: S;
        assert!(s.val ==)
                 //^
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_field_for_parameter_type() {
    check_resolve(
        r#"
module 0x1::M {
    struct Cap<phantom Feature> has key { root: address }
                                         //X
    fun m<Feature>(cap: Cap<Feature>) {
        cap.root;
          //^          
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_unresolved_field_for_struct_in_a_different_module() {
    check_resolve(
        r#"
module 0x1::M1 {
    struct S { val: u8 }
    public fun get_s(): S { S { val: 10 } }
}        
module 0x1::M {
    use 0x1::M1;
    fun main() {
        M1::get_s().val
                   //^ unresolved
    }            
} 
"#,
    )
}

// language=Move
#[test]
fn test_resolve_struct_field_through_lambda_inference() {
    check_resolve(
        r#"
module 0x1::m {
    struct S { val: u8 }
              //X
    fun call_on<Element>(i: Element, f: |Element|) {}
    fun main() {
        let select_val = |s| {
            s.val;
             //^
        };
        let t = S { val: 1 };
        call_on(t, select_val);
    }
}        
"#,
    )
}

// language=Move
#[test]
fn test_resolve_fields_from_dot_access_to_struct_reference() {
    check_resolve(
        r#"
module 0x1::M {
    struct Option<Element> has copy, drop, store {
        vec: vector<Element>
      //X  
    }
    
    public fun is_none<Element>(t: &Option<Element>) {
        &t.vec;
          //^
    }
}    
"#,
    )
}

// language=Move
#[test]
fn test_resolve_enum_fields_in_a_tuple_return_type() {
    check_resolve(
        r#"
module 0x1::M {
    enum Node<K: store, V: store> has store {
        V1 {
            is_leaf: bool,
             //X
            prev: u64,
            next: u64,
        }
    }
    struct Option<Element> has copy, drop, store {
        vec: Element
    }
    fun get_node<T>(): (Option<T>, u8) {
    }
    fun main() {
        let (node, _) = get_node<Node>();
        node.vec.is_leaf
                //^
    }
}
"#,
    )
}
