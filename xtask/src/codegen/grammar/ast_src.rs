//! Defines input for code generation process.

pub(crate) struct KindsSrc<'a> {
    pub(crate) punct: &'a [(&'a str, &'a str)],
    pub(crate) keywords: &'a [&'a str],
    pub(crate) contextual_keywords: &'a [&'a str],
    pub(crate) literals: &'a [&'a str],
    pub(crate) tokens: &'a [&'a str],
    pub(crate) nodes: &'a [&'a str],
}

#[rustfmt::skip]
pub(crate) const KINDS_SRC: KindsSrc = KindsSrc {
    punct: &[
        (";", "SEMICOLON"),
        (",", "COMMA"),
        ("(", "L_PAREN"),
        (")", "R_PAREN"),
        ("{", "L_CURLY"),
        ("}", "R_CURLY"),
        ("[", "L_BRACK"),
        ("]", "R_BRACK"),
        ("<", "L_ANGLE"),
        (">", "R_ANGLE"),
        ("@", "AT"),
        ("#", "POUND"),
        ("&", "AMP"),
        ("|", "PIPE"),
        ("+", "PLUS"),
        ("*", "STAR"),
        ("/", "SLASH"),
        ("^", "CARET"),
        ("%", "PERCENT"),
        ("_", "UNDERSCORE"),
        (".", "DOT"),
        ("..", "DOT_DOT"),
        (":", "COLON"),
        ("::", "COLON_COLON"),
        ("=", "EQ"),
        ("==", "EQ_EQ"),
        ("=>", "FAT_ARROW"),
        ("==>", "IMPLIES"),
        ("<==>", "LESS_IMPLIES"),
        ("!", "BANG"),
        ("!=", "NOT_EQ"),
        ("-", "MINUS"),
        ("<=", "LT_EQ"),
        (">=", "GT_EQ"),
        ("+=", "PLUS_EQ"),
        ("-=", "MINUS_EQ"),
        ("|=", "PIPE_EQ"),
        ("&=", "AMP_EQ"),
        ("^=", "CARET_EQ"),
        ("/=", "SLASH_EQ"),
        ("*=", "STAR_EQ"),
        ("%=", "PERCENT_EQ"),
        ("&&", "AMP_AMP"),
        ("||", "PIPE_PIPE"),
        ("<<", "SHL"),
        (">>", "SHR"),
        ("<<=", "SHL_EQ"),
        (">>=", "SHR_EQ"),
    ],
    keywords: &[
        // top-level items
        "address", "module", "script", "spec", "fun", "struct", "const", "friend", "use",
        "public", "native", "if", "else", "true", "false", "loop", "while", "continue", "break",
        "as", "return", "move", "let", "mut", "abort",
        "invariant", "acquires", "inline",
    ],
    contextual_keywords: &[
        "entry", "package", "match", "for", "in", "is", "phantom", "enum", "has",
        "assert", "assume", "requires", "ensures", "aborts_if", "post",
        "succeeds_if", "aborts_with", "decreases", "modifies", "with",
        "axiom", "include", "pragma", "global", "local", "update", "copy", "schema",
        "emits", "apply", "to", "except", "internal",
        "forall", "exists", "choose", "where", "min",
    ],
    literals: &["INT_NUMBER", "BYTE_STRING", "HEX_STRING"],
    tokens: &["BAD_CHARACTER", "ERROR", "IDENT", "WHITESPACE", "QUOTE_IDENT", "COMMENT", "WILDCARD_IDENT"],
    nodes: &[
        "SOURCE_FILE",
        "ADDRESS_DEF",
        "MODULE",
        "SCRIPT",
        "MODULE_SPEC",
        "ITEM_SPEC",
        "STRUCT",
        "FRIEND",
        "ENUM",
        "FUN",
        "SPEC_FUN",
        "SPEC_INLINE_FUN",
        "USE_STMT",
        "USE_SPECK",
        "USE_GROUP",
        "USE_ALIAS",
        "CONST",
        // "MACRO_CALL",
        "TYPE",
        "RET_TYPE",
        "PAREN_TYPE",
        "TUPLE_TYPE",
        "PATH_TYPE",
        "LAMBDA_TYPE",
        "LAMBDA_TYPE_PARAM",
        "REF_TYPE",
        "UNIT_TYPE",
        // "INFER_TYPE",
        // "OR_PAT",
        // "PAREN_PAT",
        // "REF_PAT",
        // "BOX_PAT",
        "PAT",
        "IDENT_PAT",
        "WILDCARD_PAT",
        "REST_PAT",
        "PATH_PAT",
        "STRUCT_PAT",
        "STRUCT_PAT_FIELD_LIST",
        "STRUCT_PAT_FIELD",
        "TUPLE_STRUCT_PAT",
        "TUPLE_PAT",
        // "SLICE_PAT",
        // "RANGE_PAT",
        // "LITERAL_PAT",
        // "MACRO_PAT",
        // "CONST_BLOCK_PAT",
        // // atoms
        "TUPLE_EXPR",
        "ANNOTATED_EXPR",
        // "ARRAY_EXPR",
        "PAREN_EXPR",
        "PATH_EXPR",
        "LAMBDA_EXPR",
        "LAMBDA_PARAM_LIST",
        "LAMBDA_PARAM",
        "IF_EXPR",
        "WHILE_EXPR",
        "CONDITION",
        "LOOP_EXPR",
        "FOR_EXPR",
        "FOR_CONDITION",
        "ABORT_EXPR",
        "RETURN_EXPR",
        "CONTINUE_EXPR",
        "BREAK_EXPR",
        "LABEL",
        "INLINE_EXPR",
        "BLOCK_EXPR",
        "SPEC_BLOCK_EXPR",
        "STMT_LIST",
        "VECTOR_LIT_EXPR",
        "MATCH_EXPR",
        "MATCH_ARM_LIST",
        "MATCH_ARM",
        "MATCH_GUARD",
        "STRUCT_LIT",
        "STRUCT_LIT_FIELD_LIST",
        "STRUCT_LIT_FIELD",
        // postfix
        "CALL_EXPR",
        "ASSERT_MACRO_EXPR",
        "INDEX_EXPR",
        "DOT_EXPR",
        "METHOD_CALL_EXPR",
        "CAST_EXPR",
        "IS_EXPR",
        // unary
        "REF_EXPR",
        "PREFIX_EXPR",
        "RANGE_EXPR",
        "UNIT_EXPR",
        "BIN_EXPR",
        "INVARIANT_STMT",
        "EMITS_STMT",
        "EMITS_CONDITION",
        "PRAGMA_STMT",
        "PRAGMA_ATTR_ITEM",
        "AXIOM_STMT",
        "UPDATE_STMT",
        "ABORTS_IF_STMT",
        "ABORTS_IF_WITH",
        "ABORTS_WITH_STMT",
        "SPEC_PREDICATE_STMT",
        "SPEC_PREDICATE",
        "SPEC_PREDICATE_PROPERTY_LIST",
        "SPEC_PREDICATE_PROPERTY",
        "GLOBAL_VARIABLE_DECL",

        "SCHEMA",
        "SCHEMA_FIELD",
        "INCLUDE_SCHEMA",

        // "INCLUDE_EXPR",
        // "SCHEMA_INCLUDE_EXPR",
        // "AND_INCLUDE_EXPR",
        // "IMPLY_INCLUDE_EXPR",
        // "IF_ELSE_INCLUDE_EXPR",

        "APPLY_SCHEMA",
        "APPLY_TO",
        "APPLY_EXCEPT",
        "WILDCARD_PATTERN_MODIFIER",
        "WILDCARD_PATTERN",
        "SCHEMA_LIT",
        "SCHEMA_LIT_FIELD",

        "FORALL_EXPR",
        "EXISTS_EXPR",
        "CHOOSE_EXPR",
        "WHERE_EXPR",
        "QUANT_BINDING_LIST",
        "QUANT_BINDING",

        "STRUCT_FIELD_LIST",
        "STRUCT_FIELD",
        "TUPLE_FIELD_LIST",
        "TUPLE_FIELD",
        "VARIANT_LIST",
        "VARIANT",
        "ITEM_LIST",
        "ITEM",
        "ABILITY_LIST",
        "ABILITY_BOUND_LIST",
        "ABILITY",
        "ATTR",
        "ATTR_ITEM",
        "PATH",
        "PATH_SEGMENT",
        "PATH_ADDRESS",
        "LITERAL",
        "VISIBILITY_MODIFIER",
        "NAME",
        "NAME_REF",
        "VALUE_ADDRESS",
        "NAMED_ADDRESS",
        "ADDRESS_REF",
        "ADDRESS_LIT",
        "LET_STMT",
        "EXPR_STMT",
        "TYPE_PARAM_LIST",
        "TYPE_PARAM",
        "TYPE_ARG_LIST",
        "TYPE_ARG",
        "ARG_LIST",
        "PARAM_LIST",
        "PARAM",
        "ACQUIRES",
        // "TYPE_BOUND",
        // "TYPE_BOUND_LIST",

        // "LIFETIME_PARAM",
        // "CONST_PARAM",
        // "LIFETIME",
        // "LIFETIME_ARG",
        // "ASSOC_TYPE_ARG",
        // "CONST_ARG",
        // "SELF_PARAM",
    ],
};

pub(crate) const REQUIRED_METHOD_FIELDS: &[(&str, &[&str])] = &[
    ("UseSpeck", &["path"]),
    ("Param", &["ident_pat"]),
    ("Path", &["segment"]),
    ("PathAddress", &["value_address"]),
    ("NameRef", &["ident"]),
    ("Name", &["ident"]),
    ("NamedAddress", &["ident"]),
    ("ValueAddress", &["int_number"]),
];

pub(crate) fn get_required_fields(node_name: &str) -> &[&str] {
    for (node, req_fields) in REQUIRED_METHOD_FIELDS {
        if (*node == node_name) {
            return req_fields;
        }
    }
    &[]
}

#[derive(Default, Debug)]
pub(crate) struct AstSrc {
    pub(crate) tokens: Vec<String>,
    pub(crate) nodes: Vec<AstNodeSrc>,
    pub(crate) enums: Vec<AstEnumSrc>,
}

#[derive(Debug)]
pub(crate) struct AstNodeSrc {
    pub(crate) doc: Vec<String>,
    pub(crate) name: String,
    pub(crate) traits: Vec<String>,
    pub(crate) fields: Vec<Field>,
}

#[derive(Debug, Eq, PartialEq)]
pub(crate) enum Field {
    Token {
        name: String,
        cardinality: Cardinality,
    },
    Node {
        name: String,
        ty: String,
        cardinality: Cardinality,
    },
}

#[derive(Debug, Eq, PartialEq)]
pub(crate) enum Cardinality {
    Required,
    Optional,
    Many,
}

#[derive(Debug)]
pub(crate) struct AstEnumSrc {
    pub(crate) doc: Vec<String>,
    pub(crate) name: String,
    pub(crate) traits: Vec<String>,
    pub(crate) variants: Vec<String>,
}
